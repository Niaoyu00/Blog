{"posts":[{"title":"ue4decal贴花","text":"decal贴花 材质 Tiling：平铺 Crop X：横向移动 Crop Y：纵向移动 08 - Parallax POM：侧面看也能看出高低差 Height Ratio：凸起部分的高度 Reference Plane：使用UsePOM会导致正常视角看贴花有显示bug，通过这个参数调整。 抖动，使颜色混合","link":"/Blog/2021/10/27/decal/"},{"title":"git指令","text":"1231.配置提交人姓名: git config --global user.name提交人姓名2.配置提交人姓名: git config --global user.email提交人邮箱3.查看git配置信息: git config --list 1234git init |初始化git仓库git status |查看文件状态git add 文件列表 |提交到暂存区git commit -m 提交信息 |向仓库提交代码 用==暂存区==中的文件覆盖==电脑工作目录==的文件：git checkout 文件名 将文件从暂存区里删除: git rm --cached 文件 将git仓库中置顶的更新==记录恢复==出来，并且覆盖==暂存区和工作目录==: git reset --hard commitID 分支命令功能分支 -&gt; 开发分支 -&gt; 主分支 git branch 查看分支 git branch 分支名称 创建分支 git checkout 分支名称 切换分支 git merge 来源分支 ==合并分支== git branch -d 分支名称 删除分支（分支被合并后才允许删除）（-D 强制删除） 暂时保存更改在git中，可以暂时提取分支上所有的改动并存储，让开发人员得到一个干净的工作副本，临时转向其他工作。 使用场景：分支临时切换 存储临时改动：git stash 恢复改动：git stash pop 本地仓库推送到远程仓库 git push 远程仓库地址 分支名称 git remote add 远程仓库==地址别名== 远程仓库地址 git push 远程仓库==地址别名== 分支名称 git push ==-u== 远程仓库地址别名 分支名称 -u 记住推送地址及分支，==下次推送==只需要输入==git push==即可 拉取操作克隆仓库克隆远端数据仓库到本地：git clone 仓库地址 拉取远程仓库中最新的版本：git pull 远程仓库地址 分支名称 解决冲突在多人同时开发一个项目时，如果两个人修改了同一个文件的同一个地方，就会发生冲突。冲突需要人为解决。 跨团队协作 程序员 C fork仓库 程序员 C 将仓库克隆在本地进行修改 程序员 C 将仓库推送到远程 程序员 C 发起pull reqest 原仓库作者审核 原仓库作者合并代码 ssh免登陆生成秘钥：ssh-keygen 秘钥存储目录：C:\\Users\\用户\\.ssh 公钥名称：id_rsa.pub 私钥名称：id_rsa 公钥放在github 私钥放在本地 GIT忽略清单将不需要被git管理的文件名字添加到此文件中，在执行git命令的时候，git就会忽略这些文件。 git忽略清单文件名称：**.gitignore** 将工作目录中的文件全部添加到暂存区：git add .","link":"/Blog/2022/03/01/git%E6%8C%87%E4%BB%A4/"},{"title":"unity的Axis设置","text":"unity的Axis设置unity的Axis设置，路径为Edit-&gt;Project setting-&gt;Input: 属性如下： Name：==按键名==该键的名称，可以在脚本编程中直接引用他。比如：Input.GetButtonDown(“Jump”); Descriptive Name:==【描述名】==在游戏的独立机构中的配置对话框中，当控制值为正时候所显示的名称。默认空白。 Negative Descriptive Name：==【负描述】==在游戏的独立机构中的配置对话框中，当控制值为负的时候所显示的名称。 Nagative Button：==【负向按钮】==玩家按下这个按钮来让被控制物体向负方向运动。 Positive Button：==【正向按钮】==玩家按下这个按钮让被控制物体向正方向运动。 Alt Negative Button: 玩家可以使用的备选负向按钮，比如方向键和WASD Alt Positive Button：玩家可以使用的备选争相按钮。 Gravity：==【重力】==如果玩家停止输入，该轴将恢复到空挡或0速度，其单位为单位每秒。 Dead：==【盲区】==可以用在模拟控制。在模拟控制器上，在这个范围内的任何值都会映射到空档不会提供任何输入。 Sensitivity：==【灵敏度】==可以用于数字控制，他是该轴向给定得值移动的速度。正负都可，单位为单位每秒。 Snap：==【对齐】==如果选中，可以确保在同时按下正向和负向按钮时候该轴的值为空挡。 Invert：==【反转】==迅速交换正向和负向控制键。 Type：==【类型】==该键对应的输入设备类型。可以为Key，MouseButton，MouseMove，JoystickAxis，或Window Movement。 Axis：==【轴】==这个控制方式有该输入设备的哪条轴指挥。这可受不同游戏手柄影响。 JoyNum：==【操作杆编号】==多个操作杆在机器上市后，决定哪个哪个操作杆控制给定的轴。可以选择从所有的操作杆接受输入，或是为其制定一个特定的。","link":"/Blog/2022/02/27/unity%E7%9A%84Axis%E8%AE%BE%E7%BD%AE/"},{"title":"ue4材质笔记","text":"简明PBR2：介绍了菲尼尔，以及两个网站可以查折射率 材质基础 常量Constant：不能在材质实例中调整 变量Variable：可以在材质中调整 右键可以转换常量或变量 矢量Vector：表示颜色、坐标信息 标量Scalar：常用参数调整手段 用作展示颜色节点Variable3Vector节点 可调整参数ScalarParameter节点 调用贴图 TextureCoordinate 控制纹理平铺 lerp线性插值 lerp可以混合两种颜色，加上一个标量来控制 也可以混合法线贴图，前台控制法线程度 2022年5月10日编辑:ue4材质内容基本忘光了,留着文章就当记录了.","link":"/Blog/2021/10/15/ue4%E6%9D%90%E8%B4%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"协调程序","text":"协程：协同程序协程的使用前提：直接或间接的继承MonoBehavior才可以使用。 不足：会产生外的开销。 协程方法与普通方法的区别：被调用时：普通方法被调用时，原来执行的部分保留现场，停止执行，然后去执行要调用的方法，并且，被调用的方法执行完之后才能返回到调用前的状态接着往下执行。。。协同方法的执行是不用等协同方法执行完再执行调用之前原来方法的代码。而是两者==异步执行==。 类似js的异步","link":"/Blog/2022/03/03/%E5%8D%8F%E7%A8%8B/"},{"title":"Ue4材质快捷键（转载）","text":"UE4材质的快捷键（转载）虚幻材质里面的快捷键注：以下快捷键都需要结合鼠标左键来创建 首先是数字键1234分别对应的是1234维的常数节点，然后这里有个主意的地方就是1维常数的参数快捷键是S，三维常数的参数快捷键是V。 然后是ABCD ，A是Add加法节点， B是bumpoffset凹凸偏移，C是注释，D是Divide除法节点，当然还有我们的M,multiply乘法节点 E就是我们的power节点了，F这个节点目前还不是很熟悉是一个UNspecified function什么类型的函数，欢迎补充。 L就是线性插值这个节点了。非常重要的！ I是一个IF函数节点 N是我们的normalize O就是我们的1-x函数了one minus 反转~~ P是panner平移节点 R是refelction vector 反射向量 T是Texture sample贴图节点，经常会用到。 最后是U，UV贴图平铺的一个节点，也很重要 作者：墨一良丶 https://www.bilibili.com/read/cv7905584?spm_id_from=333.999.0.0 出处：bilibili","link":"/Blog/2022/02/18/%E6%9D%90%E8%B4%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"title":"Ue4材质边界混合","text":"边界混合 世界坐标纹理对齐，实现效果大概是：在地面添加物体，任意改变形状位置，材质纹理会自动对齐。 边界混合2解决PDO抖动显示问题","link":"/Blog/2021/10/30/%E8%BE%B9%E7%95%8C%E6%B7%B7%E5%90%88/"},{"title":"ue4顶点绘制","text":"网格体绘制（顶点绘制） 步骤混合材质 打开这个，依顺序从底层-&gt;中间层-&gt;顶层进行选择。 截图里红色框命名，蓝色框确认，创建后就是混合后的材质。 然后将混合后材质拖进平面，调整平铺比例（视频里材质UV是4x4，而box盒子是一米见方，因此需要调整混合后材质的uv，将材质02-Base Layer参数平铺x平铺y改成四分之一） 绘制 模式=&gt;网格体绘制 选择平面 选绘制，切换成黑色 通道选择：红：中间层 绿：顶层 蓝：水坑层（默认需要激活） 擦除：按住shift再画高度混合方法在混合材质界面，给底层BaseLayer添加，基础层置换贴图-displacement map 之后在这里微调效果 大致效果： 顶层也可以这么操作。 Global可调节饱和度，亮度、对比度 粗糙度调节 使用独立的置换调整值 右边的勾勾，勾选之后06-displacement会增加选项 选中哪个层调数值，相当于把那个层移高，或者下降 缺点： 细看有瑕疵 性能消耗（需要去材质蓝图关闭）。 调整水材质 Liquid Color：水颜色 Liquid Opacity：透明度 （水的深/浅） Liquid Falloff Roughness：边缘过渡的粗糙度（数值越小边缘越湿润） Albedo Darkening Color：液体调白色=&gt;模拟物体防水表面。液体调暗=&gt;模拟物体表面渗入性 Liquid Wave Controls：波浪调整 浪花大小（数值越小浪花越大） 浪花速度 上方水面 法线贴图的强度 无 2和3一般一起调整。","link":"/Blog/2021/10/25/%E9%A1%B6%E7%82%B9%E7%BB%98%E5%88%B6/"},{"title":"unity塔防demo记录","text":"塔防demo参考项目:https://www.bilibili.com/video/BV15W411976h新加的功能1.怪物球自转 2.不同炮台只可在特定颜色，区域内建造。 3.未选中炮台不可建造 遇到的问题炮弹打中敌人之后发现后方的一个怪会持续扣血直到死亡。初步猜测是碰撞触发了多次，后来暂停看的时候发现，子弹爆炸特效(在子弹销毁时触发) 在敌人死亡的时候会一下子刷出特别多。因此我判断是子弹打入敌人之后没有实时销毁。运行一测，果然是。最后在子弹脚本中，释放子弹爆炸特效的前方增加了销毁自身的代码。修复了bug。 待续..","link":"/Blog/2022/03/09/unity%E5%A1%94%E9%98%B2demo%E8%AE%B0%E5%BD%95/"},{"title":"计算器","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576using System;using System.Linq;namespace Calculator{ class Program { static void Main(string[] args) { for (int i = 0; i &lt; 3; i++) { string inputStr = Console.ReadLine(); CalcOnline(inputStr); } } static CalcInfo[] configs = new CalcInfo[] { new CalcInfo(&quot;+&quot;,(a,b)=&gt;a+b), new CalcInfo(&quot;-&quot;,(a,b)=&gt;a-b), new CalcInfo(&quot;*&quot;,(a,b)=&gt;a*b), new CalcInfo(&quot;/&quot;,(a,b)=&gt;a/b), }; private static void CalcOnline(string inputStr) { int index = -1; Func&lt;float, float, float&gt; func = null; for (int i = 0; i &lt; configs.Length; i++) { var item = configs[i]; index = inputStr.IndexOf(item.tag);//找到符号，返回所在下标，未找到返回-1 if (index != -1) { func = item.func;//如果找到的是+，那么index为1，+的func函数内容是a+b break; } } if (index == -1) { Console.WriteLine(&quot;只支持+-*/&quot;); return; } CalcResult(inputStr, func, index); } private static void CalcResult(string inputStr, Func&lt;float, float, float&gt; func, int index) { string num1Str = inputStr.Substring(0, index);//0~index之间的内容(不包括后面的)赋值给num1Str，若输入1+2则获得1 int strLen = inputStr.Count(); Console.WriteLine($&quot;strLen:{strLen},index:{index}&quot;); string num2Str = inputStr.Substring(index+1,strLen-index-1);//若输入1+2则获得2 float num1 = float.Parse(num1Str); float num2 = float.Parse(num2Str); Console.WriteLine($&quot;num1:{num1}, num2:{num2}&quot;); float result = func(num1, num2); Console.WriteLine($&quot;{inputStr}的计算结果：{result}&quot;); } } public class CalcInfo { public string tag; public Func&lt;float, float, float&gt; func; public CalcInfo(string tag, Func&lt;float, float, float&gt; func) { this.tag = tag; this.func = func; } }}////5+6//strLen:3,index:1//num1:5, num2:6//5+6的计算结果：11","link":"/Blog/2022/02/23/Csharp%E8%AE%A1%E7%AE%97%E5%99%A8/"},{"title":"Csharpclass与struct的关系","text":"值与引用的关系 值类型在栈中存储 引用类型在堆中存储 ==Class==的值在堆里，地址在栈。(栈开一个空间存储地址，通过地址在堆里找到创建的值。) ==Struct==直接在栈里开辟空间来存储值。 此处为cVec的地址与sVec x,sVec Y，开辟了三个。 再来看函数内部： 更改了cvec与svec的x值， 此时**cVec.print()**打印的值为 1cVec(100,0) **sVec.print()**打印的值也为 sVec(100,0) 函数调用结束，目光回到上面初始开辟的空间。 下方的**cVec.print()，sVec.print()**； 打印结果为： cVec(100,0) sVec(0,0) 因为sVec是函数内创建的值，在外面他没有更改。而cVec是通过地址找到堆里的值，在函数里已经将值更改。 如果想要Struct的值跟class一样，需要再前面加ref","link":"/Blog/2022/02/21/CsharpClass%E4%B8%8EStruct%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"title":"委托","text":"委托delegate：可以保存多个函数指针，试用=+，-+进行操作。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//将函数赋值给delegate，delegate会储存下来。 //Action无返回值 Action&lt;string&gt; print = Print; print(&quot;使用print打印&quot;); Func&lt;float,float,float&gt; fc = Mul;//打印：Func，第三个参数是返回值类型 var f = fc(3, 4).ToString(); //打印：乘法3 * 4 = 12 Console.WriteLine(f);//打印：12 CalFunc func = Add; func(1.1f, 2);//打印：加法1.1+2=3.1 Console.WriteLine(&quot;加入Sub()&quot;); func += Sub; func(1.1f, 2);//打印：减法1.1+2=3.1 //1.1-2=-0.9 Console.WriteLine(&quot;移除Add()&quot;); func -= Add; func(1.1f, 2);//打印：减法1.1-2=-0.9 Console.WriteLine(&quot;-------------闭包↓----------------&quot;); int intVal = 10; //匿名函数 执行后改变的值可作用到函数外。 Action aa = () =&gt; { intVal += 10; }; aa();//调用 Console.WriteLine(intVal);//打印：20//无返回值，封装了一个print代替writeline static void Print(string info) =&gt;Console.WriteLine(info); //定义了delegate，可以存储函数指针 delegate float CalFunc(float f1, float f2); //下面是好几个函数，实现加减乘。 static float Add(float arg1, float arg2) { Console.WriteLine($&quot;加法{arg1}+{arg2}={arg1 + arg2}&quot;); return arg1 + arg2; } static float Sub(float arg1, float arg2) { Console.WriteLine($&quot;减法{arg1}-{arg2}={arg1 - arg2}&quot;); return arg1 - arg2; } static float Mul(float arg1, float arg2) { Console.WriteLine($&quot;乘法{arg1}*{arg2}={arg1 * arg2}&quot;); return arg1 * arg2; }","link":"/Blog/2022/02/22/%E5%A7%94%E6%89%98/"},{"title":"github图床搭建","text":"github图床搭建​ gitee的图床居然炸了？！难怪我之前看网站里图片都没了，一直没意识到是gitee的问题。因为本人前段时间重装电脑系统，导致今天整理笔记的时候要重新配置picgo的图床，刚配置完一看图片显示都是空的…我一直怀疑是因为我typora没升级付费版，所以他不给显示。网上查了半天，最后才发现是gitee加了防盗链，虽然说拿他白嫖做图床有点不厚道，但是你既然开放了这个功能，要停的话至少提前说一下嘛。算了，回到重点，下面是github图床搭建流程，在此记录下来以后忘了可以看看： 1、新建一个github仓库，clone到本地，然后将gitee旧图片文件夹拷进来再上传。完成后大概是这样： 2、仓库搞完去获取个人令牌 名字随便取，自己记得就好。日期选无限期。下方选repo 然后获取token，记得复制 3、打开picgo输入相应数据仓库名直接复制github的http链接，删一下前半部分https://github.com/还有最后的.git就行。指定存储路径最好别填，我试了很容易上传失败。 4、打开typora中文件-&gt;偏好设置-&gt;图像 按图片中操作完测试下","link":"/Blog/2022/05/23/git%E5%9B%BE%E5%BA%8A/"},{"title":"unity中查找对象的五种方法","text":"unity中查找对象的五种方法 通过对象名称（Find方法） GameObject.Find(&quot;name&quot;) 通过标签获取单个游戏对象（FindWithTag方法） GameObject.FindWithTag(&quot;Tag&quot;); 通过标签获取多个游戏对象（FindGameObjectsWithTags方法） 通过类型获取单个游戏对象（FindObjectOfType方法） 通过类型获取多个游戏对象（FindObjectsOfType方法）","link":"/Blog/2022/05/12/unity%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%94%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"title":"ScriptableObject简单使用","text":"ScriptableObject平时开发存在的一些问题： 一个场景内有多个相同组件使用相同数值的时候，这个组件也在内存中多了一份实例，浪费内存空间。 static或者[Serializable]修饰的变量，在程序退出后会还原。编辑器模式运行时，只能通过Copy Component Values来临时保存调整好的数值。 项目之间、场景之间数据很难共享。 在runtime下要改变某个GameObject上组件的数值，就一定要获取到这个GameObject实例，使项目耦合度成倍提高，最后变成蜘蛛网。 场景中总会有一些空的GameObject用来保存和共享数据，这个GameObject基本不会参与太多的游戏逻辑，但为了保存和共享场景内的数据就不得不碍眼的在场景中出现，逼死强迫症，也不利于模块抽象。 同样，要通过UGUI Button中的On Click事件调用一个GameObject上的方法，也只能获取到GameObject实例来调用，数量太多的话也变成了蜘蛛网。 使用ScriptableObject如何解决 ScriptableObject是将数据存储在.asset文件中的，可以理解为类似material这样的文件，ScriptableObject中存储的数值在runtime中作出修改，在退出后也会被保存下来。 同样，类似material文件，在多个地方需要用到同一个数据，只要把ScriptableObject生成的.asset文件拖入相应位置就可以，不必再指向某个单例或者实例。 可以被任何场景引用，在项目之间、场景之间很容易的共享数据。 不必为了保存数据在场景中放置一个空GameObject。让项目的复杂度和耦合度最大限度的降低，强迫症福音。 ScriptableObject是自定义的数据类型，应用非常灵活。 通过UGUI Button中的On Click事件只需要指向某一个ScriptableObject文件，而响应事件的GameObject也只需要获取到这个ScriptableObject文件即可触发，不必让按钮指向GameObject实例。大幅度减少了项目逻辑和结构的复杂程度。 需求 通过ScriptableObject获取一个GameObject的实例。 不获取物体实例，通过ScriptableObject实现UnityEvent的执行。 角色：player,enemy; 场景内会在随机位置生成任意数量的敌人，敌人会追着player一直跑，player通过移动来躲避敌人，每次碰到敌人就会减少生命值。 开始实现搭建场景和角色敌人: 新建脚本FollowTransformSmooth，实现追踪功能，拖到enemy上面。123456789101112131415161718192021public class FollowTransformSmooth : MonoBehaviour{ //[SerializeField] Transform target; [SerializeField] TargetTransform target; [SerializeField] Rigidbody selfRigidbody; [SerializeField, Range(0f, 100f)] float moveSpeed = 10f; Vector3 _destination;//目的地 Vector3 _direction;//方向 void LateUpdate() {//LateUpdate 在调用所有 Update 函数后调用。 //_destination = target.position;//怪物追踪目的地 _destination = target.targetTrans.position;//怪物追踪目的地 _direction = (_destination - transform.position).normalized;//怪物前进方向 //AddForce,向刚体添加力,(vector3方向,ForceMode力类型) selfRigidbody.AddForce(_direction * moveSpeed, ForceMode.Acceleration); // ForceMode.Force 向此刚体添加连续力，使用其质量。 // ForceMode.Acceleration 向此刚体添加连续加速度，忽略其质量。 // ForceMode.Impulse 向此刚体添加瞬时力冲击，考虑其质量。 // ForceMode.VelocityChange 向此刚体添加瞬时速度变化，忽略其质量。 }} 新建TargetTransform脚本，继承ScriptableObject，用来存储主角的位置信息12345[CreateAssetMenu(menuName = &quot;mySubMenu/TargetTransform &quot;)]public class TargetTransform : ScriptableObject{ public Transform targetTrans;} 编译完在文件夹新建TargetTransform，命名为Player 新建SetTarget脚本，主角位置数据赋值给TargetTransform。拖到player上12345678public class SetTarget : MonoBehaviour{ [SerializeField] TargetTransform target; void Awake() { target.targetTrans = gameObject.transform;//当前位置数据传递给TargetTransform }} 预制体上的配置：","link":"/Blog/2022/06/06/ScriptableObject/"},{"title":"unity滑条控制音量事件","text":"unity滑条控制音量事件slider.onValueChanged.AddListener1234slider.onValueChanged.AddListener((float v) =&gt; {//v等价于slider.value AudioTuning.Instance.SetMasterVolume(v); }); AudioTuning:12345678public class AudioTuning : SingLeton&lt;AudioTuning&gt;{ [SerializeField] AudioMixer audioMixer; public void SetMasterVolume(float volume) { audioMixer.SetFloat(&quot;MasterVolume&quot;, volume); }}","link":"/Blog/2022/05/12/unity%E6%BB%91%E6%9D%A1%E6%8E%A7%E5%88%B6%E9%9F%B3%E9%87%8F%E4%BA%8B%E4%BB%B6/"},{"title":"横板卷轴射击游戏笔记","text":"横板卷轴射击游戏笔记一、背景滚动实现方法 创建一个3d对象Quad,重命名为SimpleBackground,调整好大小(跟图片差不多大) 新建一个材质,设置shader为Unlit/Textu 将图片texture type设置为default，拖入材质。 将材质拖进SimpleBackground，这样就做好了背景。 通过实时更改材质中offset偏移值，来实现滚动效果 滚动代码如下：将Start()改为每帧刷新的协程(模拟Update()) 123456789101112131415Material material; [SerializeField] Vector2 scrollVelocity;//速度 void Awake() { material = GetComponent&lt;Renderer&gt;().material; } private IEnumerator Start() { while (GameManager.GameState != GameState.GameOver) //游戏状态不为gameover可运行场景滚动 { material.mainTextureOffset += scrollVelocity * Time.deltaTime; yield return null; } } 二、Input System动作输入系统Input System（安装包）实现了一个，可使用任何类型输入设备来控制unity内容的系统。它旨在替代unity旧的输入管理器（UnityEngine.Input类），并且更为强大，灵活易用。 安装输入系统Window-&gt;Pacjage Manager-&gt;UnityRegistry(搜索input)-&gt;安装 实现功能新建InputActions文件 打开InputActions，绑定输入信号。 创建c#文件,注意名字可自定，我取名为PlayerInputActions。 新建一个PlayInput类,继承于ScriptableObject,//ScriptableObject:一个类，如果需要创建【无需附加到游戏对象】的对象时，可从该类派生。【】表示强调。继承PlayerInputActions类中的几个接口，实现接口。 未完待续…(因为是好早之前看视频学的,详细的内容得去重看视频再补,目前还没那个时间)","link":"/Blog/2022/05/27/%E6%A8%AA%E6%9D%BF%E5%8D%B7%E8%BD%B4%E5%B0%84%E5%87%BB%E6%B8%B8%E6%88%8F%E7%AC%94%E8%AE%B0/"},{"title":"正则表达式(搬运)","text":"什么是正则表达式？ 正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。 一个正则表达式是一种从左到右匹配主体字符串的模式。“Regular expression”这个词比较拗口，我们常使用缩写的术语“regex”或“regexp”。正则表达式可以从一个基础字符串中根据一定的匹配模式替换文本中的字符串、验证表单、提取字符串等等。 想象你正在写一个应用，然后你想设定一个用户命名的规则，让用户名包含字符、数字、下划线和连字符，以及限制字符的个数，好让名字看起来没那么丑。我们使用以下正则表达式来验证一个用户名： 以上的正则表达式可以接受 john_doe、jo-hn_doe、john12_as。但不匹配Jo，因为它包含了大写的字母而且太短了。 目录 1. 基本匹配 2. 元字符 2.1 点运算符 . 2.2 字符集 2.2.1 否定字符集 2.3 重复次数 2.3.1 * 号 2.3.2 + 号 2.3.3 ? 号 2.4 {} 号 2.5 (…) 特征标群 2.6 | 或运算符 2.7 转码特殊字符 2.8 锚点 2.8.1 ^ 号 2.8.2 $ 号 3. 简写字符集 4. 零宽度断言(前后预查) 4.1 ?=… 正先行断言 4.2 ?!… 负先行断言 4.3 ?&lt;= … 正后发断言 4.4 ?&lt;!… 负后发断言 5. 标志 5.1 忽略大小写（Case Insensitive） 5.2 全局搜索（Global search） 5.3 多行修饰符（Multiline） 额外补充 贡献 许可证 1. 基本匹配正则表达式其实就是在执行搜索时的格式，它由一些字母和数字组合而成。例如：一个正则表达式 the，它表示一个规则：由字母t开始，接着是h，再接着是e。 \"the\" => The fat cat sat on the mat. 在线练习 正则表达式123匹配字符串123。它逐个字符的与输入的正则表达式做比较。 正则表达式是大小写敏感的，所以The不会匹配the。 \"The\" => The fat cat sat on the mat. 在线练习 2. 元字符正则表达式主要依赖于元字符。元字符不代表他们本身的字面意思，他们都有特殊的含义。一些元字符写在方括号中的时候有一些特殊的意思。以下是一些元字符的介绍： 元字符 描述 . 句号匹配任意单个字符除了换行符。 [ ] 字符种类。匹配方括号内的任意字符。 [^ ] 否定的字符种类。匹配除了方括号里的任意字符 * 匹配&gt;=0个重复的在*号之前的字符。 + 匹配&gt;=1个重复的+号前的字符。 ? 标记?之前的字符为可选. {n,m} 匹配num个大括号之前的字符或字符集 (n &lt;= num &lt;= m). (xyz) 字符集，匹配与 xyz 完全相等的字符串. &amp;#124; 或运算符，匹配符号前或后的字符. &amp;#92; 转义字符,用于匹配一些保留的字符 [ ] ( ) { } . * + ? ^ $ \\ | ^ 从开始行开始匹配. $ 从末端开始匹配. 2.1 点运算符 ..是元字符中最简单的例子。.匹配任意单个字符，但不匹配换行符。例如，表达式.ar匹配一个任意字符后面跟着是a和r的字符串。 \".ar\" => The car parked in the garage. 在线练习 2.2 字符集字符集也叫做字符类。方括号用来指定一个字符集。在方括号中使用连字符来指定字符集的范围。在方括号中的字符集不关心顺序。例如，表达式[Tt]he 匹配 the 和 The。 \"[Tt]he\" => The car parked in the garage. 在线练习 方括号的句号就表示句号。表达式 ar[.] 匹配 ar.字符串 \"ar[.]\" => A garage is a good place to park a car. 在线练习 2.2.1 否定字符集一般来说 ^ 表示一个字符串的开头，但它用在一个方括号的开头的时候，它表示这个字符集是否定的。例如，表达式[^c]ar 匹配一个后面跟着ar的除了c的任意字符。 \"[^c]ar\" => The car parked in the garage. 在线练习 2.3 重复次数后面跟着元字符 +，* or ? 的，用来指定匹配子模式的次数。这些元字符在不同的情况下有着不同的意思。 2.3.1 * 号*号匹配 在*之前的字符出现大于等于0次。例如，表达式 a* 匹配0或更多个以a开头的字符。表达式[a-z]* 匹配一个行中所有以小写字母开头的字符串。 \"[a-z]*\" => The car parked in the garage #21. 在线练习 *字符和.字符搭配可以匹配所有的字符.*。*和表示匹配空格的符号\\s连起来用，如表达式\\s*cat\\s*匹配0或更多个空格开头和0或更多个空格结尾的cat字符串。 \"\\s*cat\\s*\" => The fat cat sat on the concatenation. 在线练习 2.3.2 + 号+号匹配+号之前的字符出现 &gt;=1 次。例如表达式c.+t 匹配以首字母c开头以t结尾，中间跟着至少一个字符的字符串。 \"c.+t\" => The fat cat sat on the mat. 在线练习 2.3.3 ? 号在正则表达式中元字符 ? 标记在符号前面的字符为可选，即出现 0 或 1 次。例如，表达式 [T]?he 匹配字符串 he 和 The。 \"[T]he\" => The car is parked in the garage. 在线练习 \"[T]?he\" => The car is parked in the garage. 在线练习 2.4 {} 号在正则表达式中 {} 是一个量词，常用来限定一个或一组字符可以重复出现的次数。例如， 表达式 [0-9]{2,3} 匹配最少 2 位最多 3 位 0~9 的数字。 \"[0-9]{2,3}\" => The number was 9.9997 but we rounded it off to 10.0. 在线练习 我们可以省略第二个参数。例如，[0-9]{2,} 匹配至少两位 0~9 的数字。 \"[0-9]{2,}\" => The number was 9.9997 but we rounded it off to 10.0. 在线练习 如果逗号也省略掉则表示重复固定的次数。例如，[0-9]{3} 匹配3位数字 \"[0-9]{3}\" => The number was 9.9997 but we rounded it off to 10.0. 在线练习 2.5 (...) 特征标群特征标群是一组写在 (...) 中的子模式。(...) 中包含的内容将会被看成一个整体，和数学中小括号（ ）的作用相同。例如, 表达式 (ab)* 匹配连续出现 0 或更多个 ab。如果没有使用 (...) ，那么表达式 ab* 将匹配连续出现 0 或更多个 b 。再比如之前说的 {} 是用来表示前面一个字符出现指定次数。但如果在 {} 前加上特征标群 (...) 则表示整个标群内的字符重复 N 次。 我们还可以在 () 中用或字符 | 表示或。例如，(c|g|p)ar 匹配 car 或 gar 或 par. \"(c|g|p)ar\" => The car is parked in the garage. 在线练习 2.6 | 或运算符或运算符就表示或，用作判断条件。 例如 (T|t)he|car 匹配 (T|t)he 或 car。 \"(T|t)he|car\" => The car is parked in the garage. 在线练习 2.7 转码特殊字符反斜线 \\ 在表达式中用于转码紧跟其后的字符。用于指定 { } [ ] / \\ + * . $ ^ | ? 这些特殊字符。如果想要匹配这些特殊字符则要在其前面加上反斜线 \\。 例如 . 是用来匹配除换行符外的所有字符的。如果想要匹配句子中的 . 则要写成 \\. 以下这个例子 \\.?是选择性匹配. \"(f|c|m)at\\.?\" => The fat cat sat on the mat. 在线练习 2.8 锚点在正则表达式中，想要匹配指定开头或结尾的字符串就要使用到锚点。^ 指定开头，$ 指定结尾。 2.8.1 ^ 号^ 用来检查匹配的字符串是否在所匹配字符串的开头。 例如，在 abc 中使用表达式 ^a 会得到结果 a。但如果使用 ^b 将匹配不到任何结果。因为在字符串 abc 中并不是以 b 开头。 例如，^(T|t)he 匹配以 The 或 the 开头的字符串。 \"(T|t)he\" => The car is parked in the garage. 在线练习 \"^(T|t)he\" => The car is parked in the garage. 在线练习 2.8.2 $ 号同理于 ^ 号，$ 号用来匹配字符是否是最后一个。 例如，(at\\.)$ 匹配以 at. 结尾的字符串。 \"(at\\.)\" => The fat cat. sat. on the mat. 在线练习 \"(at\\.)$\" => The fat cat. sat. on the mat. 在线练习 3. 简写字符集正则表达式提供一些常用的字符集简写。如下: 简写 描述 . 除换行符外的所有字符 \\w 匹配所有字母数字，等同于 [a-zA-Z0-9_] \\W 匹配所有非字母数字，即符号，等同于： [^\\w] \\d 匹配数字： [0-9] \\D 匹配非数字： [^\\d] \\s 匹配所有空格字符，等同于： [\\t\\n\\f\\r\\p{Z}] \\S 匹配所有非空格字符： [^\\s] \\f 匹配一个换页符 \\n 匹配一个换行符 \\r 匹配一个回车符 \\t 匹配一个制表符 \\v 匹配一个垂直制表符 \\p 匹配 CR/LF（等同于 \\r\\n），用来匹配 DOS 行终止符 4. 零宽度断言（前后预查）先行断言和后发断言（合称 lookaround）都属于非捕获组（用于匹配模式，但不包括在匹配列表中）。当我们需要一个模式的前面或后面有另一个特定的模式时，就可以使用它们。 例如，我们希望从下面的输入字符串 $4.44 和 $10.88 中获得所有以 $ 字符开头的数字，我们将使用以下的正则表达式 (?&lt;=\\$)[0-9\\.]*。意思是：获取所有包含 . 并且前面是 $ 的数字。 零宽度断言如下： 符号 描述 ?= 正先行断言-存在 ?! 负先行断言-排除 ?&lt;= 正后发断言-存在 ?&lt;! 负后发断言-排除 4.1 ?=... 正先行断言?=... 正先行断言，表示第一部分表达式之后必须跟着 ?=...定义的表达式。 返回结果只包含满足匹配条件的第一部分表达式。定义一个正先行断言要使用 ()。在括号内部使用一个问号和等号： (?=...)。 正先行断言的内容写在括号中的等号后面。例如，表达式 (T|t)he(?=\\sfat) 匹配 The 和 the，在括号中我们又定义了正先行断言 (?=\\sfat) ，即 The 和 the 后面紧跟着 (空格)fat。 \"(T|t)he(?=\\sfat)\" => The fat cat sat on the mat. 在线练习 4.2 ?!... 负先行断言负先行断言 ?! 用于筛选所有匹配结果，筛选条件为 其后不跟随着断言中定义的格式。正先行断言 定义和 负先行断言 一样，区别就是 = 替换成 ! 也就是 (?!...)。 表达式 (T|t)he(?!\\sfat) 匹配 The 和 the，且其后不跟着 (空格)fat。 \"(T|t)he(?!\\sfat)\" => The fat cat sat on the mat. 在线练习 4.3 ?&lt;= ... 正后发断言正后发断言 记作(?&lt;=...) 用于筛选所有匹配结果，筛选条件为 其前跟随着断言中定义的格式。例如，表达式 (?&lt;=(T|t)he\\s)(fat|mat) 匹配 fat 和 mat，且其前跟着 The 或 the。 \"(?","link":"/Blog/2022/06/06/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"unity中Invoke用法","text":"Unity中Invoke用法Invoke方法是Unity3D 中的一种委托机制。现在看一下官网给出的API： public void Invoke(string methodName, float time); methodName 是方法名，time 是具体几秒 Invokes the method methodName in time seconds. 在具体事件以后调用这个方法 也就是说，Invoke(“SendMessage”,5) ,表示的是在“5s”以后执行“SendMessage”方法。 使用Invoke方法需要注意以下三点： 1、它应该在Start,Update,FixUpdate,LateUpdate,还有OnGUI中被调用 2、Invoke中传递的方法不能是含有参数的方法、 3、当Time.ScaleTime = 0时，Invoke()无效，调用不到Invoke方法 当然，Invoke也支持重复调用: InvokeRepeating(“SendMessage”,2,3); 表示在“2s”以后开始调用第一次，之后每隔“3s”重复调用一次。","link":"/Blog/2022/06/16/unity%E4%B8%ADInvoke%E7%94%A8%E6%B3%95/"},{"title":"使用vscode开发unity项目","text":"使用vscode开发unity项目仅做记录 vscode需要的插件如下： Auto-Using for C#，自动添加引用 Unity Code Snippets，unity代码补全 c#，必备 C# XML Documentation Comments，三下///实现xm注释l Code Runner，运行代码 GitHub Theme；eppz! (C# theme for Unity)；Gruvbox Theme；（三款编辑器皮肤 期间会提示安装.net framework，sdk包。 vscode字体设置:“editor.fontFamily”: “Fira Code Medium, ‘Courier New’, monospace” unity中打开edit-&gt;Preferences-&gt;External Tools,选中vscode，记得勾选下面前两行。","link":"/Blog/2022/07/12/%E4%BD%BF%E7%94%A8vscode%E5%BC%80%E5%8F%91unity%E9%A1%B9%E7%9B%AE/"},{"title":"(转载)Cinemachine Camera部分讲解和使用","text":"转载)Cinemachine Camera部分讲解和使用转载自知乎用户:Ouroboros 文章地址:https://zhuanlan.zhihu.com/p/516625841 本篇节选了body部分 在阅读以下文章之前先了解以下概念 Pitch Axis：俯仰轴 Roll Axis：翻转轴 Yaw Axis：航向轴 这三个轴与x，y，z坐标轴不同概念 Body 打开Body组件界面有7种算法 以下图片出现黄色感叹号是因为Follow没有挂载跟随目标 Do nothing 选择该算法后，该虚拟相机的坐标不会移动更新，通常为静态镜头选择此算法或使用自定义脚本直接为相机位置设置动画。通常和LookAt配合使用，模拟固定位置的跟随镜头。 3rd Person Follow选择该算法后虚拟相机会自动跟随任务移动，就是常见的第三人称视角 变量 含义 Damping 阻尼系数，指摄像机向x,y,z轴三个方向移动反应速度，系数越小反应越快，系数越大反应越慢，可以通过调整三个不同方向轴的阻尼系数来实现不同的移动效果。 Shoulder Offset 相对于跟随目标原点的肩膀支点的位置。这个偏移量位于目标模型空间。 Vertical Arm Length 手相对于肩膀的垂直偏移量。当相机垂直旋转时，arm长度会影响跟踪目标在屏幕空间的偏移。 Camera Side 明确哪个位置是相机的肩膀（0-1，代表left，in-between，right三种状态） Camera Distance 相机的手部位置会被放置多远距离 Camera Collision Fiter 相机碰撞过滤器，相机会自动避免阻碍这些层。有以下成员：Nothing/Everything/default/TransparentFX/Ignore Raycast/Water/UI Ignore Tag 检测忽略的Tag Camera Radius 虚拟相机会尽量与遮挡物保持不低于这个距离。如果你看到由于较大的FOV导致相机穿透了遮挡物内部，可以适当增加这个值。 Framing Transposer​ 此虚拟相机本身算法将相机以固定的屏幕空间关系移动到跟随目标。您还可以指定偏移、阻尼和合成规则。Framing Transposer只改变相机在空间中的位置。它不会重新定向或以其他方式瞄准相机。 ​ Framing Transposer专为 2D 和正交相机而设计。但它也适用于透视相机和 3D 环境。 ​ 此算法首先沿相机 Z 轴移动相机，直到跟随目标与相机的 XY 平面处于所需距离。然后在其 XY 平面中移动相机，直到跟随目标位于相机屏幕上的所需点。 注意：Framing Transposer忽略 LookAt 目标 - 仅使用 Follow 目标。 如果Follow目标是Target Group，则可以使用其他属性来构建整个组。 面版 变量 含义 Tracked Object Offse 对跟随目标对象的偏移量（在目标-局部坐标中）。相机将尝试框定目标位置加上此偏移量的点。当目标原点不是目标点时，使用它来校正相机 Lookahead Time 根据目标的运动，调整虚拟相机与“跟随”目标的偏移量。Cinemachine预测目标在未来数秒之内到达的位置并提前设置Unity相机的位置。这个功能对微动的动画敏感，并且会放大噪点，导致非预期的相机抖动。如果不能接受目标运动时的相机抖动，减小这个属性可能会使相机动画更流畅。 Lookahead Smoothing 预测算法的平滑度。较大的值可以消除抖动但会使预测滞后。 Lookahead Ignore Y 如果选中，则忽略沿 Y 轴的移动以进行预测计算。 X ，Y，Z Damping 相机尝试保持 x ，y，z轴偏移的响应程度。小数字使相机更灵敏。数字越大，相机响应越慢。每个轴使用不同的设置可以产生广泛的相机行为。 Target Movement Only 如果启用此选项，则阻尼仅适用于目标的运动。相机旋转更改将绕过阻尼。 Screen X，Y 目标的水平，垂直屏幕位置。相机移动的结果是使目标处于此位置。 Camera Distance 沿摄像机Z轴与跟随目标保持的距离。 Dead Zone Width 当目标在此位置范围内时，不会水平移动相机 Dead Zone Height 当目标在此位置范围内时，不会垂直移动相机。 Dead Zone Depth 当跟随目标距离相机在此范围内时，不会沿其z轴移动相机。 Unlimited Soft Zone 如果选中，Soft Zone没有边界 Soft Zone Width 当目标处于此范围内时，会水平移动相机，将目标移回到Dead Zone中。Damping属性会影响摄像机的运动速度。 Soft Zone Height 当目标处于此范围内时，会垂直移动相机，将目标移回到Dead Zone中。Damping属性会影响摄像机的运动速度。 Bias X，Y Soft Zone的中心与目标位置的水平，垂直偏移。 Center On Active 选中时，虚拟相机激活时会将镜头中心对准物体。不选中时，虚拟相机会将目标物体放置在最近的dead zone边缘。 非常详细不用介绍了 Hard Lock To Target该算法实现虚拟相机和跟随目标使用相同位置。可以用作第一人称 Orbital Transposer这个算法支持相机和目标之间的可变相对位置关系。可以接受玩家的输入，动态的控制相机的位置。 Orbital Transposer引入了一个新的概念叫heading，代表了目标移动的方向或面朝的方向。Orbital Transposer会尝试移动相机，让镜头朝向heading的方向。默认情况下，相机的位置会在target的正后面。也可以通过Heading Bias属性设置。如果给Orbital Transposer添加了输入控制器，玩家就可以控制相机围绕目标旋转。可以设置为Input Manager中的轴，也可以直接用脚本控制。 当Recenter To Target Heading属性选中时，在没有输入时Orbital Transposer可以自动重新居中相机。 变量 含义 Binding Mode 解释虚拟摄像机与跟随目标的偏移时要使用的坐标空间。 Follow Offset 跟随目标时的位置偏移 X Damping 相机在X轴上移动的阻力系数。较小的值会使相机反应更快。较大的值会使相机的反应速度变慢。每个轴使用不同的设置可以制造出各种类型相机的行为。 绑定模式为Simple Follow With World Up时不可用。 Y Damping 相机尝试保持 y 轴偏移的响应速度。小数字使相机更灵敏。数字越大，相机响应越慢。 Z Damping 相机尝试保持 z 轴偏移的响应程度。小数字使相机更灵敏。数字越大，相机响应越慢。 Yaw Damping 相机在y轴旋转的阻力系数。较小的数字会使相机反应更快。较大的数字会使相机的反应速度变慢。每个轴使用不同的设置可以制造出各种类型相机的行为。Binding Mode为Lock to Target With World Up、Lock to Target No Roll、Lock to Target时可用。 Pitch Damping 相机在x轴旋转的阻力系数。较小的数字会使相机反应更快。较大的数字会使相机的反应速度变慢。 Binding Mode为Lock to Target No Roll、Lock to Target时可用。 Roll Damping 相机在z轴旋转的阻力系数。较小的数字会使相机反应更快。较大的数字会使相机的反应速度变慢。 Binding Mode为Lock to Target时可用。 Heading 指定如何计算跟随目标的航向。 Recenter To Target Heading Orbital Transposer __可选地自动将相机重新居中。选中__Recenter To Target Heading 后，Orbital Transposer 会自动将相机移回目标航向。您可以指定在检测到没有用户输入后要等待的时间长度以及重新定位的速度。 X Axis 航向控制。此处的设置控制相机响应玩家输入的行为。 Binding Mode Lock To Target On Assign：本地空间，相机被激活或target赋值时的相对位置。 Lock To Target With World Up：本地空间，保持相机y轴朝上，yaw和roll为0。 Lock To Target No Roll：本地空间，锁定到目标物体，roll为0。 Lock To Target：本地空间，锁定到目标物体 。 World Space：世界空间 。 Simple Follow With World Up：相对于目标的位置，使用相机的本地坐标系，保持相机y轴朝上。 Heading Definition：计算Follow朝向的方法 Position Delta 以根据上次更新和当前帧的目标位置差异来计算航向。 Velocity 以使用目标刚体的速度。 如果目标没有刚体组件，则恢复到位置增量。 Target Forward 以使用目标的本地 Forward 轴作为航向。 World Forward 以使用恒定的世界空间 Forward 作为航向。 Velocity Filter Strength：在定义中使用 Position Delta 或 Velocity 时控制速度的平滑。 Bias：相对于航向放置相机的轨道中的角度偏移。 以度为单位。 轴值为 0 会将相机放在此处。 Recenter To Target Heading Wait Time：如果在轴上没有检测到用户输入，相机会在重新定位之前等待这么长时间（以秒为单位）。 Recentering Time：重新自动定位居中的过程花费的时间. X Axis Value：当前值 Value Range ：值范围 Wrap：如果选中，则轴在 Min 和 Max 值之间形成一个循环。 Speed ：最大速度（Max Speed）或者最大增加速度（Input Value Gain） Accel Time ：加速到最高速度所需要的时间 Input Axis Name：在 Unity 输入管理器中指定的此轴的名称。 设置为空字符串以禁用此轴的自动更新。 Input Axis Value：玩家输入轴的值。值0表示没有输入。可以通过编写脚本控制 Invert：是否反转输入的值（取相反数） Tracked Dolly这个算法可以让相机沿预定路径移动（轨道相机）。使用Path Position属性来指定将虚拟相机放置在路径上的位置。需Follow目标移动。 使用Auto-Dolly模式将虚拟相机移动到路径上最接近Follow目标的位置。启用后，Auto-Dolly会自动将虚拟相机的位置移动到最接近目标的路径上的位置。 提示：使用Auto-Dolly模式时，一定要谨慎选择路径形状。在围绕某个点形成弧形的路径上可能会有问题。举一个极端的例子，考虑一条以Follow目标为中心的完美圆形路径。路径上最接近目标的点变得不稳定，因为圆形路径上的所有点都同样接近目标。在这种情况下，将Follow目标移动很小的距离会导致相机在轨道上移动很大的距离。 注意此算法一定要有Path 变量 含义 Path 相机移动的路径。此属性必须引用CinemachinePath或Cinemachine Smooth Path对象。 Path Position 沿路径放置相机的位置。直接给这个属性作动画或启用Auto-Dolly。这个值以Position Units指定的单位为单位。 Position Units 路径位置的度量单位。 Path Offset 相机相对于路径的位置。X 垂直于路径，Y 向上，Z 平行于路径。使用此属性可使相机偏离路径本身 X ，Y，Z Damping 相机尝试保持 x ，y，z轴偏移的响应程度。小数字使相机更灵敏。数字越大，相机响应越慢。每个轴使用不同的设置可以产生广泛的相机行为。 Camera Up 如何为虚拟摄像机设置向上矢量。这会影响屏幕构图，因为相机 Aim 算法尝试尊重向上方向。 Auto Dolly 控制自动轨道位置选择方式。要使用此功能，必须设置Follow目标。 Path Cinemachine中有两种Dolly Path组件： CinemachinePath组件：每个路径点都可以设置位置、切线和翻转角度，可以最大程度控制路径。但是如果切线设置的不合理，相机在路径上运动时可能会有不稳定的现象。 CinemachineSmoothPath组件：每个路径点都可以设置位置和翻转角度。组件中会使用Bezier算法来推算路径点之间的位置。虽然SmoothPath不能完全控制路径，但是整个路径会更平滑和连续。推荐优先使用。可以避免出现，尽管路径位置始终是平滑连续的，但沿路径设置动画时仍然可能会产生不稳定的现象。 额外扩展：什么是Bezier算法和Bezier曲线 Bezier曲线 怎么理解贝塞尔曲线? - 知乎 Bezier算法 详细的算法推导可以在上述链接中观看如何逐阶层运算各个阶的Bezier曲线。 Unity本身自带的CinemachineSmoothPath脚本源码，他们是定义一个世界空间路径，由一组路点组成，每个路点都有位置和滚动设置。Bezier 插值在航点之间执行，以获得平滑和连续的路径。 计算距离缓存时，对点之间的路径进行多次采样。路径将通过所有航路点，并且（与 CinemachinePath 不同）保证一阶和二阶连续性。 源码都是运算过程，大家可以自行观看。 如何创建Dolly Path 方法一：如果是在相机上制作路径动画，可以直接创建Dolly Camera。菜单栏Cinemachine &gt; Create Dolly Camera with Track。点击后会创建一个虚拟相机和dolly path。这个Path默认是SmoothPath。虚拟相机会自动设置好Body属性为Dolly Track并且Path属性赋值为创建出来的Dolly path。 方法二：如果是给GameObject制作路径动画，可以直接创建Dolly Cart。菜单栏Cinemachine &gt; Create Dolly Track With Cart。点击后会创建一个虚拟相机和DollyCart。这个Path默认是SmoothPath。只需要把做路径动画的物体作为Cart的子物体即可。 方法三：直接创建Dolly Path。创建一个空物体，给空物体添加CinemachinePath或CinemachineSmoothPath组件。 SmoothPath参数详解 Resolution： 每个路径点之间采样的次数。Cinemachine在计算路径距离时使用此值来限制粒度。场景视图中路径Gizmo上的交叉线反映了该值。 Appearance ：路径在场景中显示的外观。只在编辑器中生效。 Path Color ：选中路径时的颜色。 Inactive Path Color ：未选中路径的颜色。 Width ：路径轨道的宽度。 Looped ：选中后，路径会首尾相连。 Path Length ：整个路径长度，这个数据是只读的，根据所有路径点计算出来的。 Waypoints ：定义路径点的列表。 Position ：位置，在路径局部空间中的位置（即相对于路径GameObject本身的变换） Roll* ：翻转角度。朝向的其他轴方向是从切线和世界的向上向量推断出来的。 Dolly Cart参数 （只有Create Dolly Track With Cart才有）详解： 这是限制在 CinemachinePath的移动镜头。 它可用于为路径上的任何对象设置动画，或作为 Cinemachine 虚拟摄像机的跟随目标。这个组件就是把当前所附着的GameObject沿着path移动。 Speed ：移动物体的速度。基于Position Unit设置的单位。如果速度不为0，则小车会根据速度自动移动。 Position :当前物体所处的位置。基于Position Unit设置的单位 Position Units Path Units ：使用路径点的序号。比如0代表第一个路径点，1代表第二个路径点。 Distance ：使用路径的总长度。 Normalized： 归一化。0代表路径最开始的位置，1代表路径结束的位置。 Camera Up Default：不修改虚拟相机up方向，使用Cinemachine Brain的Override的World Up Path：使用路径当前的向上向量 Path No Roll：使用路径节点当前的向上向量，Roll*为0 Follow Target：使用跟随目标的向上向量 Follow Target No Roll：使用跟随目标的向上向量，Roll*为0 不要修改虚拟摄像机的向上方向。 相反，使用 Cinemachine Brain 中的 World Up Override 属性 Auto Dolly Enabled：选中使用自动dolly，注意：这对性能可能会有一些影响，却决于Search Resolution Position Offset：从路径最近点到跟随目标的偏移量 Search Radius：对当前路径点的n个单位点进行搜索，如果为0则为整条路径所有点 Search Resolution：Cinemachine 通过将片段分成许多直线来搜索片段。 数字越大，结果越准确。 但是，对于更高的数字，性能会成比例地变慢。 Transposer这个算法将虚拟相机的坐标与跟随目标的坐标有固定的偏移量来进行跟随，也可以使用Damping属性 简单来说就是虚拟相机跟目标会有固定的位置差偏移 根据BindingMode的不同选择会有不同参数的Damping可以调整 Binding Mode 各种模式可以参考上面Orbital Transposer 的详细介绍","link":"/Blog/2022/08/04/Cinemachine%20Camera%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"title":"unity平台跳跃控制器(持续更新)","text":"unity平台跳跃控制器(持续更新)教程来自b站阿严:https://www.bilibili.com/video/BV1rL4y1W7KH 一 项目的创建和管理插件 删除不需要的插件，安装需要的插件，删除后插件内容： 1.1 安装： Cinemachine，虚拟相机插件。 Post Processing，后处理插件。 Input System，新的输入系统插件。 1.2 安装完成后图: 1.3 导入资源包这里我使用的是自己在unity商店买的资源包，替换了unity酱，想要做点不一样的。 二 状态机系统创建接口文件和状态机类 2.1 Istate接口123456789101112131415using System.Collections;using System.Collections.Generic;using UnityEngine;public interface IState{ void Enter();//状态进入 void Exit();//状态退出 void LogicUpdate();//状态逻辑更新 void PhysicUpdate();//状态物理更新} 2.2 StateMachine类作用: 持有所有状态,并且进行管理和切换; 负责当前状态的更新. 1234567891011121314151617181920212223242526272829303132using System.Collections;using System.Collections.Generic;using UnityEngine;public class StateMachine : MonoBehaviour{ //1、持有所有状态,并且进行管理和切换;2、负责当前状态的更新 IState currentState; void Update() { //更新状态逻辑 currentState.LogicUpdate(); } void FixedUpdate() { //更新物理 currentState.PhysicUpdate(); } protected void SwitchOn(IState newState) {//状态开启 //新状态赋值给当前状态,然后启动 currentState = newState; currentState.Enter(); } public void SwitchState(IState newState) {//切换状态 //先关闭状态,然后新状态赋值给当前状态,启动 currentState.Exit(); SwitchOn(newState); }} 三 扩展状态机系统创建PlayerStates(玩家状态)并初始化 123456789101112131415161718192021222324252627282930313233343536using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerState : ScriptableObject, IState{//玩家状态类 Animator animator;//动画器 PlayerStateMachine stateMachine;//玩家状态机类 public void Initialize(Animator animator, PlayerStateMachine stateMachine) { this.animator = animator; this.stateMachine = stateMachine; } public virtual void Enter() { } public virtual void Exit() { } public virtual void LogicUpdate() { } public virtual void PhysicUpdate() { }} PlayerStatesMachine(玩家状态机) 1234567891011121314using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerStateMachine : StateMachine{//玩家状态机 Animator animator; private void Awake() { animator = GetComponentInChildren&lt;Animator&gt;(); //可以在此初始化 玩家状态 }} 3.1 状态机系统继承关系图 3.2 使用两种方法实现角色动画3.2.1、常规方法(不使用状态机)构建基础状态机系统,创建动画控制器 拖到玩家对象 将动画拖入控制器 更改默认状态 然后在player对象添加玩家控制器脚本 需求分析: 按下A/D键时播放跑步动画 松开按键回到空闲动画 实现方式： 获取键盘的输入信号(Input System) 播放特定动画(Animator) PlayerController代码如下： 1234567891011121314151617181920212223242526using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.InputSystem;public class PlayerController : MonoBehaviour{ Animator animator; private void Awake() { animator = GetComponentInChildren&lt;Animator&gt;();//获取动画控制组件 } void Update() { //按住当前键盘的a或者d键 //if(Input.GetKey(KeyCode.A)|| Input.GetKey(KeyCode.D)) if (Keyboard.current.aKey.isPressed || Keyboard.current.dKey.isPressed) { animator.Play(&quot;Run&quot;);//播放动画器中特定动画 } else//松开按键时 { animator.Play(&quot;Idle&quot;); } }} 并且同时更改动画器中动画的名字，以匹配代码中的命名 全部改完效果如图： 3.2.2、通过状态机实现动画状态切换首先将状态机脚本添加到玩家上 其次在Player State文件夹中创建idle和run状态脚本 皆继承于PlayerState [CreateAssetMenu(menuName = &quot;Data/StateMachine/PlayerState/Idle&quot;, fileName = &quot;PlayerState_Idle&quot;)] 这条代码将代码暴露在编辑器中，可在文件夹中创建可程序化对象文件 举例PlayerState_Idle代码如下: 重写状态函数,更新状态 1234567891011121314151617181920using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.InputSystem;[CreateAssetMenu(menuName = &quot;Data/StateMachine/PlayerState/Idle&quot;, fileName = &quot;PlayerState_Idle&quot;)]public class PlayerState_Idle : PlayerState{ public override void Enter() { animator.Play(&quot;Idle&quot;); } public override void LogicUpdate() { if (Keyboard.current.aKey.isPressed || Keyboard.current.dKey.isPressed) { stateMachine.SwitchState(stateMachine.runState); } }} PlayerState_Idle脚本代码同理。 状态机模式将不同状态分开来处理,这个模式中只需要思考,当前状态如何切换到下一状态,而不再需要同时考虑另一个状态的逻辑问题。 (例如需要落地后才可起跳，常规方法需要使用很多Boolean值来判断状态，而状态机模式只需要在各自状态中实现切换即可) 3.3 状态机模式优缺点优点 逻辑分开到各个状态中处理，不需要考虑状态之间的约束，让思路更清楚。 代码性能提升 缺点 文件数量增加 代码重复 3.4 继续完善状态机功能打开玩家状态机脚本PlayerStateMachine 目前所有新状态都需要新建初始化,是否可以声明一个鸡和然后将所有状态都扔进去呢?当然可以。 首先修改玩家状态机类的代码，(注释中是原代码) 我们新建一个states数组，通过遍历获取玩家具体状态。 1234567891011121314151617181920212223242526272829using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerStateMachine : StateMachine{//玩家状态机 Animator animator; //public PlayerState_Idle idleState; //public PlayerState_Run runState; [SerializeField] PlayerState[] states;//持有所有状态 private void Awake() { animator = GetComponentInChildren&lt;Animator&gt;(); //可以在此初始化 玩家状态 //idleState.Initialize(animator, this); //runState.Initialize(animator, this); foreach (PlayerState state in states) { state.Initialize(animator, this); } } private void Start() { SwitchOn(【idleState】);//默认idle，【idleState】报错，需要通过字典 }} 这么做idleState会出现报错， 这时需要在父类创建字典，声明一个键为System.Type值为IState类型的字典 然后在玩家状态机类PlayerStateMachine中的状态遍历循环中，给它赋值。 最后就可以通过键来获取状态。以下是父类，也就是状态+6机类StateMachine中代码： 1234567891011121314151617181920212223242526272829303132333435using System.Collections;using System.Collections.Generic;using UnityEngine;public class StateMachine : MonoBehaviour{ //1、持有所有状态,并且进行管理和切换;2、负责当前状态的更新 IState currentState; //新建一个 键为System.Type 值为IState类型的字典 protected Dictionary&lt;System.Type, IState&gt; stateTbale; void Update() { //更新状态逻辑 currentState.LogicUpdate(); } void FixedUpdate() { //更新物理 currentState.PhysicUpdate(); } protected void SwitchOn(IState newState) {//状态开启 //新状态赋值给当前状态,然后启动 currentState = newState; currentState.Enter(); } public void SwitchState(IState newState) {//切换状态 //先关闭状态,然后新状态赋值给当前状态,启动 currentState.Exit(); SwitchOn(newState); }} 接着在玩家状态机类awake()中初始化，更改后的玩家状态机类代码如下： 12345678910111213141516171819202122232425262728293031323334using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerStateMachine : StateMachine{//玩家状态机 Animator animator; //public PlayerState_Idle idleState; //public PlayerState_Run runState; [SerializeField] PlayerState[] states;//持有所有状态 private void Awake() { //获取动画 animator = GetComponentInChildren&lt;Animator&gt;(); //字典长度为状态数组长度 stateTbale = new Dictionary&lt;System.Type, IState&gt;(states.Length); //可以在此初始化 玩家状态 //idleState.Initialize(animator, this); //runState.Initialize(animator, this); foreach (PlayerState state in states) { state.Initialize(animator, this); stateTbale.Add(state.GetType(), state);//朝字典添加数据 } } private void Start() { Debug.Log(typeof(PlayerState_Idle)); //在字典中传入PlayerState_Idle的类型 //默认idle SwitchOn(stateTbale[typeof(PlayerState_Idle)]); }} 接着会遇到两个报错：PlayerState_Run和PlayerState_Idle类中的状态切换里的变量不存在了。 我们需要回到状态机主类StateMachine，重载状态切换函数SwitchState。将变量类型改为字典需要的键(System.Type类)对比如下: 1234567891011public void SwitchState(IState newState) {//切换状态 //先关闭状态,然后新状态赋值给当前状态,启动 currentState.Exit(); SwitchOn(newState); } public void SwitchState(System.Type newStateType) {//切换状态 //通过字典获取状态，再调用上面那个SwitchState()； SwitchState(stateTbale[newStateType]); } 这样在报错的PlayerState_Run和PlayerState_Idle中修改相应的变量即可： stateMachine.SwitchState(runState); 改成了 stateMachine.SwitchState(typeof(PlayerState_Run)); 123456789101112131415161718192021using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.InputSystem;[CreateAssetMenu(menuName = &quot;Data/StateMachine/PlayerState/Idle&quot;, fileName = &quot;PlayerState_Idle&quot;)]public class PlayerState_Idle : PlayerState{ public override void Enter() { animator.Play(&quot;Idle&quot;); } public override void LogicUpdate() { if (Keyboard.current.aKey.isPressed || Keyboard.current.dKey.isPressed) { stateMachine.SwitchState(typeof(PlayerState_Run)); } }} 四 Input System输入系统 如果需要某个功能对应不同按键都可触发,使用InputSystem会更加方便。不使用输入系统的话需要多个判断语句实现。 4.1 新建Input Actions命名为PlayerInputActions,玩家输入动作 4.1.1、创建移动动作新建GamePlay动作表,重命名动作名为Axes 轴。右边动作类型选value，值类型选二维向量 删除默认的按键，添加预设的上下左右 通过listen绑定按键 手柄和键盘的模式都改成digital，这样手柄将和键盘一样xy取值只有0,-1,1 4.1.2、创建跳跃动作 记得保存资产 4.1.3、生成c#文件更改文件位置 4.2 初始化玩家输入4.2.1、新建脚本PlayerInput 玩家输入类，并且添加到player对象中。1234567891011121314151617181920212223242526272829using UnityEngine;public class PlayerInput : MonoBehaviour{//玩家输入类 PlayerInputActions playerInputAction;//inputsystem生成的c#文件 public bool PlayerMove =&gt; AxisX != 0f;//通过判断x轴是否为0,判断是否移动 //获取轴的值 x,y Vector2 axes =&gt; playerInputAction.GamePlay.Axes.ReadValue&lt;Vector2&gt;(); public float AxisX =&gt; axes.x; //WasPressedThisFrame()是否按下 public bool playerjump =&gt; playerInputAction.GamePlay.Jump.WasPressedThisFrame(); //WasReleasedThisFrame()是否松开按键 public bool playerstopJump =&gt; playerInputAction.GamePlay.Jump.WasReleasedThisFrame(); private void Awake() { playerInputAction = new PlayerInputActions();//初始化 } public void EnableGameplayInputs() { //启用gameplay动作表（inputsystem中自带的方法，通过.GamePlay.Enable()启动） playerInputAction.GamePlay.Enable(); Cursor.lockState = CursorLockMode.Locked;//鼠标设置为锁定模式 }} 4.2.2、更改PlayerState 玩家状态脚本，加入玩家输入 初始化12345678910111213141516171819202122232425262728using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerState : ScriptableObject, IState{//玩家状态类 protected Animator animator;//动画器 protected PlayerInput input;//玩家输入类 protected PlayerStateMachine stateMachine;//玩家状态机类 public void Initialize(Animator animator, PlayerInput input, PlayerStateMachine stateMachine) { //初始化状态动画,玩家输入类，玩家状态机 this.animator = animator; this.input = input; this.stateMachine = stateMachine; } public virtual void Enter() { } public virtual void Exit() { } public virtual void LogicUpdate() { } public virtual void PhysicUpdate() { }} 4.2.3、修改PlayerState_Idle和PlayerState_Run脚本因为在PlayerInput中,新建了一个变量表示玩家是否移动。原来判断玩家是否在移动的语句优化如下： 旧版通过检测按键a或者d判断: if (Keyboard.current.aKey.isPressed || Keyboard.current.dKey.isPressed) 新版判断输入事件x轴是否为0，得出玩家是否正移动: if (input.PlayerMove) 4.2.4、在PlayerStateMachine 玩家状态机类中初始化玩家输入部分代码如下： 12345678910111213141516171819PlayerInput input;//玩家输入 private void Awake() { //获取动画 animator = GetComponentInChildren&lt;Animator&gt;(); //获取玩家输入 input = GetComponent&lt;PlayerInput&gt;(); //字典长度为状态数组长度 stateTbale = new Dictionary&lt;System.Type, IState&gt;(states.Length); //可以在此初始化 玩家状态 //idleState.Initialize(animator, this); //runState.Initialize(animator, this); foreach (PlayerState state in states) { state.Initialize(animator, input, this); stateTbale.Add(state.GetType(), state);//朝字典添加数据 } } 4.2.5、在PlayerController 玩家控制器类中添加玩家输入，并且启用动作表1234567891011121314public class PlayerController : MonoBehaviour{ //玩家控制器 PlayerInput input;//玩家输入类 private void Awake() { input = GetComponent&lt;PlayerInput&gt;();//获取对象 } private void Start() { input.EnableGameplayInputs();//启用动作表 }#region 常规方法(不使用状态机)...} 五 玩家移动、转向5.1 玩家移动功能实现分析:通过刚体模拟物体运动，需要获取player身上的刚体组件。 将玩家移动功能写在PlayerController玩家控制器脚本中。 新建刚体变量，获取实例，创建了三个改变刚体速度的函数 123456789101112131415161718192021222324252627282930313233343536using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.InputSystem;public class PlayerController : MonoBehaviour{//玩家控制器 PlayerInput input;//玩家输入类 Rigidbody rigidBody;//刚体类引用变量 private void Awake() { input = GetComponent&lt;PlayerInput&gt;();//获取对象实例 rigidBody = GetComponent&lt;Rigidbody&gt;();//获取刚体组件实例 } private void Start() { input.EnableGameplayInputs();//启用动作表 } public void SetVelocity(Vector3 velocity) { //直接修改刚体速度 rigidBody.velocity = velocity; } public void SetVelocityX(float velocityX) { //将刚体x轴的速度设置为参数的值,y不变。左右移动 rigidBody.velocity = new Vector3(velocityX, rigidBody.velocity.y); } public void SetVelocityY(float velocityY) { //将刚体y轴的速度设置为参数的值,x不变。跳跃或者下落 rigidBody.velocity = new Vector3(rigidBody.velocity.x, velocityY); } #region 常规方法(不使用状态机)...} PlayerState 玩家状态类中添加玩家控制器类，并初始化(部分代码) 12345678910protected PlayerController player;//玩家控制器public void Initialize(PlayerController player, Animator animator, PlayerInput input, PlayerStateMachine stateMachine) { //初始化玩家控制器，状态动画,玩家输入类，玩家状态机 this.player = player; this.animator = animator; this.input = input; this.stateMachine = stateMachine; } PlayerStateMachine 玩家状态机类一起更新 123456789101112131415161718192021222324252627282930313233343536373839404142using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerStateMachine : StateMachine{//玩家状态机 Animator animator;//动画 PlayerInput input;//玩家输入 PlayerController playerController;//玩家状态机 [SerializeField] PlayerState[] states;//持有所有状态 private void Awake() { //获取动画 animator = GetComponentInChildren&lt;Animator&gt;(); //获取玩家输入 input = GetComponent&lt;PlayerInput&gt;(); //获取玩家控制器 playerController = GetComponent&lt;PlayerController&gt;(); //字典长度为状态数组长度 stateTbale = new Dictionary&lt;System.Type, IState&gt;(states.Length); //可以在此初始化 玩家状态 //idleState.Initialize(animator, this); //runState.Initialize(animator, this); foreach (PlayerState state in states) { state.Initialize(playerController, animator, input, this); stateTbale.Add(state.GetType(), state);//朝字典添加数据 } } private void Start() { //Debug.Log(typeof(PlayerState_Idle)); //在字典中传入PlayerState_Idle的类型 //默认idle SwitchOn(stateTbale[typeof(PlayerState_Idle)]); }} 在PlayerState_Run 跑步状态脚本中**重写PhysicUpdate()**方法实现玩家移动 123456789101112131415161718192021222324using System.Collections;using System.Collections.Generic;using UnityEngine;[CreateAssetMenu(menuName = &quot;Data/StateMachine/PlayerState/Run&quot;, fileName = &quot;PlayerState_Run&quot;)]public class PlayerState_Run : PlayerState{ [SerializeField] float runSpeed = 5f;//跑步速度 public override void Enter() { animator.Play(&quot;Run&quot;); } public override void LogicUpdate() { if (!input.PlayerMove) {//if玩家没移动输入 则切换状态为idle stateMachine.SwitchState(typeof(PlayerState_Idle)); } } public override void PhysicUpdate() { player.SetVelocityX(runSpeed); }} 新建变量runSpeed 跑步速度 将它序列化，已暴露在编辑器中，至此移动功能实现。 5.2 玩家转向5.2.1、通过镜像翻转改变玩家朝向首先在PlayerController 玩家控制器中增加Move(), 通过更改Player的localScale的属性x轴正负(对应axisX轴)值,同步修改角色朝向。 左右移动功能使用速度x方向 然后修改PlayerState_Run中**PhysicUpdate()**函数 player.SetVelocityX(runSpeed);改为player.Move(runSpeed); 新的比旧的多了转向功能。 5.5.2、停止移动**PlayerState_Idle类Enter()**中新加一条代码player.SetVelocityX(0f);x轴速度归零 5.3 玩家加速和减速5.3.1、实现玩家加速在玩家控制器中添加一个方法,获取玩家移速。 打开玩家状态类声明浮点型变量currentSpeed，当前速度 修改PlayerState_Run脚本,新增变量acceration加速度，Enter()中获取当前速度，LogicUpdate()中新增缓慢加速的算法。 12345678910111213141516171819202122232425262728using System.Collections;using System.Collections.Generic;using UnityEngine;[CreateAssetMenu(menuName = &quot;Data/StateMachine/PlayerState/Run&quot;, fileName = &quot;PlayerState_Run&quot;)]public class PlayerState_Run : PlayerState{ [SerializeField] float runSpeed = 5f;//跑步速度 [SerializeField] float acceration = 10f;//加速度 public override void Enter() { animator.Play(&quot;Run&quot;); currentSpeed = player.MoveSpeed;//获取当前速度 } public override void LogicUpdate() { if (!input.PlayerMove) {//if玩家没移动输入 则切换状态为idle stateMachine.SwitchState(typeof(PlayerState_Idle)); } //从当前速度到指定速度之间随着acceration加速度增加。 currentSpeed = Mathf.MoveTowards(currentSpeed, runSpeed, acceration * Time.deltaTime); } public override void PhysicUpdate() { //player.Move(runSpeed); player.Move(currentSpeed); }} 5.3.2、实现玩家减速修改PlayerState_Idle脚本，新增变量deceleration表示减速加速度，Enter()中记录当前速度，LogicUpdate()中新增缓慢减速算法。重写PhysicUpdate()方法设置减速。 1234567891011121314151617181920212223242526272829using System.Collections;using System.Collections.Generic;using UnityEngine;[CreateAssetMenu(menuName = &quot;Data/StateMachine/PlayerState/Idle&quot;, fileName = &quot;PlayerState_Idle&quot;)]public class PlayerState_Idle : PlayerState{ [SerializeField] float deceleration = 5f; public override void Enter() { animator.Play(&quot;Idle&quot;);//播放动画器里的idle动画 //player.SetVelocityX(0f);//x轴速度归零 currentSpeed = player.MoveSpeed;//记录当前速度 } public override void LogicUpdate() { if (input.PlayerMove) {//判断是否移动 stateMachine.SwitchState(typeof(PlayerState_Run)); } //减速 currentSpeed = Mathf.MoveTowards(currentSpeed, 0, deceleration * Time.deltaTime); } public override void PhysicUpdate() { //因为已停止移动 所以不能用Move()，并且需要获取玩家朝向layer.transform.localScale.x player.SetVelocityX(currentSpeed * player.transform.localScale.x); }} 5.4 相机跟随玩家使用Cinemachine虚拟相机插件实现。 新建虚拟相机命名为Virtual Camera Player Follow， 拖到Cameras下。 提前重置两个相机位置，然后将player拖到follow槽中 取消勾选Aim选项，这个是用作瞄准用的。 将body机身改成Framing Transposer取景器 调试参数，选中这个，在试玩时做的操作也会保存 六 优化改进动画播放PlayerState玩家状态脚本中新增三条属性 分别用来获取状态动画名称、动画切换时间、声明int类型哈希值。 onenable()中，将获取的字符串转哈希值（哈希值占用资源少）。 Enter()中，使用animator.crossFade()过渡动画，淡入淡出效果。 参数1：字符串或者哈希值，参数2：持续时间。 玩家状态PlayerState_Idle和PlayerState_Run中的animator.Play()改为base.Enter();继承父类 回到编辑器中只需要在可视化脚本中输入动画名即可. 七 玩家跳跃功能7.1 地面检测要实现跳跃功能，首先要检测地面。 在Player对象下的Ground Detector空对象中添加新的脚本：PlayerGroundDetector 玩家地面检测器 代码如下: 123456789101112131415161718192021using System.Diagnostics;using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerGroundDetector : MonoBehaviour{ [SerializeField] float detectionRadius = 0.1f;//检测半径 [SerializeField] LayerMask groundLayer;//层级 Collider[] colliders = new Collider[1];//碰撞数组 //Physics.OverlapSphereNonAlloc 检测碰撞个数,不触发回收机制 判断如不为0则返回true //IsGrounded:可以判断玩家是否在地面 public bool IsGrounded =&gt; Physics.OverlapSphereNonAlloc(transform.position, detectionRadius, colliders,groundLayer) != 0; //OnDrawGizmosSelected():系统提供的方法,不是自己建的。 void OnDrawGizmosSelected() {//在编辑器中展示 方便调试 Gizmos.color = Color.green; Gizmos.DrawWireSphere(transform.position, detectionRadius); }} 在PlayerController 玩家控制器脚本中新增代码,以使用玩家地面检测器的参数. 新增内容: 1234567PlayerGroundDetector groundDetector;//玩家地面检测//获取地面检测结果public bool IsGrounded =&gt; groundDetector.IsGrounded;//true 为已接触//判断玩家是否为正在下落,下落时刚体的y速度为负数,并且需要未落地.public bool IsFalling =&gt; rigidBody.velocity.y &lt; 0f &amp;&amp; !IsGrounded; 7.2 检测当前播放动画是否完成需要获取:1.动画播放开启的时间;2.当前状态持续时长;3.动画自身播放时长 打开玩家状态脚本 PlayerState,新增代码. 1234567float stateStartTime;//状态开始时间 //动画是否播放完毕,通过判断 [当前状态的持续时间]是否大于等于[动画本身长度],若大于则动画结束. protected bool IsAnimationFinished =&gt; StateDuration &gt;= animator.GetCurrentAnimatorStateInfo(0).length; //当前状态的持续时间,当前时间减去状态开始时间. protected float StateDuration =&gt; Time.time - stateStartTime; Enter()中给stateStartTime赋值 12345public virtual void Enter() {//animator.CrossFade()交叉淡化函数,可传入哈希值或者string animator.CrossFade(stateHash, transitionDuration); stateStartTime = Time.time;//记录下状态开始时间 } 7.3 玩家跳跃新建三个状态类PlayerState_Fall,PlayerState_JumpUp,PlayerState_Land。 玩家按下跳跃键,并且玩家在地面上","link":"/Blog/2022/07/08/unity%E5%B9%B3%E5%8F%B0%E8%B7%B3%E8%B7%83%E6%8E%A7%E5%88%B6%E5%99%A8/"},{"title":"平台跳跃控制器之土狼时间","text":"平台跳跃控制器之土狼时间土狼时间人物在地面/平台边缘即将掉落的时候,仍有机会进行跳跃动作; 其原理是:在人物掉落判定时开始计时,在设置的土狼时间内,可以按键跳跃。 新建一个状态脚本PlayerState_CoyoteTime，大部分代码可复制PlayerState_Run。 从RUN状态转向CoyoteTime，首先关闭刚体重力(需要在PlayerController脚本中添加方法获取参数)，使角色在空中保持一段时间。状态结束再开启刚体重力。 其中包含的下落状态处理逻辑，因此可以将PlayerState_Run中浮空切换下落状态改为切换为PlayerState_CoyoteTime PlayerState_CoyoteTime.cs代码 12345678910111213141516171819202122232425262728293031323334353637using System.Collections;using System.Collections.Generic;using UnityEngine;[CreateAssetMenu(menuName = &quot;Data/StateMachine/PlayerState/CoyoteTime&quot;, fileName = &quot;PlayerState_CoyoteTime&quot;)]public class PlayerState_CoyoteTime : PlayerState{ [SerializeField] float runSpeed = 5f;//跑步速度 [SerializeField] float coyoteTime = 0.1f;//土狼时间持续时间 public override void Enter() { base.Enter(); //取消刚体重力 player.SetUseGravity(false); } public override void Exit() { //结束,开启重力 player.SetUseGravity(true); } public override void LogicUpdate() { if (input.playerjump) { //如果玩家按下空格起跳,则切换状态为跳跃 stateMachine.SwitchState(typeof(PlayerState_JumpUp)); } if (StateDuration &gt; coyoteTime || !input.PlayerMove) {//当玩家不进行移动操作,或土狼时间结束时,切换为掉落状态 stateMachine.SwitchState(typeof(PlayerState_Fall)); } } public override void PhysicUpdate() { player.Move(runSpeed); }} PlayerController中新加的函数 12345public void SetUseGravity(bool value) {//控制刚体重力开关 rigidBody.useGravity = value; } PlayerState_Run中修改后的内容 1234if (!player.IsGrounded) {//当玩家不在地面上时,切换为土狼时间状态 stateMachine.SwitchState(typeof(PlayerState_CoyoteTime)); }","link":"/Blog/2022/09/08/%E5%B9%B3%E5%8F%B0%E8%B7%B3%E8%B7%83%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B%E5%9C%9F%E7%8B%BC%E6%97%B6%E9%97%B4/"},{"title":"平台跳跃控制器之二段跳","text":"平台跳跃控制器之二段跳 总章中间漏了点，最近懒得补。干脆做到哪写到哪吧，有时间再整理。 跳跃在空中的状态是：跳起-&gt;下落; 跳起之后松开空格就是下落状态，所以二段跳逻辑我们写在下落状态中； 实现空中多段跳 新建一个空中跳跃状态(PlayerState_AirJump.cs),为他添加资产菜单(CreateAssetMenu); 空中跳跃的逻辑和普通跳跃一样,所以直接复制代码即可。重要的地方在于,我们需要给二段跳进行限制。 在PlayerController.cs中,新建属性CanAirJump,public bool CanAirJump { get; set; } = true;//控制空中跳跃能力的开关 在下落状态脚本PlayerState_Fall.cs中的**LogicUpdate()**函数里实现判断,当玩家可以跳跃时(吃到星星,测试时条件是落地后)切换状态: 1234567891011121314public override void LogicUpdate() { if (player.IsGrounded) {//当玩家接触到地面时,切换到落地状态 stateMachine.SwitchState(typeof(PlayerState_Land)); } if (input.playerjump) { if (player.CanAirJump) {//当玩家可以跳跃时(吃到星星,测试时条件是落地后) stateMachine.SwitchState(typeof(PlayerState_AirJump)); } } } 给跳跃添加粒子特效分别在两个跳跃状态新建[SerializeField] ParticleSystem jumpVFX;//粒子特效 实现吃星星增加跳跃次数首先将玩家控制器脚本PlayerController中,属性 public bool CanAirJump { get; set; }的ture赋值删除,不进行初始化.默认值为false; 其次在PlayerState_Land脚本中删除Enter()里,player.CanAirJump。 打开星星宝石预制体,创建脚本StarGem,内容如下:12345678910111213public class StarGem : MonoBehaviour{ //进入触发器 private void OnTriggerEnter(Collider other) { //检测进入触发器的对象是否是玩家 if (other.TryGetComponent&lt;PlayerController&gt;(out PlayerController player)) {//打开空中跳跃能力 player.CanAirJump = true; //Destroy(gameObject);不可直接摧毁宝石 } }} 碰撞体配置,记得打开触发器 接下来实现星星宝石消失后延时恢复 1234567891011121314151617181920212223242526272829303132333435363738public class StarGem : MonoBehaviour{//进入触发器 [SerializeField] float resetTime = 2; MeshRenderer meshRenderer;//渲染器组件 new Collider collider;//碰撞器组件 WaitForSeconds waitResetTime; private void Awake() { meshRenderer = GetComponentInChildren&lt;MeshRenderer&gt;(); collider = GetComponent&lt;Collider&gt;(); waitResetTime = new WaitForSeconds(resetTime); } private void OnTriggerEnter(Collider other) { //检测进入触发器的对象是否是玩家 if (other.TryGetComponent&lt;PlayerController&gt;(out PlayerController player)) {//打开空中跳跃能力 player.CanAirJump = true; //Destroy(gameObject);不可直接摧毁宝石 meshRenderer.enabled = false;//关闭宝石的渲染器组件 collider.enabled = false;//关闭碰撞器组件 //Invoke(nameof(Reset), resetTime);//延时resetTime秒调用函数 StartCoroutine(ResetCoroutine());//启动延时携程 } } IEnumerator ResetCoroutine() {//延时携程 yield return waitResetTime;//挂起等待resetTime秒 Reset();//实现功能 } void Reset() { meshRenderer.enabled = true;//关闭宝石的渲染器组件 collider.enabled = true;//关闭碰撞器组件 }} 给星星添加音效组件中添加Audio Source,在代码中添加拾取音效.图中已圈出 旋转星星1234567891011using System.Collections;using System.Collections.Generic;using UnityEngine;public class AutoRotate : MonoBehaviour{ [SerializeField] Vector3 rotation; private void Update() {//旋转 transform.Rotate(rotation * Time.deltaTime); }}","link":"/Blog/2022/08/29/%E5%B9%B3%E5%8F%B0%E8%B7%B3%E8%B7%83%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B%E4%BA%8C%E6%AE%B5%E8%B7%B3/"},{"title":"平台跳跃控制器之预输入","text":"平台跳跃控制器之预输入功能实现说明:未落地时按跳跃键,可被记录，并且落地后起跳。 降落状态，并且无法二段跳时，开启缓冲输入。 从降落到落地之间只要一直按着空格，落地后会立马跳起。 中间松开就会关闭缓冲输入。 落地后关闭缓冲输入。 PlayerInput中添加变量public bool HasJumpInputBuffer { get; set; } **onEnable()**函数中添加松开按键判定 12345678private void OnEnable() { //当玩家松开按键跳跃时 playerInputAction.GamePlay.Jump.canceled += delegate { HasJumpInputBuffer = false;//松开按键关闭跳跃输入缓冲 }; } PlayerState_Fall脚本中添加输入缓冲 123456789if (input.playerjump) { if (player.CanAirJump) {//当玩家可以跳跃时(吃到星星,测试时条件是落地后) stateMachine.SwitchState(typeof(PlayerState_AirJump)); return; } input.HasJumpInputBuffer = true;//如果玩家不能二段跳,则开启动作预输入(输入缓冲) } PlayerState_JumpUp脚本,**Enter()**中添加input.HasJumpInputBuffer = false;//关闭动作缓冲 PlayerState_Land,落地状态脚本,判定开启动作缓冲输入时也可跳跃 12345if (input.HasJumpInputBuffer || input.playerjump) {//如果存在跳跃输入缓冲 //或者玩家按下空格起跳,则切换状态为跳跃 stateMachine.SwitchState(typeof(PlayerState_JumpUp)); } 限制缓冲输入时长新建协程JumpInputBufferCoroutine,跳跃输入缓冲携程 1234567IEnumerator JumpInputBufferCoroutine() { //跳跃输入缓冲携程 HasJumpInputBuffer = true; yield return waitJumpInputBufferTime;//延迟0.5s HasJumpInputBuffer = false; } 该协程写进一个方法用以别的类调用 12345public void SetJumpInputBufferTimer() { StopCoroutine(nameof(JumpInputBufferCoroutine)); StartCoroutine(nameof(JumpInputBufferCoroutine)); } 例如PlayerState_Fall状态中,将无限制缓冲输入时长改为长按0.5s失效 123//若如果玩家不能二段跳,则开启动作预输入(输入缓冲) 携程 // input.HasJumpInputBuffer = true; input.SetJumpInputBufferTimer();","link":"/Blog/2022/09/14/%E5%B9%B3%E5%8F%B0%E8%B7%B3%E8%B7%83%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B%E9%A2%84%E8%BE%93%E5%85%A5/"},{"title":"游戏画面中查看debug:OnGUI","text":"游戏画面中查看debug:OnGUI123456789private void OnGUI() { Rect rect = new Rect(200, 200, 200, 200);//显示位置 string msg = &quot;是否有跳跃缓冲:&quot; + HasJumpInputBuffer;//字符串 GUIStyle style = new GUIStyle();//自定义文本样式 style.fontSize = 20; style.fontStyle = FontStyle.Bold;//粗体 GUI.Label(rect, msg, style); }","link":"/Blog/2022/09/14/%E6%B8%B8%E6%88%8F%E7%94%BB%E9%9D%A2%E4%B8%AD%E6%9F%A5%E7%9C%8Bdebug-OnGUI/"},{"title":"平台跳跃控制器之声音","text":"平台跳跃控制器之声音说明:红宝石和蓝宝石是一次性的,所以拾取后要摧毁音效对象，而黄宝石是需要重复利用的，不需要摧毁。 为了整体音效更好管理，新建一个SoundEffectsPlayer类,附加在SFX Player对象上,SFX Player对象上要有AudioSource组件。 123456789public class SoundEffectsPlayer : MonoBehaviour{ public static AudioSource audioSource { get; private set; } private void Awake() { audioSource = GetComponent&lt;AudioSource&gt;(); audioSource.playOnAwake = false; }} StarGem,黄色跳跃星星脚本中,注释掉AudioSource定义代码，播放音效改为调用SoundEffectsPlayer类中的AudioSource:SoundEffectsPlayer.audioSource.PlayOneShot(pickUpSFX);//播放音效 一次性宝石分别在红、蓝宝石组件上新建两个同名脚本:VitoryGem、GateTrigger 统一代码为:拾取时播放音效、特效。 1234567891011public class GateTrigger : MonoBehaviour{ [SerializeField] AudioClip pickUpSound;//音效 [SerializeField] ParticleSystem pickUpVFX;//特效 private void OnTriggerEnter(Collider other) { SoundEffectsPlayer.audioSource.PlayOneShot(pickUpSound); Instantiate(pickUpVFX, transform.position, Quaternion.identity); Destroy(gameObject);//摧毁 }} 红、蓝宝石不需要判断是否和玩家产生碰撞。通过碰撞物理层级来实现，限定两个宝石只和玩家产生碰撞 新建Player和Interactable层级 项目设置中，设置Interactable物理层级只和player碰撞。 玩家音效在PlayerController中添加音源组件 在跳跃、二段跳、落地等状态中添加音效（截图为跳跃状态，其他代码一样） 然后在编辑器中拖入各自的音频文件 添加背景音乐(Loop：循环播放，Play On Awake:开局自动播放) 调整音量在每个有创建AudioSource,的脚本中添加音量调整滑块 SoundEffectsPlayer: PlayerController: 效果：","link":"/Blog/2022/09/15/%E5%B9%B3%E5%8F%B0%E8%B7%B3%E8%B7%83%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B%E5%A3%B0%E9%9F%B3/"},{"title":"平台跳跃控制器之宝石功能实现:delegate","text":"平台跳跃控制器之宝石功能实现-delegate常规方法：通过委托联系宝石与门(观察者模式)流程是: 在宝石脚本中创建委托,并在碰撞函数中调用(Invoke()); 在门脚本中创建函数(Open())摧毁对象,并且订阅宝石中的委托。 当宝石碰撞，调用了委托，订阅委托的两个门就执行相应动作(摧毁)。 这个方法缺点是门与宝石耦合 给宝石添加委托event关键字:其他类不可使用=,只可以+=或-= 碰撞事件函数中调用委托 给门添加Gate脚本写一个函数来销毁门 1234void Open() { Destroy(gameObject); } 获取gateTrigger实例并且 在**Onenable()**中订阅Open函数 引入Scriptable Object实现解耦 新建一个EventChannels文件夹并且创建VoidEventChannel脚本 将它继承于ScriptableObject,实现声明委托、调用、订阅、退订等操作。 1234567891011121314151617using UnityEngine;[CreateAssetMenu(menuName = &quot;Data/EventChannels/VoidEventChannel&quot;, fileName = &quot;VoidEventChannel_&quot;)]public class VoidEventChannel : ScriptableObject{ event System.Action Delegate; public void Broadcast() { Delegate?.Invoke();//调用委托 // 等价于如下代码 // if (Delegate!=null) // { // Delegate.Invoke(); // } } public void AddListener(System.Action action) { Delegate += action; }//订阅 public void RemoveListener(System.Action action) { Delegate -= action; }//退订} 在中Data文件夹中创建EventChannels文件夹，并创建VoidEventChannel_文件 门开关之类的命名为VoidEventChannel_GateTriggered 修改GateTrigger代码序列化获取VoidEventChannel可脚本化对象,注释定义委托代码,在触发器中调用VoidEventChannel中的调用委托函数。 1234567891011121314151617using UnityEngine;public class GateTrigger : MonoBehaviour{ [SerializeField] AudioClip pickUpSound;//音效 [SerializeField] ParticleSystem pickUpVFX;//特效 [SerializeField] VoidEventChannel gateTriggeredEventChannel; // public event System.Action OpenDoor;//定义委托 private void OnTriggerEnter(Collider other) { gateTriggeredEventChannel.Broadcast();//调用委托 SoundEffectsPlayer.audioSource.PlayOneShot(pickUpSound); Instantiate(pickUpVFX, transform.position, Quaternion.identity); Destroy(gameObject);//摧毁 }} 修改Gate代码序列化获取VoidEventChannel可脚本化对象，调用其中订阅和退订函数,意为委托执行时摧毁门。 12345678910111213141516171819using UnityEngine;public class Gate : MonoBehaviour{ [SerializeField] VoidEventChannel gateTriggeredEventChannel; private void OnEnable() { //gateTrigger.OpenDoor += Open; gateTriggeredEventChannel.AddListener(Open); } private void OnDisable() { //gateTrigger.OpenDoor -= Open; gateTriggeredEventChannel.RemoveListener(Open); } void Open() { Destroy(gameObject); }} 配置GateTrigger和相对应的Gate拖入可视化脚本对象，VoidEventChannel 此时,拾取蓝宝石将会摧毁宝石和红门。","link":"/Blog/2022/09/20/%E5%B9%B3%E5%8F%B0%E8%B7%B3%E8%B7%83%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B%E5%AE%9D%E7%9F%B3%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-delegate/"},{"title":"平台游戏控制器之开始结束画面","text":"平台游戏控制器之开始结束画面说明:开始游戏时播放ui动画,放完后摧毁红色闸门。游戏结束时(吃完红宝石)，弹出用时、结束画面。 开始画面开始时ReadyScreen对象的Canvas和Animator组件默认为开启。 在ReadyScreen对象下新建同名脚本ReadyScreen，拖入脚本化对象VoidEventChannel： ui关闭时调用委托(关门)，并且隐藏Canvas和Animator，播放音效。 123456789101112public class ReadyScreen : MonoBehaviour{ [SerializeField] VoidEventChannel levelStartedEventChannel;//获取事件频道 [SerializeField] AudioClip beginSFX;//开始音效 private void CloseUI() { levelStartedEventChannel.Broadcast();//调用委托 GetComponent&lt;Canvas&gt;().enabled = false; GetComponent&lt;Animator&gt;().enabled = false; SoundEffectsPlayer.audioSource.PlayOneShot(beginSFX);//播放音效 }} 接下来是添加动画事件 动画器中选中最后一帧，添加事件 选择该ui上脚本里的函数CloseUI(),当动画执行到此就会运行该函数。 记得在闸门(StartGate)上添加Gate脚本 附加上对应的脚本化文件。 因此实现通过动画事件，隐藏ui、播放开始动画、移除闸门等操作。 结束画面与上面原理相同，流程：吃到红宝石游戏结束，弹出游戏结束画面。 红宝石中的同名脚本VitoryGem中，获取事件频道，触发函数时调用委托。 1234567891011121314using UnityEngine;public class VitoryGem : MonoBehaviour{ [SerializeField] AudioClip pickUpSound;//音效 [SerializeField] ParticleSystem pickUpVFX;//特效 [SerializeField] VoidEventChannel levelClearedEventChannel;//获取事件频道 private void OnTriggerEnter(Collider other) { levelClearedEventChannel.Broadcast();//调用委托 SoundEffectsPlayer.audioSource.PlayOneShot(pickUpSound); Instantiate(pickUpVFX, transform.position, Quaternion.identity); Destroy(gameObject);//摧毁 }} VictoryScreen对象(UI)创建同名脚本VictoryScreen VictoryScreen默认Canvas和Animator为隐藏 在ShowUI函数中开启显示Canvas和Animator组件。 123456789101112131415161718using UnityEngine;public class VictoryScreen : MonoBehaviour{ [SerializeField] VoidEventChannel levelClearedEventChannel;//获取事件频道 private void OnEnable() { levelClearedEventChannel.AddListener(ShowUI); } private void OnDisable() { levelClearedEventChannel.RemoveListener(ShowUI); } private void ShowUI() { GetComponent&lt;Canvas&gt;().enabled = true; GetComponent&lt;Animator&gt;().enabled = true; }}","link":"/Blog/2022/09/21/%E5%B9%B3%E5%8F%B0%E6%B8%B8%E6%88%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B%E5%BC%80%E5%A7%8B%E7%BB%93%E6%9D%9F%E7%94%BB%E9%9D%A2/"},{"title":"平台游戏控制器之玩家失败","text":"平台游戏控制器之玩家失败说明:玩家碰到尖刺或者被黑球撞到就会死亡 功能实现尖刺碰撞首先选中所有尖刺,为他们添加脚本Spike 1234567891011using UnityEngine;public class Spike : MonoBehaviour{ private void OnTriggerEnter(Collider other) { if (other.TryGetComponent(out PlayerController player)) {//如果碰撞的是挂载PlayerController的对象 player.OnDefeated();//游戏失败，玩家身上相关功能禁用 } }} 角色属性调整(关闭功能)通过问题修复功能,自动在PlayerController脚本中生成**OnDefeated()**函数; 同样地,在input类中生成DisableGamePlayInputs(); 123456789public void OnDefeated() {//游戏失败 input.DisableGamePlayInputs();//关闭输入 rigidBody.velocity = Vector3.zero;//速度清零 rigidBody.useGravity = false;//关闭重力对刚体的影响 rigidBody.detectCollisions = false;//关闭刚体碰撞检测 //状态机切换到失败状态 GetComponent&lt;StateMachine&gt;().SwitchState(typeof(PlayerState_Defeated)); } DisableGamePlayInputs();只有一行代码:禁用当前输入动作表。playerInputAction.GamePlay.Disable(); 小球碰撞为球Ball添加脚本Ball,如果球撞到玩家,则执行玩家死亡游戏失败逻辑。 1234567891011121314151617using System.Collections;using System.Collections.Generic;using UnityEngine;public class Ball : MonoBehaviour{ [SerializeField] Collider gameplayer;//获取玩家碰撞体 [SerializeField] PlayerController player;//获取玩家控制器 private void OnCollisionEnter(Collision other) { //Debug.Log(other.collider); //Debug.Log(gameplayer); if (other.collider == gameplayer) { player.OnDefeated(); } }} 更简便的写法: 12345678910111213141516171819using System.Collections;using System.Collections.Generic;using UnityEngine;public class Ball : MonoBehaviour{ // [SerializeField] Collider gameplayer;//获取玩家碰撞体 // [SerializeField] PlayerController player;//获取玩家控制器 private void OnCollisionEnter(Collision other) { if (other.gameObject.TryGetComponent(out PlayerController player)) { player.OnDefeated(); } // if (other.collider == gameplayer) // { // player.OnDefeated(); // } }} 给小球加上消失功能,大约6s摧毁自身 12345678910111213141516171819202122232425262728using System;using System.Collections;using System.Collections.Generic;using UnityEngine;public class Ball : MonoBehaviour{ [SerializeField] VoidEventChannel ballTriggeredEventChannel; private void OnEnable() { ballTriggeredEventChannel.AddListener(EliminateBall); } private void OnDisable() { ballTriggeredEventChannel.RemoveListener(EliminateBall); } private void OnCollisionEnter(Collision other) { if (other.gameObject.TryGetComponent(out PlayerController player)) { player.OnDefeated(); } } private void EliminateBall() { Destroy(gameObject, 6f); }} 对状态的操作新建状态PlayerState_Defeated 用来玩家生成死亡时的音效、特效 123456789101112131415using System;using UnityEngine;[CreateAssetMenu(menuName = &quot;Data/StateMachine/PlayerState/Defeated&quot;, fileName = &quot;PlayerState_Defeated&quot;)]public class PlayerState_Defeated : PlayerState{ [SerializeField] ParticleSystem Deathvfx;//死亡特效 [SerializeField] AudioClip[] voice;//音效集合 public override void Enter() { base.Enter(); Instantiate(Deathvfx, player.transform.position, Quaternion.identity);//生成特效 AudioClip deathVoice = voice[UnityEngine.Random.Range(0, voice.Length)];//随机选中一个音效 player.voicePlayer.PlayOneShot(deathVoice);//播放音效 }} UI相关新建SceneLoader脚本用来管理场景的切换，用来实现ui中按钮功能 1234567891011121314151617181920212223242526272829303132using System;using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.SceneManagement;public class SceneLoader{ public static void ReloadScene() {//重开 int sceneIndex = SceneManager.GetActiveScene().buildIndex;//获取场景下标 SceneManager.LoadScene(sceneIndex);//切换为当前场景(重进) } public static void QuitGame() {//退出游戏 //如果在编辑器中运行#if UNITY_EDITOR UnityEditor.EditorApplication.isPlaying = false;//判断当前是否处于游戏状态#else Application.Quie();//退出应用#endif } public static void LoadNextScene() {//下一关 int sceneIndex = SceneManager.GetActiveScene().buildIndex + 1;//获取下一关场景下标 if (sceneIndex &gt;= SceneManager.sceneCount) {//如果下标大于场景总数 ReloadScene();//返回当前关 return; } SceneManager.LoadScene(sceneIndex);//切换为下一关 }} UI中新建DefeatScreen同名脚本 OnEnable和OnDisable中订阅、退订按钮功能。 PlayerShot中实现随机播放失败bgm。这里有个问题，我在玩家失败状态类中实现这个功能的时候，最终运行时音效呈现的效果是若干音乐叠加 而且音调更低，排查了很久找不到原因，所以我把这个功能改成了动画事件触发。动画里事件大概在这个位置 123456789101112131415161718192021222324252627282930313233343536using System;using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class DefeatScreen : MonoBehaviour{ [SerializeField] VoidEventChannel playerDefeatedEventChannel;//获取事件频道 [SerializeField] AudioClip[] voice;//加油音效合集 [SerializeField] Button retryButton; [SerializeField] Button quitButton; private void OnEnable() { playerDefeatedEventChannel.AddListener(ShowUI);//订阅展示ui函数 retryButton.onClick.AddListener(SceneLoader.ReloadScene);//订阅重置按钮功能 quitButton.onClick.AddListener(SceneLoader.QuitGame);//订阅退出按钮功能 } private void OnDisable() { playerDefeatedEventChannel.RemoveListener(ShowUI); retryButton.onClick.RemoveListener(SceneLoader.ReloadScene); quitButton.onClick.RemoveListener(SceneLoader.QuitGame); } private void ShowUI() { GetComponent&lt;Canvas&gt;().enabled = true; GetComponent&lt;Animator&gt;().enabled = true; Cursor.lockState = CursorLockMode.None;//显示鼠标光标 } void PlayerShot() { AudioClip retryVoice = voice[UnityEngine.Random.Range(0, voice.Length)];//随机播放加油音效 //游戏错误失败音效 许可:CC-BY 作者:GabrielAraujo 来源:耳聆网 https://www.ear0.com/sound/13207 SoundEffectsPlayer.audioSource.PlayOneShot(retryVoice);//播放音效 }}","link":"/Blog/2022/09/21/%E5%B9%B3%E5%8F%B0%E6%B8%B8%E6%88%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B%E7%8E%A9%E5%AE%B6%E5%A4%B1%E8%B4%A5/"},{"title":"平台游戏控制器之状态驱动虚拟相机","text":"平台游戏控制器之状态驱动虚拟相机说明:为角色胜利镜头做特殊定制 follow属性用玩家对象 Animated Target:动画目标属性,拖入角色. 原有的相机拖入状态驱动虚拟相机下 复制一个相机改名为Zoom In,意为镜头放大的虚拟相机. 将镜头垂直视野值36改为24 回到状态驱动虚拟相机对象,在这可选玩家不同状态对应使用不同的相机,还可以设置延迟1.2秒切换","link":"/Blog/2022/09/23/%E5%B9%B3%E5%8F%B0%E6%B8%B8%E6%88%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B%E7%8A%B6%E6%80%81%E9%A9%B1%E5%8A%A8%E8%99%9A%E6%8B%9F%E7%9B%B8%E6%9C%BA/"},{"title":"平台游戏控制器之过关","text":"平台游戏控制器之过关过关功能实现说明:过关时开启ui,切换状态为vitory,落地后再播放动画。 VictoryScreen中增加代码:订阅按钮功能,唤出鼠标指针。 1234567891011121314151617181920212223using UnityEngine;using UnityEngine.UI;public class VictoryScreen : MonoBehaviour{ [SerializeField] VoidEventChannel levelClearedEventChannel;//获取事件频道 [SerializeField] Button nextLevelButton; private void OnEnable() { levelClearedEventChannel.AddListener(ShowUI); nextLevelButton.onClick.AddListener(SceneLoader.LoadNextScene);//订阅下一关按钮功能 } private void OnDisable() { levelClearedEventChannel.RemoveListener(ShowUI); nextLevelButton.onClick.RemoveListener(SceneLoader.LoadNextScene);//订阅下一关按钮功能 } private void ShowUI() { GetComponent&lt;Canvas&gt;().enabled = true; GetComponent&lt;Animator&gt;().enabled = true; Cursor.lockState = CursorLockMode.None; }} PlayerState_Land的LogicUpdate中添加判定，如果玩家胜利，则切换为PlayerState_Victory状态。 PlayerState_Victory状态主要进行随机播放获胜音效。 12345678910public class PlayerState_Victory : PlayerState{ [SerializeField] AudioClip[] voice; public override void Enter() { base.Enter(); input.DisableGamePlayInputs();//关闭动作表 player.voicePlayer.PlayOneShot(voice[Random.Range(0, voice.Length)]); }}","link":"/Blog/2022/09/23/%E5%B9%B3%E5%8F%B0%E6%B8%B8%E6%88%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B%E8%BF%87%E5%85%B3/"},{"title":"平台游戏控制器之计时功能","text":"平台游戏控制器之计时功能ready动画结束-&gt;游戏开始-&gt;开始计时,直到死亡或者胜利再暂停计时。 1、创建带参数的委托。","link":"/Blog/2022/09/23/%E5%B9%B3%E5%8F%B0%E6%B8%B8%E6%88%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B%E8%AE%A1%E6%97%B6%E5%8A%9F%E8%83%BD/"},{"title":"Csharp中问号的用法（转载）","text":"C#中? 、?? 、?. 、??= 的用法和说明（转载）一、可空类型修饰符&lt; ? &gt;引用类型能用空引用来表示一个表示一个不存在的值，但是值类型不能。例如： 12string str = null;int i = null;//编译报错 为了使值类型也能使用可空类型，就可以用 “ ? “来表示，表现形式为”T?”。例如： 12int i? //表示可空的整型DateTime time? //表示可空的时间 二、空合并运算符&lt; ?? &gt;用于定义引用类型和可空类型的默认值。如果此运算符的左操作数不为Null，则此操作符将返回左操作数，否则返回右操作数。 var c = a??b //当a不为null时返回a，为null时返回b 三、&lt; ?. &gt;不为null时执行后面的操作。例如： 12Person.Name?.Person.Code Person.Name = Person == null ? null : Person.Code //两段代码等效 四、&lt; ??= &gt;C# 8.0 引入了 null 合并赋值运算符 ??=。 仅当左操作数计算为 null 时，才能使用运算符 ??= 将其右操作数的值分配给左操作数。 123456789List&lt;int&gt; numbers = null;int? i = null;numbers ??= new List&lt;int&gt;();numbers.Add(i ??= 17);numbers.Add(i ??= 20);Console.WriteLine(string.Join(&quot; &quot;, numbers)); // output: 17 17Console.WriteLine(i); // output: 17 版权声明：本文为CSDN博主「机械键盘侠」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/xuchen_wang/article/details/102850615","link":"/Blog/2022/09/25/Csharp%E4%B8%AD%E9%97%AE%E5%8F%B7%E7%9A%84%E7%94%A8%E6%B3%95/"},{"title":"开发笔记","text":"开发笔记在给任务轨迹Trail找安放位置的时候我发现：这个模型还有好多武器之类的cube，于是打算做个笔记，以后也许能用到。 另外有一个想法：吃到蓝色超级跳宝石时给角色换双鞋子，将这个超能力设定改为装备赋予，给鞋子加一个Trail短一点的轨迹，应该很酷。 这样的话就需要学一下换装了。干脆在开始页面来一个自定义装扮场景。 刚开始我设想是点击图标然后隐藏/显示角色身上对应的衣服，看了视频的开头才知道，可以给角色换骨骼和mesh，确实比直接开关gameobject合理得多，更省资源。国庆几天尝试一下。","link":"/Blog/2022/10/01/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"git","slug":"git","link":"/Blog/tags/git/"},{"name":"unity","slug":"unity","link":"/Blog/tags/unity/"},{"name":"塔防demo","slug":"塔防demo","link":"/Blog/tags/%E5%A1%94%E9%98%B2demo/"},{"name":"Csharp","slug":"Csharp","link":"/Blog/tags/Csharp/"},{"name":"ue4材质","slug":"ue4材质","link":"/Blog/tags/ue4%E6%9D%90%E8%B4%A8/"},{"name":"ScriptableObject","slug":"ScriptableObject","link":"/Blog/tags/ScriptableObject/"},{"name":"正则表达式","slug":"正则表达式","link":"/Blog/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"VsCode","slug":"VsCode","link":"/Blog/tags/VsCode/"},{"name":"Invoke","slug":"Invoke","link":"/Blog/tags/Invoke/"},{"name":"Cinemachine Camera","slug":"Cinemachine-Camera","link":"/Blog/tags/Cinemachine-Camera/"},{"name":"平台跳跃控制器","slug":"平台跳跃控制器","link":"/Blog/tags/%E5%B9%B3%E5%8F%B0%E8%B7%B3%E8%B7%83%E6%8E%A7%E5%88%B6%E5%99%A8/"},{"name":"OnGUI","slug":"OnGUI","link":"/Blog/tags/OnGUI/"},{"name":"开发笔记","slug":"开发笔记","link":"/Blog/tags/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"unity","slug":"unity","link":"/Blog/categories/unity/"},{"name":"Csharp","slug":"Csharp","link":"/Blog/categories/Csharp/"},{"name":"ue4","slug":"ue4","link":"/Blog/categories/ue4/"},{"name":"git","slug":"git","link":"/Blog/categories/git/"},{"name":"基础学习","slug":"Csharp/基础学习","link":"/Blog/categories/Csharp/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"name":"开发工具","slug":"开发工具","link":"/Blog/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"基础学习","slug":"基础学习","link":"/Blog/categories/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}],"pages":[{"title":"links","text":"","link":"/Blog/links/index.html"},{"title":"about","text":"你好，我是Niaoyu。个人博客用来分享作品记录、笔记；还有偶尔想到的idea","link":"/Blog/about/index.html"},{"title":"tags","text":"","link":"/Blog/tags/index.html"}]}