{"meta":{"title":"Niaoyu","subtitle":"🌼付诸行动","description":"Niaoyu","author":"ZHY","url":"https://niaoyu00.github.io/Blog","root":"/Blog/"},"pages":[{"title":"","date":"2022-12-13T09:50:11.414Z","updated":"2022-12-13T09:50:11.414Z","comments":true,"path":"about/index.html","permalink":"https://niaoyu00.github.io/Blog/about/index.html","excerpt":"","text":"该博客主要用来分享我的学习记录以及一些笔记 还有偶尔想到的idea 博客用到的技术 Github Hexo hexo-theme-volantis gitalk评论插件 图床阿里oss对象存储 欢迎互相探讨交流!"},{"title":"","date":"2022-12-13T06:18:13.241Z","updated":"2022-12-13T06:18:09.233Z","comments":true,"path":"archives/index.html","permalink":"https://niaoyu00.github.io/Blog/archives/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-05-10T06:52:28.000Z","updated":"2022-12-13T09:37:38.511Z","comments":true,"path":"friends/index.html","permalink":"https://niaoyu00.github.io/Blog/friends/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-10-13T08:40:23.000Z","updated":"2022-12-13T09:34:36.875Z","comments":false,"path":"category/index.html","permalink":"https://niaoyu00.github.io/Blog/category/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-05-10T06:52:13.000Z","updated":"2022-12-13T09:34:12.751Z","comments":false,"path":"tag/index.html","permalink":"https://niaoyu00.github.io/Blog/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"vloantis主题回顶按钮","slug":"vloantis主题回顶按钮","date":"2022-12-14T04:02:18.000Z","updated":"2022-12-14T04:54:50.849Z","comments":true,"path":"2022/12/14/vloantis主题回顶按钮/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/12/14/vloantis%E4%B8%BB%E9%A2%98%E5%9B%9E%E9%A1%B6%E6%8C%89%E9%92%AE/","excerpt":"","text":"最近博客换了个新的主题: vloantis文档 研究了半天发现找不到回顶按钮,通过对比f12发现是有这个按钮,但是官方文档中并没有找到相关配置. 于是我就打算自己加一个. 设置回滚锚点 Volantis 用户可以在不修改主题文件的情况下向 head 和 body 中添加各种标签 代码片段注入的位置： head_begin: 注入在 &lt;head&gt; 之后 head_end: 注入在 &lt;/head&gt; 之前 body_begin: 注入在 &lt;body&gt; 之后 body_end: 注入在 &lt;/body&gt; 之前 import: head_begin: - &lt;meta name=&quot;theme-color&quot; content=&quot;#ffffff&quot;&gt; head_end: - &lt;meta name=&quot;hello&quot; content=&quot;world&quot;&gt; body_begin: - &lt;script&gt;&lt;/script&gt; body_end: - &lt;script&gt;&lt;/script&gt; 首先打开blog/_config.yml,最下面添加如下代码 第一行代码是css平滑滚动样式 第二行代码是设立锚点方便跳转 然后打开主题文件夹下的layout/layout.ejs,搜索s-top,并且添加下图内容即可. 以上内容作废,因为我发现切换到tag和category页面,&lt;span&gt;就不显示了导致没法回顶. 然后又f12看了一番,发现有现成的锚点(笑死 回到顶部功能重写首先打开blog/_config.yml,最下面添加如下代码 import: head_begin: - &lt;style&gt;html&#123;scroll-behavior:smooth;&#125;&lt;/style&gt; # - &lt;span id=&quot;topTarget&quot;&gt;&lt;/span&gt; 其次打开主题文件夹下的layout/layout.ejs,搜索s-top,并且添加下图内容 到此就完成了,是不是非常简单!","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://niaoyu00.github.io/Blog/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://niaoyu00.github.io/Blog/tags/Hexo/"},{"name":"vloantis","slug":"vloantis","permalink":"https://niaoyu00.github.io/Blog/tags/vloantis/"}]},{"title":"动作游戏制作","slug":"动作游戏制作","date":"2022-12-12T09:54:22.000Z","updated":"2022-12-13T06:03:45.195Z","comments":true,"path":"2022/12/12/动作游戏制作/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/12/12/%E5%8A%A8%E4%BD%9C%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C/","excerpt":"","text":"开个新坑,最近瓶颈期,我觉得需要多敲代码,让自己更熟悉unity. 教程原链接: https://www.udemy.com/course/project-little-adventurer-learn-to-create-a-3d-action-game/ b站视频链接: 【UNITY教程 | 学习使用高质量的游戏资产创建 3D 动作游戏（更新完毕）】https://www.bilibili.com/video/BV1B14y1E7SW?p=6&amp;vd_source=b702db14148b48ad87406aaf674e1744 付费教程且看且珍惜,是生肉,但是勉强硬啃. 下面内容是我边查资料,边尝试理解作者的操作意图,如有不对欢迎指出. 导入资源包首先,项目设置里,设置渲染为线性渲染.以下内容为转载 线性渲染Linear Rendering 和 Gamma Rendering的区别Linear Rendering就是在shader中所有计算会在线性空间下进行，Gamma Rendering就是在shader中不进行转换到线性空间下，直接计算。然就是计算方程式不同，也就意味例如光照表面会有不同的响应曲线和图片效果，表现不相同。 1.Light Falloff 光照表现一般受光源的距离和法线两个因素影响（在同等光强下）。首先当我们用Linear Rendering时，执行Gamma矫正将会使光照范围变大。第二种会使边缘模糊，分不清界限。这更准确的表现了表面光照强度下降。 2.表面响应强度 随着光强的增加，非线性方式计算的表面会更亮一些。这导致了光照在表面很多地方曝光过度，而且给场景模型一个褪色（变白色了）的感觉。当你用线性渲染时，表面颜色仍然随着光照强度线性增加的，这样就使表面材质和颜色更接近现实. 3.混合 混合是在帧缓冲区发生的，当使用Gamma Rendering，这表示颜色之间混合是在非线性空间下计算的。然而这是不正确的。 上图是在Linear Space中混合结果，颜色之间过度不是很明显。 上图是Gamma Space中混合结果，颜色交界处出现了明显的其它颜色，颜色更亮，出现褪色的现象。 4.Mipmaps 计算纹理Mipmap是种线性计算，需要对某个方形区域内像素取平均值，如果纹理存储在非线性空间，那么计算时也是在非线性空间里计算，这样就会得到错误的结果。正确的做法是先转换到线性空间在计算mipmap。 5.Lightmapping 切换linear 和gamma方式，需要重新烘焙相关的Lightmapping。 关于渲染我了解的很少,具体资料可以参考: ————————————————版权声明：本文为CSDN博主「追风者t」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/k46023/article/details/52489363/","categories":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/categories/unity/"}],"tags":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/tags/unity/"},{"name":"动作游戏","slug":"动作游戏","permalink":"https://niaoyu00.github.io/Blog/tags/%E5%8A%A8%E4%BD%9C%E6%B8%B8%E6%88%8F/"}]},{"title":"花了两天学习了像素画","slug":"花了两天学习了像素画","date":"2022-12-01T10:11:25.000Z","updated":"2022-12-02T09:14:45.364Z","comments":false,"path":"2022/12/01/花了两天学习了像素画/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/12/01/%E8%8A%B1%E4%BA%86%E4%B8%A4%E5%A4%A9%E5%AD%A6%E4%B9%A0%E4%BA%86%E5%83%8F%E7%B4%A0%E7%94%BB/","excerpt":"","text":"前两天偶然刷到像素画的教程，抱着试一试的态度，边看边练习了一下。 链接:只要看到11p就行 https://www.bilibili.com/video/BV1hJ411c73i?p=1&amp;vd_source=7aa5bcb5a7c34becbf26b1d712279ba8 我使用的软件是Aseprite，个人认为比ps好用10000倍！ Aseprite快捷键少，并且没有那么多用不着的功能（我个人认为仅像素画来说使用Photoshop有点臃肿），且不会闪退。 花了点时间熟悉快捷键操作（这步很重要），用快捷键是效率的基础。只要根据up的节奏一起做一遍差不多就会了，比较费时间的部分是最后画图，处理细节的地方，而这部分就是像素画的精髓。先晒一下我的成果~ 这个表情包花了我差不多两天才完成，效果我还挺满意的\\^o^/,最花时间的地方在于各种细节. 比如光照我花了好多时间,一直在微调,如果有美术基础的童鞋应该会比较容易上手,我是一边调一边在看效果,怎么说呢感觉全靠个人审美在支撑着反复修改.当然作为第一个像素画临摹作品肯定有很多不足,不过在我这是过关了哈哈哈,下午又画了一张以我头像为摹本的像素画,效果不太理想.总结出问题是我初始定的像素太低,导致脸上很多细节没办法画出来,不过像素画的精华就是低像素抽象化表示复杂的元素,画成这样只能说明我功夫不到家,以后有时间再重新画吧.渣作在下面: 原图 像素图 重新看一眼发现眼镜画得太圆了,我用椭圆工具直接拉得图没有特地修改过,画的时候还真的没注意到. 花了一晚上改进了一下,我悟了,既然像素少,那要表现出意思就必须得将复杂的图像变得简单,纠结了很久的眉毛终于让我换了个位置,舒服多了","categories":[{"name":"美术","slug":"美术","permalink":"https://niaoyu00.github.io/Blog/categories/%E7%BE%8E%E6%9C%AF/"}],"tags":[{"name":"像素画","slug":"像素画","permalink":"https://niaoyu00.github.io/Blog/tags/%E5%83%8F%E7%B4%A0%E7%94%BB/"},{"name":"美术","slug":"美术","permalink":"https://niaoyu00.github.io/Blog/tags/%E7%BE%8E%E6%9C%AF/"}]},{"title":"unity热更新","slug":"unity热更新","date":"2022-11-25T06:53:48.000Z","updated":"2022-12-13T06:03:59.386Z","comments":false,"path":"2022/11/25/unity热更新/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/11/25/unity%E7%83%AD%E6%9B%B4%E6%96%B0/","excerpt":"","text":"尝试了解unity热更新时，总会看到ab包、Addressables、AssetBundle、xlua等关键字，但是没深入了解的话很难搞清楚这几个是啥关系。今天我就尝试去缕一缕！ ..待续","categories":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/categories/unity/"}],"tags":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/tags/unity/"},{"name":"热更新","slug":"热更新","permalink":"https://niaoyu00.github.io/Blog/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"Addressables","slug":"Addressables","permalink":"https://niaoyu00.github.io/Blog/tags/Addressables/"},{"name":"AssetBundle","slug":"AssetBundle","permalink":"https://niaoyu00.github.io/Blog/tags/AssetBundle/"},{"name":"AB包","slug":"AB包","permalink":"https://niaoyu00.github.io/Blog/tags/AB%E5%8C%85/"}]},{"title":"lua语法","slug":"lua语法","date":"2022-11-24T05:29:11.000Z","updated":"2022-12-02T09:48:04.309Z","comments":false,"path":"2022/11/24/lua语法/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/11/24/lua%E8%AF%AD%E6%B3%95/","excerpt":"","text":"lua的注释符号用– Lua测试链接:https://wiki.luatos.com/_static/luatos-emulator/lua.html 变量声明直接a&#x3D;1为全局声明,可在别的文件使用. 要想限制就在变量前加local,local a=1 多重赋值a,b=1,233print(a,b)--------运行结果[13:32:39] 1 233 未声明变量为nil,类似null a,b,c=1,233print(a,b,c)--------[13:34:56] 1 233 nil 数值型numberint char long float之类的统一叫做number lua支持Ox开头十六进制表示 支持科学计数法 a=0x10b=2e2print(a,b)-------[13:39:12] 16 200.0 运算符支持运算符支持加减乘除幂运算之类的运算符 a=0x6b=2print(a^b)--------[13:41:52] 36.0 支持移位0001左移四位1000 print(1&lt;&lt;4)----------[13:43:56] 16 字符串可以用单引号,支持转义字符b=&quot;asd\\ndddd&quot;a=&#x27;asdf&#x27;print(a)print(b)----------[13:47:35] asdf[13:47:35] asddddd 支持输出多行字符c=[[qqqq\\n12357777asdasd]]print(c)------------------[13:49:17] qqqq\\n12357777asdasd 字符串连接符号..用加号连接会报错 a=&#x27;111&#x27;b=&#x27;bbbb&#x27;d=a+bprint(d)-------------[13:51:26] [string &quot;a=&#x27;111&#x27;...&quot;]:4: attempt to perform arithmetic on a string value (global &#x27;b&#x27;)============a=&#x27;111&#x27;b=&#x27;bbbb&#x27;c=a..bprint(c)----------[13:52:10] 111bbbb 数字转字符串tostring()字符串转数字tonumber()转换失败会打印nil #号获取字符串长度n=&quot;csdfs&quot;print(#n)--------[14:02:04] 5 string.char()string.char()可以将ASCII码值变成字符串 string.byte(a,b)可以将ASCII码值转十进制.a为字符串,b为下标 s=string.char(0x2e,0x2f,0x30,0x31,0x32)for i=1,#s do n=string.byte(s,i) print(n)endprint(s)------------[17:36:36] 46[17:36:36] 47[17:36:36] 48[17:36:36] 49[17:36:36] 50[17:36:36] ./012 函数两种定义方式function f1( a ) print(&quot;第一个函数:&quot;..a)endf2=function( a ) print(&quot;第2个函数:&quot;..a)endf1(1)f2(2)---------------[14:06:25] 第一个函数:1[14:06:25] 第2个函数:2 自定义return内容这个print里a和c要输出的话都是nil function f( a,b,c ) return bendprint(f(a,&quot;b&quot;,c))------------[14:12:12] b 多个返回值可以配合多重赋值function f( a,b,c ) return a,b,cendlocal i,j,k = f(a,&quot;b&quot;,7)print(i,j,k)------[14:19:00] nil b 7 table数字下标a=&#123;&quot;A&quot;,123,&#123;&#125;,function()return 1; end&#125;a[5]=555for i,v in ipairs(a) do print(i,v)endprint(&quot;第一个元素用下标1:&quot;..a[1])print(#a)--------[15:44:03] 1 A[15:44:03] 2 123[15:44:03] 3 table: 0x154[15:44:03] 4 function: 0x155[15:44:03] 5 555[15:44:03] 第一个元素用下标1:A[15:44:03] 5 插入元素table.insert(a,3,&quot;新插入&quot;),在table a中的索引3前插入字符串”新插入”, table.remove()与insert同理 a=&#123;&quot;A&quot;,123,&#123;&#125;,function() end&#125;a[5]=555function p() for i,v in ipairs(a) do print(i,v) end print(&quot;--------------&quot;);endprint(&quot;第一个元素用下标1:&quot;..a[1])print(&quot;count:&quot;..#a)p()table.insert(a,3,&quot;新插入&quot;)print(&quot;count:&quot;..#a)p()================================第一个元素用下标1:A[15:53:42] count:5[15:53:42] 1 A[15:53:42] 2 123[15:53:42] 3 table: 0x155[15:53:42] 4 function: 0x156[15:53:42] 5 555[15:53:42] --------------[15:53:42] count:6[15:53:42] 1 A[15:53:42] 2 123[15:53:42] 3 新插入[15:53:42] 4 table: 0x155[15:53:42] 5 function: 0x156[15:53:42] 6 555[15:53:42] -------------- 字符串作为下标有点像字典,也是分为键值对,但是这个调用真的非常自由 符合规范的key可以用t.a这种形式直接调用 不符合规范的可以在方括号中调用:[“乱写的下标”] 定义的时候也必须加方括号. t=&#123; a=1, b=&quot;bb&quot;, c=function() end, d=&#123;&#125;, [&quot;乱写的下标&quot;]=&quot;啊啊啊&quot;&#125;print(t[&quot;a&quot;])print(t.a)print(t[&quot;乱写的下标&quot;])-------------------[16:03:51] 1[16:03:51] 1[16:03:51] 啊啊啊 t=&#123; a=1, b=&quot;bb&quot;, c=function() end, d=&#123;&#125;, [&quot;乱写的下标&quot;]=&quot;乱写的下标的内容&quot;&#125;print(t[&quot;a&quot;])print(t.a)print(t[&quot;乱写的下标&quot;])t.f=&quot;新增f&quot;print(t.f)t.a=&quot;修改后的a&quot;print(t.a)----------------[16:10:32] 1[16:10:32] 1[16:10:32] 乱写的下标的内容[16:10:32] 新增f[16:10:32] 修改后的a 全局表_G所有的全局变量都存在**_G表**中 a=1print(_G.a)print(_G.b)-------------[16:12:58] 1[16:12:58] nil table也属于_G,所以_G[&quot;table&quot;]打印出来也是table,table的insert方法,打印出来可以看到是function类型 print(_G[&quot;table&quot;])print(_G[&quot;table&quot;][&quot;insert&quot;])--------------[16:16:18] table: 0x10[16:16:18] function: 0x155 真假判断符号lua中的不等于号是~=而不是!= a=trueb=falseprint(1&gt;2)print(1&lt;2)print(1&gt;=2)print(1&lt;=2)print(1==2)print(1~=2)----------------[16:22:12] false[16:22:12] true[16:22:12] false[16:22:12] true[16:22:12] false[16:22:12] true 与或非a=trueb=falseprint(a and b)print(a or b)print(not a)-----------[16:24:39] false[16:24:39] true[16:24:39] false lua中只有false和nil为假,其他包括数字0都为真 与或非运算lua可以直接输出结果 a=0 --真b=nil --假print(a and b)print(a or b)print(not a)----------[16:28:50] nil[16:28:50] 0[16:28:50] false 两个正确参数and运算,输出右边的值;两个正确参数or运算,输出左边值; 两个错误参数or运算,输出右边的值;两个错误参数and运算,输出左边值; 一正一错进行and,输出错误值 一正一错进行or,输出正确值 print(1 and 0)print(1 or 0)print(false or nil)print(false and nil)-------------[16:52:01] 0[16:52:01] 1[16:52:01] nil[16:52:01] false print((2&gt;1)and&quot;正确&quot;or&quot;错误&quot;)print((2==1)and&quot;正确&quot;or&quot;错误&quot;)-------------[16:44:45] 正确[16:44:45] 错误 条件判断if 1&gt;2 then print(&quot;1&gt;2&quot;)elseif 1&lt;2 then print(&quot;1&lt;2&quot;)else print(&quot;错误&quot;)end-------------[17:02:06] 1&lt;2 循环for循环第三个参数是步长 for i=1,5 do print(i)endprint(&quot;=================&quot;)for i=1,5,2 do print(i)end------------------[17:09:50] 1[17:09:50] 2[17:09:50] 3[17:09:50] 4[17:09:50] 5[17:09:50] =================[17:09:50] 1[17:09:50] 3[17:09:50] 5 如果i比结束数字大,则步长要为负数,例如-1 for i=10,5,-1 do print(i)end-----------[17:11:47] 10[17:11:47] 9[17:11:47] 8[17:11:47] 7[17:11:47] 6 循环途中更改i的值无效,但是可以通过break弹出 for i=10,5,-1 do print(i) if i==7 then break endend------------[17:15:32] 10[17:15:32] 9[17:15:32] 8[17:15:32] 7 while循环lua不支持x--或者x-=1;只能使用x=x-1; local x = 5while x&gt;1 do x=x-1 print(x)end-----------[17:18:20] 4[17:18:20] 3[17:18:20] 2[17:18:20] 1","categories":[{"name":"lua","slug":"lua","permalink":"https://niaoyu00.github.io/Blog/categories/lua/"}],"tags":[{"name":"lua","slug":"lua","permalink":"https://niaoyu00.github.io/Blog/tags/lua/"}]},{"title":"Hexo-next文章内置标签","slug":"Hexo-next文章内置标签","date":"2022-11-22T15:46:57.000Z","updated":"2022-12-13T08:13:40.527Z","comments":true,"path":"2022/11/22/Hexo-next文章内置标签/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/11/22/Hexo-next%E6%96%87%E7%AB%A0%E5%86%85%E7%BD%AE%E6%A0%87%E7%AD%BE/","excerpt":"","text":"文本居中引用&lt;!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt;&lt;!-- 其中 class=&quot;blockquote-center&quot; 是必须的 --&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;blah blah blah&lt;/blockquote&gt;&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;&#123;% centerquote %&#125;blah blah blah&#123;% endcenterquote %&#125;&lt;!-- 标签别名 --&gt;&#123;% cq %&#125; blah blah blah &#123;% endcq %&#125; 效果实例: 突破容器宽度限制的图片&lt;!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt;&lt;!-- 其中 class=&quot;full-image&quot; 是必须的 --&gt;&lt;img src=&quot;/image-url&quot; class=&quot;full-image&quot; /&gt;&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;&#123;% fullimage /image-url, alt, title %&#125;&lt;!-- 别名 --&gt;&#123;% fi /image-url, alt, title %&#125;","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://niaoyu00.github.io/Blog/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://niaoyu00.github.io/Blog/tags/Hexo/"},{"name":"next","slug":"next","permalink":"https://niaoyu00.github.io/Blog/tags/next/"},{"name":"文章内置标签","slug":"文章内置标签","permalink":"https://niaoyu00.github.io/Blog/tags/%E6%96%87%E7%AB%A0%E5%86%85%E7%BD%AE%E6%A0%87%E7%AD%BE/"}]},{"title":"unity模型换装","slug":"unity模型换装","date":"2022-11-19T06:57:09.000Z","updated":"2022-11-22T06:34:24.849Z","comments":true,"path":"2022/11/19/unity模型换装/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/11/19/unity%E6%A8%A1%E5%9E%8B%E6%8D%A2%E8%A3%85/","excerpt":"","text":"开始换装之前,首先需要了解一些概念. 参考部分以下内容转载自博客: https://sunra.top/2021/11/07/uniyt-change-suit/ 骨骼，蒙皮和动画目前游戏开发中常用的两种动画：顶点动画和蒙皮动画 顶点动画 通过在动画帧中直接修改mesh顶点的位置来实现，通常在mesh顶点数目较少，动画简单的情况下使用，如草的摆动，树的摆动，水的波动等 蒙皮动画 通过在动画中直接修改bone的位置，让mesh的顶点随着bone的变化而变化，通常用于人形动画，如人物的跑动，跳跃等 骨骼是什么当我们倒入带有骨骼的Model时，我们可以在其中发现一个嵌套的GameObject，这个GamoeObject以及它的所有的子GameObject都只有一个属性，就是transforms的坐标信息，这些坐标信息组成了该模型的骨骼信息。 蒙皮是什么我们知道Mesh是由顶点和面组成的，如果不绑定蒙皮数据，称之为静态mesh，不具有动画效果的，如游戏中的房子，地面，桥，道路等； 对于绑定蒙皮的mesh，我们称之为SkinMesh，在SkinMesh中每个mesh的顶点会受到若干个骨骼的影响，并配以一定的权重比例； 就像我们真实的人一样，首先支撑并决定位置和运动的是一组骨骼，头+身体+四肢，而身上的肌肉是受到骨骼的影响而产生运动的，每一块肌肉的运动可能会受到多个骨骼的影响； 蒙皮中需要的数据在unity中主要是通过SkinnedMeshRenderer组件来实现蒙皮动画的计算 计算蒙皮动画所需要的数据：SkinnedMeshRenderer.bones：所有引用到bone的列表，注意顺序是确定的，后续顶点的BoneWeight中bone的索引，就是基于这个数组顺序的索引SkinnedMeshRenderer.sharedMesh：渲染所需的mesh数据，注意相比普通的MeshRender所需的顶点和面数据，还会有一些额外的计算蒙皮相关的数据Mesh.boneWeights：每个顶点受到哪几根bone的影响的索引和权重（每个顶点最多受到四根骨骼的影响，详见结构体BoneWeight的定义）Mesh.bindposes：每根bone从mesh空间到自己的bone空间的变换矩阵，也就是预定义的bone的bone空间到mesh空间的变换矩阵的逆矩阵，注意顶点受到bone影响所做的变换都是基于在bone空间做的变换 根据Unity文档, Unity中BindPose的算法如下: OneBoneBindPose &#x3D; bone.worldToLocalMatrix * transform.localToWorldMatrix;骨骼的世界转局部坐标系矩阵乘上Mesh的局部转世界矩阵 注意：美术一般在绑定蒙皮时，会将骨骼摆成一个Tpose的样式，这个时候的bone的transform转换出矩阵也就是bindpose，所有的骨骼动画都是在这个基础上相对变换的，最终会作为mesh本身的静态数据保存下来。 SkinnedMeshRenderer是一种不同于普通Mesh Renderer的渲染器，普通的渲染器是使用Mesh Filter定义的网格信息加上Material（会指定使用的Shader）对GameObject进行渲染，而SkinnedMeshRenderer不同，它还会有bones等属性，用于表明对应的骨骼信息。这些信息都是在导入模型时自带的，在建模工具中就会定好每个点受到每个骨骼信息的影响，即当骨骼中的某个点位置发生改变时，相应的Mesh如何变化。 换装的两种方式替换SkinnedMeshRender的方式主要适用于衣服，裤子，发型等 替换步骤： 1：一般根据是否单独部位可以换装，将单独部位或者整套模型制作成一个Prefab 2：加载prefab，并实例化为GameObject 3：查找到新实例化的SkinnedMeshRender对应的原有的SkinnedMeshRender 4：替换bones 5：替换mesh 6：替换material 7：替换完成，销毁新实例化的Prefab 节点挂载的方式主要适用于武器，翅膀，尾巴等 替换步骤： 1：一般将单独一套模型制作成一个Prefab 2：加载prefab，并实例化为GameObject 3：查找挂点（比如武器一般会挂载在手的骨骼节点上） 4：销毁原有的装备 5：将实例化的GameObject的父节点设置为挂点 6：设置好GameObject的偏移，缩放，旋转（一般都为0） 个人实现替换smr思路我使用的是第一种方式,替换smr中的蒙皮和骨骼,材质.因为是那套素材的材质是通用的,所以无需替换材质. 首先我是在b站找了siki学院的视频,虽然是好几年前的教程了,小姐姐使用的是嵌套字典来存储模型数据. 大概思路如下: 首先准备一套初始模型(Player),还有一套只有骨骼的目标模型(PlayerTarget),分别做成预制体.放在assets下新建的Resources文件夹内(主要用于代码从这寻找生成); 其次通过代码在世界中生成这两套模型,初始带着若干装备的模型默认setActivity(false); 然后将这套模型的SkinnedMeshRenderer存储在字典中,通过部件名+编号的形式 嵌套存储; 在目标模型对象中读取字典中的SkinnedMeshRenderer中的bones、materials、sharedMesh并替换，完成换装。 初始模型: 实现首先创建一个新场景,随意摆个平面+两面墙 然后在合适位置制作player和playertarget,拖下去作为预制体,并且删除.(注意这俩模型的位置要一致) 新建AvatarSys空物体，挂载脚本AvatarSys.cs. 新建脚本AvatarSysData.cs继承自SriptableObject,用来存储模型对象上读取的数据,在资源文件夹中可右键创建; AvatarSysData:using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.InputSystem.Interactions;/// &lt;summary&gt;/// 存储数据/// &lt;/summary&gt;[CreateAssetMenu(menuName = &quot;Data/PlayerSkin&quot;, fileName = &quot;AvatarSysData_&quot;)]public class AvatarSysData : ScriptableObject&#123; /// &lt;summary&gt; /// 嵌套字典,存储皮肤模型资源信息 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public Dictionary&lt;string, Dictionary&lt;string, SkinnedMeshRenderer&gt;&gt; PLayerSkinData = new Dictionary&lt;string, Dictionary&lt;string, SkinnedMeshRenderer&gt;&gt;(); /// &lt;summary&gt; /// 骨骼位置信息 /// &lt;/summary&gt; public Transform[] playerBoneTrans;//玩家骨骼位置信息 /// &lt;summary&gt; /// 存储换装骨骼上SkinnedMeshRenderer的信息 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;string&quot;&gt;&lt;/typeparam&gt; /// &lt;typeparam name=&quot;SkinnedMeshRenderer&quot;&gt;&lt;/typeparam&gt; /// &lt;returns&gt;&lt;/returns&gt; public Dictionary&lt;string, SkinnedMeshRenderer&gt; PlayerTargetData = new Dictionary&lt;string, SkinnedMeshRenderer&gt;(); /// &lt;summary&gt; /// 模型资源位置信息 /// &lt;/summary&gt; public Transform playerSourceTrans;//玩家模型位置信息 /// &lt;summary&gt; /// 目标模型资源中的骨骼 /// &lt;/summary&gt; public GameObject playerTarget;//目标玩家骨骼 /// &lt;summary&gt; /// 获取时playerStr[0,0]为&quot;Belt&quot;;playerStr[0,1]为&quot;1&quot; /// &lt;/summary&gt; /// &lt;value&gt;&lt;/value&gt; public string[,] playerStr = new string[,] &#123; &#123; &quot;Belt&quot;, &quot;1&quot; &#125;, &#123; &quot;Cloth&quot;, &quot;1&quot; &#125;, &#123; &quot;Face&quot;, &quot;1&quot; &#125;, &#123; &quot;Glove&quot;, &quot;1&quot; &#125;, &#123; &quot;HairHalf&quot;, &quot;1&quot; &#125;, &#123; &quot;Hat&quot;, &quot;1&quot; &#125;, &#123; &quot;Shoe&quot;, &quot;1&quot; &#125;, &#123; &quot;ShoulderPad&quot;, &quot;1&quot; &#125; &#125;; //&#123; &quot;Hair&quot;, &quot;1&quot; &#125;, public SkinnedMeshRenderer[] saveSmr; public SkinnedMeshRenderer[] SaveParts(SkinnedMeshRenderer[] s) &#123; saveSmr = s; return saveSmr; &#125;&#125; AvatarSys.cs:代码内容如下:包含了存储模型信息,以及读取更换服装等功能 //using System.Diagnostics;using System.Text.RegularExpressions;using System.Collections;using System.Collections.Generic;using UnityEngine;public class AvatarSys : MonoBehaviour&#123; [SerializeField] AvatarSysData avatarSysData; /// &lt;summary&gt; /// 原模板模型对象 /// &lt;/summary&gt; GameObject Modelgo; private void OnEnable() &#123; InstantiateSource(); InstantiateTarget(); SaveData(); InitAvatar(); &#125; private void Start() &#123; DontDestroyOnLoad(avatarSysData.playerTarget);//切换场景不会删除 &#125; /// &lt;summary&gt; /// 场景中加载资源物体 /// &lt;/summary&gt; void InstantiateSource() &#123;//加载模型资源物体 Modelgo = Instantiate(Resources.Load(&quot;Player&quot;)) as GameObject; avatarSysData.playerSourceTrans = Modelgo.transform;//玩家资源位置信息 Modelgo.SetActive(false); &#125; /// &lt;summary&gt; /// 场景中加载资源物体加载骨骼 /// &lt;/summary&gt; void InstantiateTarget() &#123;//加载骨骼 avatarSysData.playerTarget = Instantiate(Resources.Load(&quot;PlayerTarget&quot;)) as GameObject; avatarSysData.playerBoneTrans = avatarSysData.playerTarget.GetComponentsInChildren&lt;Transform&gt;(); &#125; /// &lt;summary&gt; /// 保存信息 /// &lt;/summary&gt; void SaveData() &#123;//如果无位置信息则返回 if (avatarSysData.playerSourceTrans == null) &#123; return; &#125; //遍历所有模型资源位置信息子物体,存储SkinnedMeshRenderer SkinnedMeshRenderer[] parts = avatarSysData.playerSourceTrans.GetComponentsInChildren&lt;SkinnedMeshRenderer&gt;(); foreach (var part in parts) &#123; // 取出字符串中所有的英文字母 string PartsNum = Regex.Replace(part.name, &quot;[a-z]&quot;, &quot;&quot;, RegexOptions.IgnoreCase); //取出字符串中所有的数字 string PartsName = Regex.Replace(part.name, &quot;[0-9]&quot;, &quot;&quot;, RegexOptions.IgnoreCase); //string[] names = &#123; PartsName, PartsNum &#125;; //判断字典是否包含键,names[0]:string 名字为身体部件名 if (!avatarSysData.PLayerSkinData.ContainsKey(PartsName)) &#123; //如果不包含此部件名,则在骨骼下新建 //新建空物体 GameObject partGo = new GameObject(); partGo.name = PartsName;//名字为身体部件名 partGo.transform.parent = avatarSysData.playerTarget.transform;//父对象的位置等于骨骼位置 //骨骼字典里存储名字和SkinnedMeshRenderer avatarSysData.PlayerTargetData.Add(PartsName, partGo.AddComponent&lt;SkinnedMeshRenderer&gt;()); //模型字典里存储名字和新建smr avatarSysData.PLayerSkinData.Add(PartsName, new Dictionary&lt;string, SkinnedMeshRenderer&gt;()); &#125; //[模型]字典中根据[部件名]添加数字和SkinnedMeshRenderer avatarSysData.PLayerSkinData[PartsName].Add(PartsNum, part); &#125; &#125; /// &lt;summary&gt; /// 更改mesh,part:部位,num:数字 /// &lt;/summary&gt; /// &lt;param name=&quot;part&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;num&quot;&gt;&lt;/param&gt; public void ChangeMesh(string part, string num) &#123; //从data里获取对应的skm //要更换的部位 SkinnedMeshRenderer skm = avatarSysData.PLayerSkinData[part][num]; //存储骨骼位置信息 List&lt;Transform&gt; bonesList = new List&lt;Transform&gt;(); //skm.bones:需要更换部位的骨骼 foreach (var skmbone in skm.bones) &#123; foreach (var targetbone in avatarSysData.playerBoneTrans) &#123; //如果找到对应骨骼 if (targetbone.name == skmbone.name) &#123; bonesList.Add(targetbone); break; &#125; &#125; &#125; //换装实现 avatarSysData.PlayerTargetData[part].bones = bonesList.ToArray(); avatarSysData.PlayerTargetData[part].materials = skm.materials; avatarSysData.PlayerTargetData[part].sharedMesh = skm.sharedMesh; &#125; /// &lt;summary&gt; /// 初始化骨架 /// &lt;/summary&gt; public void InitAvatar() &#123;//初始化骨架 让他有mesh 材质 骨骼信息 int length = avatarSysData.playerStr.GetLength(0);//0:获取行数;1:获取列 for (int i = 0; i &lt; length; i++) &#123;//i表示第i行 ChangeMesh(avatarSysData.playerStr[i, 0], avatarSysData.playerStr[i, 1]); &#125; //Destroy(Modelgo);//销毁原模型 &#125;&#125; 在游戏场景中读取数据新建ui,注意部件名要和字典中key一致 UI上绑定两个脚本,实现的功能分别是:变换服装(BtnChange.cs),保存跳转(BtnSave.cs) BtnChange.cs:变装实现思路是:通过列表获取按键,循环添加按钮监听器.通过点击按钮,调用avatarSys中ChangeMesh(),这是换装函数;参数是部位,数字,这部分通过按钮名字和点击次数n实现. using System;using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class BtnChange : MonoBehaviour&#123; [SerializeField] AvatarSysData avatarSysData;//scriptobj存储数据 [SerializeField] AvatarSys avatarSys; /// &lt;summary&gt; /// 按钮列表 /// &lt;/summary&gt; [SerializeField] List&lt;Button&gt; listBtnChangeParts;//按钮列表 [SerializeField] Button btnReset;//重置 int n = 1; private void Awake() &#123; for (int i = 0; i &lt; listBtnChangeParts.Count; i++) &#123; listBtnChangeParts[i].onClick.AddListener(ChangeShin); &#125; &#125; private void OnEnable() &#123; btnReset.onClick.AddListener(Reset); &#125; private void OnDisable() &#123; btnReset.onClick.RemoveListener(Reset); &#125; /// &lt;summary&gt; /// 换装 /// &lt;/summary&gt; void ChangeShin() &#123; //获取当前按钮 var button = UnityEngine.EventSystems.EventSystem.current.currentSelectedGameObject; //当前按钮的部件个数 int partCount = avatarSysData.PLayerSkinData[button.name].Count; //Debug.Log(button.name + n.ToString()); //更换部件 //Debug.Log(button.name); if (n &gt;= partCount) &#123; n = 0; //Debug.Log(button.name + &quot;超出&quot;); //更改部位为初始值1 avatarSys.ChangeMesh(button.name, &quot;1&quot;); &#125; n++; avatarSys.BtnChange(button.name, n.ToString()); &#125; /// &lt;summary&gt; /// 重置皮肤 /// &lt;/summary&gt; void Reset() &#123; for (int i = 0; i &lt; listBtnChangeParts.Count; i++) &#123; avatarSys.ChangeMesh(listBtnChangeParts[i].name, &quot;1&quot;); &#125; n = 1; &#125;&#125; BtnSave.cs:保存数据就是将SkinnedMeshRenderer数据存入AvatarSysData,游戏场景中读取时只需要读sharedMesh即可,因为materials是全部件共用一个,bone因为是同骨骼所以不需要换. using System;using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class BtnSave : MonoBehaviour&#123; [SerializeField] AvatarSysData avatarSysData;//保存数据 [SerializeField] Button btnSave; [SerializeField] Button btnJump; private void OnEnable() &#123; btnSave.onClick.AddListener(OnSave); btnJump.onClick.AddListener(SceneLoader.LoadGameScene); &#125; private void OnDisable() &#123; btnSave.onClick.RemoveListener(OnSave); btnJump.onClick.RemoveListener(SceneLoader.LoadGameScene); &#125; /// &lt;summary&gt; /// 保存部件 /// &lt;/summary&gt; public void OnSave() &#123; GameObject player = GameObject.FindWithTag(&quot;SkinModel&quot;); SkinnedMeshRenderer[] smr = player.GetComponentsInChildren&lt;SkinnedMeshRenderer&gt;(); avatarSysData.SaveParts(smr); Debug.Log(&quot;保存&quot;); &#125;&#125; 读取数据换装First Scene中玩家对象Player下的GamePlayer模型里创建一个脚本ChangePlayerSkin.cs 获取当前主角的sharedmesh替换成保存数据中的sharedmesh即可. using System.Collections;using System.Collections.Generic;using System.Linq;using TreeEditor;using UnityEngine;public class ChangePlayerSkin : MonoBehaviour&#123; [SerializeField] AvatarSysData avatarSysData;//获取数据 SkinnedMeshRenderer[] smr; private void Awake() &#123; smr = gameObject.GetComponentsInChildren&lt;SkinnedMeshRenderer&gt;(); &#125; private void OnEnable() &#123; if (GameObject.FindWithTag(&quot;SkinModel&quot;)) &#123; GameObject.FindWithTag(&quot;SkinModel&quot;).SetActive(false);//隐藏前一个场景传来的对象 &#125; &#125; private void Start() &#123; for (int i = 0; i &lt; avatarSysData.saveSmr.Length; i++) &#123; //Debug.Log(&quot;部件名:&quot; + avatarSysData.saveSmr[i].sharedMesh.name); //替换sharemesh smr[i].sharedMesh = avatarSysData.saveSmr[i].sharedMesh; &#125; &#125;&#125; 总结第一次使用scriptableobject来存储,做完发现其实用json存档可能会更合适点,因为这里从不同场景进入换装场景都会初始化皮肤.用json存档的话可以判断key来读取存档,实现数据持久化.以后有时间可以尝试下.","categories":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/categories/unity/"}],"tags":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/tags/unity/"},{"name":"unity换装","slug":"unity换装","permalink":"https://niaoyu00.github.io/Blog/tags/unity%E6%8D%A2%E8%A3%85/"}]},{"title":"UIToolKit开发arpg游戏","slug":"UIToolKit开发arpg游戏","date":"2022-11-19T03:34:07.000Z","updated":"2022-12-13T15:49:44.399Z","comments":true,"path":"2022/11/19/UIToolKit开发arpg游戏/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/11/19/UIToolKit%E5%BC%80%E5%8F%91arpg%E6%B8%B8%E6%88%8F/","excerpt":"","text":"目前的UI Toolkit比较适合做画面覆盖ui 暂时的缺陷如下: 教程来自b站: 阿严_独立游戏开发 本篇是笔记. 创建UIBuilder第一种,直接在window中创建 第二种资产文件夹下创建UI document 打开后就是一样的画面,并且带着根节点 按住ctrl+alt+左键可以移动窗口(可能鼠标中键也行,但是今天我忘了带鼠标) 画布设置 不过我们不使用这个功能,手动设定窗口宽高1920*1080. 制作画面画布已经创建好,现在开始做画面吧!效果图: 这方面就不细说了,类似安卓的前端页面,也类似web前端的操作方式,值得一提的是这里也有xml代码 创建uss(类似css) 红色框内去掉.,添加Label,选中Label即可对所有文本的样式进行编辑. 在游戏内显示场景内右键创建UIdocument,就会出现一个搭载ui Document脚本的对象 此处可以选展示的页面 空格显示&#x2F;隐藏画面新建脚本PartyDataScreen.cs附加到该对象上. getcomponent获取uidocument,然后获取rootVisualElement根视觉元素,根据根视觉元素的样式是否为flex,来展示&#x2F;隐藏画面. public class PartyDataScreen : MonoBehaviour&#123; VisualElement rootvisualElement;//根部视觉部分 private void Awake() &#123; rootvisualElement = GetComponent&lt;UIDocument&gt;().rootVisualElement; &#125; private void Update() &#123; if (Input.GetKeyDown(KeyCode.Space)) &#123; rootvisualElement.style.display = rootvisualElement.style.display == DisplayStyle.Flex ? DisplayStyle.None : DisplayStyle.Flex; &#125; &#125;&#125; 查找多个元素进行操作(批量操作) rtvElement.Query()函数可以对多个元素进行操作 public class PartyDataScreen : MonoBehaviour&#123; VisualElement rtvElement;//根部视觉部分 private void Awake() &#123; rtvElement = GetComponent&lt;UIDocument&gt;().rootVisualElement; rtvElement.Query(&quot;CharacterDataPanel&quot;).ForEach(OnSelectedMultipleElements); rtvElement.Query&lt;Label&gt;(&quot;NameLabel&quot;).ForEach(OnSelectLabelElements); &#125; private void OnSelectLabelElements(Label obj) &#123; obj.style.color = Color.red; obj.text = &quot;冒险家&quot;; &#125; private void OnSelectedMultipleElements(VisualElement obj) &#123;//设定背景色为黄色 obj.style.backgroundColor = Color.yellow; &#125;&#125; 查找单个元素首先查找到索引1的个体,然后再通过q()单项设置 public class PartyDataScreen : MonoBehaviour&#123; [SerializeField] Texture2D cat; [SerializeField] string catName; VisualElement rtvElement;//根部视觉部分 private void Awake() &#123; rtvElement = GetComponent&lt;UIDocument&gt;().rootVisualElement; var secondDataPanel = rtvElement.Query(&quot;CharacterDataPanel&quot;).AtIndex(1); secondDataPanel.Q&lt;Label&gt;().text = catName; secondDataPanel.Q(&quot;Avatar&quot;).style.backgroundImage = cat; &#125;&#125; 脚本中拖入图片素材,还有输入名字 运行结果 我们可以看到第二个框内部已更换为新的. 数据独立性为了以后更好地维护和管理数据,我们有必要设计一个专门的类存放并处理这些数据,这也是从数据独立性方面来考虑.将游戏的逻辑和数据分开. 思路:创建一个继承于ScriptableObject的角色数据类:CharacterData,再创建四个实例分别存储四个角色数据. 创建队伍数据类,管理角色数据 角色属性类创建白板,角色属性类CharacterStats.cs [System.Serializable]//可序列化public class CharacterStats&#123;//角色属性,暂时用int public int initiative;//主动权\\速度 public int maxHp;//血量 public int manMp;//魔法 public int attack;//攻击力 public int defense;//防御力&#125; 创建角色数据类创建角色数据类CharacterData.cs 详细可以看代码注释 using System.Collections;using System.Collections.Generic;using UnityEngine;[CreateAssetMenu(menuName = (&quot;Data/CharacterData&quot;), fileName = (&quot;CharacterData_&quot;))]public class CharacterData : ScriptableObject&#123; [SerializeField] Texture2D characterAvatarImage;//角色头像 [SerializeField] string characterName;//角色名 [SerializeField] int characterStartLevel = 1;//角色初始等级 [SerializeField] CharacterStats characterStats;//角色属性类 //公有属性,防止数据被修改 public Texture2D CharacterAvatarImage =&gt; characterAvatarImage; public string CharacterName =&gt; characterName; public int CharacterStartLevel1 =&gt; characterStartLevel; public CharacterStats ChStats =&gt; characterStats;&#125; 资源文件夹中创建CharacterData实例 所有角色实例 队伍数据类创建队伍数据类PartyData.cs using System.Collections;using System.Collections.Generic;using UnityEngine;/// &lt;summary&gt;/// 队伍数据类/// &lt;/summary&gt;[CreateAssetMenu(menuName = (&quot;Data/PartyData&quot;), fileName = (&quot;PartyData_&quot;))]public class PartyData : ScriptableObject&#123; [SerializeField] List&lt;CharacterData&gt; characterDataList; public List&lt;CharacterData&gt; CharacterDataList =&gt; characterDataList;&#125; 拖入角色实例,这样队伍里增加减少或角色更加方便. 这样,就可以通过序列化PartyData对象获取整个队伍的数据. CustomControls自定义控件 CustomControls是ui Toolkit的一个高级功能,我们可以通过c#脚本创建拥有自定义逻辑的复杂ui元素,自定义控件的创建从相应的c#类开始 实时生成角色数据面板创建CharacterDataPanel角色数据面板类 using UnityEngine.UIElements;public class CharacterDataPanel : VisualElement&#123;//继承VisualElement /// &lt;summary&gt; /// 使自定义控件曝露到uxml文件中,让它可以像其他默认UI元素一样,在UI Builder里使用. /// &lt;para&gt;|模板,不需要特地记&lt;/para&gt; /// &lt;/summary&gt; public new class UxmlFactory : UxmlFactory&lt;CharacterDataPanel&gt; &#123; &#125; //声明构造函数 public CharacterDataPanel() &#123; &#125;&#125; 保存后打开UI Builder,在下面project中可以找到该控件 给自定义控件添加内容使用UI Toolkit的Template模板功能. 创建模板 将模板存放到Assets\\Data\\UIDocuments\\Resources中,注意Resources文件夹创建的时候不可以有任何大小写拼写错误. 控件显示如下图 显示成这个样子是因为创建的控件自动多了一个容器 我们在存放目录这,右键从UIBuilder打开模板的uxml文件 重置basis属性,grow设为1 然后保存后回到主页面,将basis设为25% 全部替换掉,就得到了原来的样子 现在,我们有了数据面板的模板,那么接下来实现用c#脚本生成模板 代码生成模板打开CharacterDataPanel.cs using UnityEngine;using UnityEngine.UIElements;public class CharacterDataPanel : VisualElement&#123;//继承VisualElement readonly TemplateContainer templateContainer; /// &lt;summary&gt; /// 使自定义控件曝露到uxml文件中,让它可以像其他默认UI元素一样,在UI Builder里使用. /// &lt;para&gt;|模板,不需要特地记&lt;/para&gt; /// &lt;/summary&gt; public new class UxmlFactory : UxmlFactory&lt;CharacterDataPanel&gt; &#123; &#125; //声明构造函数 public CharacterDataPanel() &#123; //加载模板资产文件,这个模板是uxml文件,Instantiate:实例化ui templateContainer = Resources.Load&lt;VisualTreeAsset&gt;(&quot;CharacterDataPanel&quot;).Instantiate(); templateContainer.style.flexGrow = 1.0f;//设grow为1 hierarchy.Add(templateContainer);//添加到游戏操作界面 &#125;&#125;","categories":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/categories/unity/"}],"tags":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/tags/unity/"},{"name":"UIToolkit","slug":"UIToolkit","permalink":"https://niaoyu00.github.io/Blog/tags/UIToolkit/"},{"name":"arpg","slug":"arpg","permalink":"https://niaoyu00.github.io/Blog/tags/arpg/"}]},{"title":"unity脚本模板","slug":"unity脚本模板","date":"2022-11-18T10:23:52.000Z","updated":"2022-11-19T03:32:15.358Z","comments":true,"path":"2022/11/18/unity脚本模板/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/11/18/unity%E8%84%9A%E6%9C%AC%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"说明unity创建脚本时初始化的内容可以通过修改模板来diy。 下面是修改步骤: 查找模板文件位置在此获取引擎版本位置， 以我为例，到此目录下\\2021.3.4f1c1\\Editor\\Data\\Resources\\ScriptTemplates 打开81-C# Script-NewBehaviourScript.cs.txt,可以看到里面的内容就是我们创建脚本时生成的. 详细规则 参考阿严的模板创建 上文提到的操作都是基于现版本的编辑器进行的. 要将模板跟随项目一起的话,可以将四个文件复制到项目里Accest下新建的ScriptTemplates文件夹里. 也可以选中ScriptTemplates文件夹,导出成unityPackage.","categories":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/categories/unity/"}],"tags":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/tags/unity/"},{"name":"unity脚本模板","slug":"unity脚本模板","permalink":"https://niaoyu00.github.io/Blog/tags/unity%E8%84%9A%E6%9C%AC%E6%A8%A1%E6%9D%BF/"}]},{"title":"unity生命周期","slug":"unity生命周期","date":"2022-11-16T09:22:21.000Z","updated":"2022-11-16T09:47:58.700Z","comments":true,"path":"2022/11/16/unity生命周期/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/11/16/unity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"本文转载自csdnhttps://blog.csdn.net/xiaoyaoACi/article/details/119887467?spm=1001.2014.3001.5502 详细看原帖地址:https://blog.csdn.net/xiaoyaoACi/article/details/119324146?spm=1001.2014.3001.5502","categories":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/categories/unity/"}],"tags":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/tags/unity/"},{"name":"unity生命周期","slug":"unity生命周期","permalink":"https://niaoyu00.github.io/Blog/tags/unity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"name":"awake","slug":"awake","permalink":"https://niaoyu00.github.io/Blog/tags/awake/"}]},{"title":"二分查找和顺序查找","slug":"二分查找和顺序查找","date":"2022-11-13T04:41:14.000Z","updated":"2022-11-22T16:06:36.137Z","comments":true,"path":"2022/11/13/二分查找和顺序查找/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/11/13/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%92%8C%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE/","excerpt":"","text":"二分查找算法只能对有序排列数据进行高效查找。 方法定义下标：头l，尾r，中位数mid。 中位数对应元素与参数对比大小，若参数小于mid，则在左侧，将mid-1赋值给r，重定位r下标。 依次执行最终找到数据。 代码实现二分查找namespace AlgorithmTest13_二分查找&#123; class TestSearch &#123; public static int BinarySearch(int[] arr, int target) &#123; int l = 0; int r = arr.Length - 1; //int mit = (r + 1 )/ 2;中位数 int mit = l + (r - l) / 2;//中位数 while (l &lt;= r) &#123; //如果输入值小于中位数 if (target &lt; arr[mit]) &#123; r = mit - 1; &#125; else if (target &gt; arr[mit]) &#123; l = mit + 1; &#125; else &#123; return mit; &#125; &#125; return -1; &#125; &#125;&#125; 时间复杂度分析顺序查找法:最坏的时间复杂度。也就是对于未命中查找的情况，需要遍历所有的元素。 二分查找法:最坏的时间复杂度。也就是对于未命中查找的情况。每次比较都将数据规模缩小一半。 最坏情况(未命中查找)对于15个元素使用顺序查找最多进行了15次比较 对于15个元素使用二分查找最多进行了4次比较log2^15 &#x3D; 4 对于n个元素使用二分查找最多进行了log2 n次比较 因此顺序查找复杂度：O(n)，二分查找复杂度:O(log n) O(1) &lt; O(log n) &lt; O(n)","categories":[{"name":"基础学习","slug":"基础学习","permalink":"https://niaoyu00.github.io/Blog/categories/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Csharp","slug":"Csharp","permalink":"https://niaoyu00.github.io/Blog/tags/Csharp/"},{"name":"二分查找","slug":"二分查找","permalink":"https://niaoyu00.github.io/Blog/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"顺序查找","slug":"顺序查找","permalink":"https://niaoyu00.github.io/Blog/tags/%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://niaoyu00.github.io/Blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"集合和映射","slug":"集合和映射","date":"2022-11-10T10:26:11.000Z","updated":"2022-11-22T16:06:32.913Z","comments":true,"path":"2022/11/10/集合和映射/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/11/10/%E9%9B%86%E5%90%88%E5%92%8C%E6%98%A0%E5%B0%84/","excerpt":"","text":"集合 集合(set)作为存储数据容器时： 它不允许存储相同元素，只能保留一份。 能快速帮助我们进行去重操作，过滤掉重复元素。 典型应用 词汇量统计 统计一篇英文文章的总单词数，使用集合进行去重，判断英文文章难度。 创建集合接口新建Iset接口 namespace AlgorithmTest11_集合ISet&#123; interface Iset&lt;T&gt; &#123; /// &lt;summary&gt; /// 判空 /// &lt;/summary&gt; bool IsEmpty &#123; get; &#125; /// &lt;summary&gt; /// 元素个数 /// &lt;/summary&gt; int Count &#123; get; &#125; /// &lt;summary&gt; /// 添加 /// &lt;/summary&gt; /// &lt;param name=&quot;t&quot;&gt;&lt;/param&gt; void Add(T t); /// &lt;summary&gt; /// 删除 /// &lt;/summary&gt; /// &lt;param name=&quot;t&quot;&gt;&lt;/param&gt; void Remove(T t); /// &lt;summary&gt; /// 查询是否有某个元素 /// &lt;/summary&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; bool Contains(T e); &#125;&#125; 实现集合接口使用无序链表LinkedList1Set实现集合接口 using AlgorithmTest08_链表;namespace AlgorithmTest11_集合ISet&#123; /// &lt;summary&gt; /// 链表实现集合 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; public class LinkedList1Set&lt;T&gt; : Iset&lt;T&gt; &#123; /// &lt;summary&gt; /// 引用08链表的LinkedList1 /// &lt;/summary&gt; private LinkedList1&lt;T&gt; list; public LinkedList1Set() &#123; list = new LinkedList1&lt;T&gt;(); &#125; public bool IsEmpty &#123; get &#123; return list.IsEmpty; &#125; &#125; public int Count &#123; get &#123; return list.Count; &#125; &#125; public void Add(T t) &#123; //如果不包含该元素 if (!list.Contains(t)) &#123; list.AddFirst(t);//头部添加 &#125; &#125; public bool Contains(T t) &#123;//查询是否有某个元素 return list.Contains(t); &#125; public void Remove(T t) &#123;//根据值删除 list.Remove(t); &#125; &#125;&#125; 创建工具类创建TestHelper,用来将文件里文本存储到列表 using System;using System.Collections.Generic;using System.IO;namespace AlgorithmTest11_集合ISet&#123; class TestHelper &#123; //读取名为filename的文件,并将他分词,分词后存入list public static List&lt;string&gt; ReadFile(string filename) &#123; //使用FileStream类打开filename文件 FileStream fs = new FileStream(filename, FileMode.Open); //使用streamreader读取filename文件信息 StreamReader sr = new StreamReader(fs); //将读取的单词存入动态数组words中 List&lt;string&gt; words = new List&lt;string&gt;(); //分词操作,简陋的分词方式 //只要单词拼写不一样,就认为是不同单词,不考虑词性时态 while (!sr.EndOfStream)//如果没有督导filename末尾,就继续 &#123; //去除头部尾部空格,存在contents string contents = sr.ReadLine().Trim(); //寻找contents第一个字母的位置 int start = FirstCharacterIndex(contents, 0); //开始分词逻辑,将一个个的单词存储在数组words中 for (int i = start + 1; i &lt; contents.Length;) &#123; if (i == contents.Length || !Char.IsLetter(contents[i])) &#123; string word = contents.Substring(start, i - start).ToLower(); words.Add(word); start = FirstCharacterIndex(contents, i); i = start + 1; &#125; else i++; &#125; &#125; //关闭流对象释放资源 fs.Close(); sr.Close(); return words; &#125; //寻找字符串s中,从start的位置开始的第一个字母字符的位置. private static int FirstCharacterIndex(string s, int start) &#123; for (int i = start; i &lt; s.Length; i++) &#123; if (Char.IsLetter(s[i])) &#123; return i;//返回位置 &#125; &#125; return s.Length; &#125; &#125;&#125; 添加文档,修改文档属性 测试结果using System;using System.Collections.Generic;using System.Diagnostics;namespace AlgorithmTest11_集合ISet&#123; class Program &#123; static void Main(string[] args) &#123; #region 集合 Stopwatch t = new Stopwatch(); Console.WriteLine(&quot;双城记&quot;); List&lt;string&gt; words = TestHelper.ReadFile(&quot;txt/A Tale Of Two Cities.txt&quot;); Console.WriteLine(&quot;总单词数:&quot; + words.Count); //去重 LinkedList1Set&lt;string&gt; linkedset = new LinkedList1Set&lt;string&gt;(); t.Start(); foreach (var item in words) &#123; linkedset.Add(item); &#125; t.Stop(); Console.WriteLine(&quot;去重后:&quot; + linkedset.Count); Console.WriteLine(&quot;执行时长,&quot; + t.ElapsedMilliseconds + &quot;ms&quot;); #endregion Console.ReadKey(); &#125; &#125;&#125; 用时接近六秒,可以看出顺序查找非常耗时 映射&#x2F;字典定义接口创建IDictionary&lt;Key, Value&gt;,定义接口 namespace AlgorithmTest12_映射or字典IDictionary&#123; interface IDictionary&lt;Key, Value&gt; &#123; /// &lt;summary&gt; /// 添加 /// &lt;/summary&gt; /// &lt;param name=&quot;key&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;value&quot;&gt;&lt;/param&gt; void Add(Key key, Value value); /// &lt;summary&gt; /// 通过键删除 /// &lt;/summary&gt; /// &lt;param name=&quot;key&quot;&gt;&lt;/param&gt; void Remove(Key key); /// &lt;summary&gt; /// 查看是否有这个键 /// &lt;/summary&gt; /// &lt;param name=&quot;key&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; bool ContainsKey(Key key); /// &lt;summary&gt; /// 通过键获取值 /// &lt;/summary&gt; /// &lt;param name=&quot;key&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; Value Get(Key key); /// &lt;summary&gt; /// 修改键对应的值 /// &lt;/summary&gt; /// &lt;param name=&quot;key&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;newValue&quot;&gt;&lt;/param&gt; void Set(Key key, Value newValue); /// &lt;summary&gt; /// 元素个数 /// &lt;/summary&gt; int Count &#123; get; &#125; /// &lt;summary&gt; /// 判空 /// &lt;/summary&gt; bool IsEmpty &#123; get; &#125; &#125;&#125; 实现接口功能新建字典专用链表新建带两个泛型参数的链表 using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace AlgorithmTest12_映射or字典IDictionary&#123; class LinkedList3&lt;Key, Value&gt; &#123; private class Node &#123; public Key key; public Value value; public Node next; public Node(Key key, Value value, Node next) &#123; this.key = key; this.value = value; this.next = next; &#125; public override string ToString() &#123; return key.ToString() + &quot;:&quot; + value.ToString(); &#125; &#125; private Node head; private int N; public LinkedList3() &#123; head = null; N = 0; &#125; public int Count &#123; get &#123; return N; &#125; &#125; public bool IsEmpty &#123; get &#123; return N == 0; &#125; &#125; //返回key所在节点 private Node GetNode(Key key) &#123; Node cur = head;//从头查找 while (cur != null) &#123; //如果键在链表中 if (cur.key.Equals(key)) &#123; return cur; &#125; cur = cur.next; &#125; return null; &#125; /// &lt;summary&gt; /// 添加 /// &lt;/summary&gt; /// &lt;param name=&quot;key&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;value&quot;&gt;&lt;/param&gt; public void Add(Key key, Value value) &#123; Node node = GetNode(key); if (node == null) &#123;//如果为空,则新增加节点 head = new Node(key, value, head); N++; &#125; else &#123;//如果不为空则覆盖内容 node.value = value; &#125; &#125; /// &lt;summary&gt; /// 查询key是否在链表中 /// &lt;/summary&gt; /// &lt;param name=&quot;key&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public bool Contains(Key key) &#123; //不为空说明能找到对应值 return GetNode(key) != null; &#125; /// &lt;summary&gt; /// 通过key获取值 /// &lt;/summary&gt; /// &lt;param name=&quot;key&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public Value Get(Key key) &#123; Node node = GetNode(key); if (node == null) &#123; throw new ArgumentException(&quot;键&quot; + key + &quot;不存在&quot;); &#125; else &#123; return node.value; &#125; &#125; /// &lt;summary&gt; /// 修改键对应的值 /// &lt;/summary&gt; /// &lt;param name=&quot;key&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;newValue&quot;&gt;&lt;/param&gt; public void Set(Key key, Value newValue) &#123; Node node = GetNode(key); if (node == null) &#123; throw new ArgumentException(&quot;键&quot; + key + &quot;不存在&quot;); &#125; else &#123; node.value = newValue; &#125; &#125; /// &lt;summary&gt; /// 根据值删除 /// &lt;/summary&gt; /// &lt;param name=&quot;key&quot;&gt;&lt;/param&gt; public void Remove(Key key) &#123; if (head == null) &#123;//如果链表为空则弹出 return; &#125; if (head.key.Equals(key)) &#123;//删除的值为头部 head = head.next; N--; &#125; else &#123; Node cur = head; Node pre = null; while (cur != null) &#123; if (cur.t.Equals(key)) &#123; break; &#125; pre = cur;//第一轮pre移动到head,第二轮pre右移 cur = cur.next;//第一轮cur右移,第二轮cur右移 //直到查询到相同内容,弹出.或者cur为null(查到底了) &#125; if (cur != null) &#123;//删除操作,跳过cur pre.next = pre.next.next; N--; &#125; &#125; &#125; &#125;&#125; 实现字典类新建字典类,通过链表实现字典功能 namespace AlgorithmTest12_映射or字典IDictionary&#123; class LinkedList3Dictionary&lt;Key, Value&gt; : IDictionary&lt;Key, Value&gt; &#123; private LinkedList3&lt;Key, Value&gt; list; public LinkedList3Dictionary() &#123; list = new LinkedList3&lt;Key, Value&gt;(); &#125; public int Count &#123; get &#123; return list.Count; &#125; &#125; public bool IsEmpty &#123; get &#123; return list.IsEmpty; &#125; &#125; public void Add(Key key, Value value) &#123; list.Add(key, value); &#125; public bool ContainsKey(Key key) &#123; return list.Contains(key); &#125; public Value Get(Key key) &#123; return list.Get(key); &#125; public void Remove(Key key) &#123; list.Remove(key); &#125; public void Set(Key key, Value newValue) &#123; list.Set(key, newValue); &#125; &#125;&#125; 运行调试using System;using System.Collections.Generic;using System.Diagnostics;namespace AlgorithmTest12_映射or字典IDictionary&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(&quot;字典双城记&quot;); List&lt;string&gt; words = TestHelper.ReadFile(&quot;txt/A Tale Of Two Cities.txt&quot;); Console.WriteLine(&quot;总单词数:&quot; + words.Count); Stopwatch t = new Stopwatch(); //key为单词,值为频率 LinkedList3Dictionary&lt;string, int&gt; dic = new LinkedList3Dictionary&lt;string, int&gt;(); t.Start(); foreach (var key in words) &#123; //key不在字典中 说明是第一次遇到此单词 if (!dic.ContainsKey(key)) &#123; dic.Add(key, 1);//频率为1 &#125; //否则让它加一 else &#123; //修改dic对应key的值,自增1 dic.Set(key, dic.Get(key) + 1); &#125; &#125; t.Stop(); Console.WriteLine(&quot;不同的单词总数: &quot; + dic.Count); Console.WriteLine(&quot;city出现次数: &quot; + dic.Get(&quot;city&quot;)); Console.WriteLine(&quot;运行时长: &quot; + t.ElapsedMilliseconds + &quot;ms&quot;); Console.ReadKey(); &#125; &#125;&#125; 总结可以看出查找用时非常久,这是因为Set和Get每次都调用GetNode循环遍历节点,复杂度n。","categories":[{"name":"基础学习","slug":"基础学习","permalink":"https://niaoyu00.github.io/Blog/categories/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Csharp","slug":"Csharp","permalink":"https://niaoyu00.github.io/Blog/tags/Csharp/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://niaoyu00.github.io/Blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"集合","slug":"集合","permalink":"https://niaoyu00.github.io/Blog/tags/%E9%9B%86%E5%90%88/"},{"name":"映射","slug":"映射","permalink":"https://niaoyu00.github.io/Blog/tags/%E6%98%A0%E5%B0%84/"}]},{"title":"将手机设为电脑麦克风","slug":"将手机设为电脑麦克风","date":"2022-11-10T07:37:07.000Z","updated":"2022-11-10T07:46:52.879Z","comments":true,"path":"2022/11/10/将手机设为电脑麦克风/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/11/10/%E5%B0%86%E6%89%8B%E6%9C%BA%E8%AE%BE%E4%B8%BA%E7%94%B5%E8%84%91%E9%BA%A6%E5%85%8B%E9%A3%8E/","excerpt":"","text":"软件官网https://wolicheng.com/womic/ 点download下载,分别下载app和pc客户端 我是iphone所以直接appstore搜索WO Mic,下载完后直接点start app会提供ip地址 pc客户端下载后打开连接,输入对应ip地址即可连上。 还可以使用蓝牙、usb等连接方式，移动端调音量好像需要会员，不过目前勉强够用。","categories":[{"name":"其他","slug":"其他","permalink":"https://niaoyu00.github.io/Blog/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"麦克风","slug":"麦克风","permalink":"https://niaoyu00.github.io/Blog/tags/%E9%BA%A6%E5%85%8B%E9%A3%8E/"}]},{"title":"数据结构-队列","slug":"数据结构-队列","date":"2022-11-05T11:19:01.000Z","updated":"2022-11-22T16:06:28.270Z","comments":true,"path":"2022/11/05/数据结构-队列/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/11/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/","excerpt":"","text":"队列(Queue)数组实现队列队列相关操作 void Enqueue(T t);&#x2F;&#x2F;入队 T Dequeue();&#x2F;&#x2F;出队 T Peek();&#x2F;&#x2F;查看队首元素 int Count { get; }&#x2F;&#x2F;查看元素个数 bool IsEmpty { get; }&#x2F;&#x2F;查看队列是否为空 创建接口创建接口IQueue namespace AlgorithmTest10_队列Queue&#123; interface IQueue&lt;T&gt; &#123; void Enqueue(T t);//入队 T Dequeue();//出队 T Peek();//查看队首元素 int Count &#123; get; &#125;//查看元素个数 bool IsEmpty &#123; get; &#125;//查看队列是否为空 &#125;&#125; 实现接口功能新建**Array1Queue类,实现IQueue**接口功能 using AlgorithmTest06_List;namespace AlgorithmTest10_队列Queue&#123; class Array1Queue&lt;T&gt; : IQueue&lt;T&gt; &#123; private SeqList&lt;T&gt; arr;//引用06中的动态数组 /// &lt;summary&gt; /// capacity:容量 /// &lt;/summary&gt; /// &lt;param name=&quot;capacity&quot;&gt;&lt;/param&gt; public Array1Queue(int capacity) &#123; arr = new SeqList&lt;T&gt;(capacity);//数组开辟空间 &#125; /// &lt;summary&gt; /// 默认容量:10 /// &lt;/summary&gt; public Array1Queue() &#123; arr = new SeqList&lt;T&gt;();//数组开辟空间 &#125; /// &lt;summary&gt; /// 查询元素个数 /// &lt;/summary&gt; public int Count &#123; get &#123; return arr.GetCount(); &#125; &#125; /// &lt;summary&gt; /// 判空 /// &lt;/summary&gt; public bool IsEmpty &#123; get &#123; return arr.IsEmpty(); &#125; &#125; /// &lt;summary&gt; /// 出队 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public T Dequeue() &#123; return arr.Delete(0); &#125; /// &lt;summary&gt; /// 入队 /// &lt;/summary&gt; /// &lt;param name=&quot;t&quot;&gt;&lt;/param&gt; public void Enqueue(T t) &#123; arr.AddLast(t);//末尾入队 &#125; /// &lt;summary&gt; /// 查询队首 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public T Peek() &#123; return arr.GetElem(0); &#125; public override string ToString() &#123; return &quot;Queue: front &quot; + arr.ToString(); &#125; &#125;&#125; 效果展示using System;namespace AlgorithmTest10_队列Queue&#123; class Program &#123; static void Main(string[] args) &#123; Array1Queue&lt;int&gt; que = new Array1Queue&lt;int&gt;(); Console.WriteLine(&quot;队列是否为空:&quot; + que.IsEmpty); for (int i = 0; i &lt; 5; i++) &#123; que.Enqueue(i); Console.WriteLine(que); &#125; Console.WriteLine(&quot;删除&quot; + que.Dequeue()); Console.WriteLine(&quot;队首&quot; + que.Peek()); Console.WriteLine(&quot;队列是否为空:&quot; + que.IsEmpty); Console.ReadKey(); &#125; &#125;&#125; 时间复杂度 可以看到按以上方法实现的出队时间复杂度为O(n) 所以我们需要循环队列优化复杂度 循环队列新建类**Array2**实现循环数组 实现循环数组using System;using System.Text;namespace AlgorithmTest10_队列Queue&#123; class Array2&lt;T&gt; &#123; private T[] data; private int first; private int last; private int count; public Array2(int capacity) &#123; data = new T[capacity];//数组预设空间 first = 0; last = 0; count = 0; &#125; public Array2() : this(10) &#123; &#125; /// &lt;summary&gt; /// 成员数量 /// &lt;/summary&gt; public int GetCount &#123; get &#123; return count; &#125; &#125; /// &lt;summary&gt; /// 判空, /// &lt;/summary&gt; public bool IsEmpty &#123; get &#123; return count == 0; &#125; &#125; /// &lt;summary&gt; /// 数组末尾添加 /// &lt;/summary&gt; /// &lt;param name=&quot;t&quot;&gt;&lt;/param&gt; public void AddLast(T t) &#123; //如果元素数量与数组长度相等,则扩容 if (count == data.Length) &#123; RestCapacity(2 * data.Length); &#125; data[last] = t; last = (last + 1) % data.Length; //如果last小于数组元素长度,则返回结果为last+1本身 //如果last等于data.Length,则返回0 count++; &#125; /// &lt;summary&gt; /// 删除数组头部 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public T RemoveFirst() &#123; if (IsEmpty) &#123; throw new InvalidOperationException(&quot;不能数组为空!&quot;); &#125; T ret = data[first];//存储要删除的值用来返回显示 data[first] = default(T);//设置为default ,c#会回收 first = (first + 1) % data.Length; //如果first小于数组元素长度,则返回结果为first+1本身 //如果first等于data.Length,则返回0 count--; //如果元素个数为空间的四分之一,则缩容一半 if (count == data.Length / 4) &#123; RestCapacity(data.Length / 2); &#125; return ret; &#125; /// &lt;summary&gt; /// 查询数组头部内容 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public T GetFirst() &#123; if (IsEmpty) &#123; throw new InvalidOperationException(&quot;不能数组为空!&quot;); &#125; return data[first]; &#125; /// &lt;summary&gt; /// 扩容循环数组 /// &lt;/summary&gt; private void RestCapacity(int newCap) &#123; T[] newData = new T[newCap]; //旧数组赋值到新数组头部 for (int i = 0; i &lt; count; i++) &#123; //newData[0]=data[first] newData[i] = data[(first + i) % data.Length]; &#125; data = newData; first = 0; last = count; &#125; public override string ToString() &#123; StringBuilder res = new StringBuilder(); for (int i = 0; i &lt; count - 1; i++) &#123; res.Append(data[(first + i) % data.Length] + &quot;,&quot;); &#125; //最后一位单独打印,因为末尾不需要逗号 res.Append(data[(first + count - 1) % data.Length]); return res.ToString(); &#125; &#125;&#125; 循环数组扩容新建一个newData[],容量更大,将旧data[]数组中的first下标移到newData[0]完成扩容。 private void RestCapacity(int newCap)&#123; T[] newData = new T[newCap]; //旧数组赋值到新数组头部 for (int i = 0; i &lt; count; i++) &#123; //newData[0]=data[first] newData[i] = data[(first + i) % data.Length]; &#125; data = newData; first = 0; last = count;&#125; 重写ToString()public override string ToString()&#123; StringBuilder res = new StringBuilder(); for (int i = 0; i &lt; count - 1; i++) &#123; res.Append(data[(first + i) % data.Length] + &quot;,&quot;); &#125; //最后一位单独打印,因为末尾不需要逗号 res.Append(data[(first + count - 1) % data.Length]); return res.ToString();&#125; 实现接口功能创建Array2Queue namespace AlgorithmTest10_队列Queue&#123; class Array2Queue&lt;T&gt; : IQueue&lt;T&gt; &#123; private Array2&lt;T&gt; arr; /// &lt;summary&gt; /// capacity:容量 /// &lt;/summary&gt; /// &lt;param name=&quot;capacity&quot;&gt;&lt;/param&gt; public Array2Queue(int capacity) &#123; arr = new Array2&lt;T&gt;(capacity);//数组开辟空间 &#125; /// &lt;summary&gt; /// 默认容量:10 /// &lt;/summary&gt; public Array2Queue() &#123; arr = new Array2&lt;T&gt;();//数组开辟空间 &#125; /// &lt;summary&gt; /// 查询元素个数 /// &lt;/summary&gt; public int Count &#123; get &#123; return arr.GetCount; &#125; &#125; /// &lt;summary&gt; /// 判空 /// &lt;/summary&gt; public bool IsEmpty &#123; get &#123; return arr.IsEmpty; &#125; &#125; /// &lt;summary&gt; /// 出队 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public T Dequeue() &#123; return arr.RemoveFirst(); &#125; /// &lt;summary&gt; /// 入队 /// &lt;/summary&gt; /// &lt;param name=&quot;t&quot;&gt;&lt;/param&gt; public void Enqueue(T t) &#123; arr.AddLast(t);//末尾入队 &#125; /// &lt;summary&gt; /// 查询队首 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public T Peek() &#123; return arr.GetFirst(); &#125; public override string ToString() &#123; return &quot;Queue: front &quot; + arr.ToString(); &#125; &#125;&#125; 效果展示using System;namespace AlgorithmTest10_队列Queue&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(&quot;=====使用循环数组=====&quot;); Array2Queue&lt;int&gt; que2 = new Array2Queue&lt;int&gt;(); Console.WriteLine(&quot;队列是否为空:&quot; + que2.IsEmpty); for (int i = 0; i &lt; 5; i++) &#123; que2.Enqueue(i); Console.WriteLine(que2); &#125; Console.WriteLine(&quot;删除&quot; + que2.Dequeue()); Console.WriteLine(&quot;队首&quot; + que2.Peek()); Console.WriteLine(&quot;队列是否为空:&quot; + que2.IsEmpty); Console.ReadKey(); &#125; &#125;&#125; 数组队列、循环队列性能对比Program.cs中创建方法TextQueue,并运行测试diamagnetic public static long TextQueue(IQueue&lt;int&gt; que, int N) &#123; Stopwatch t = new Stopwatch(); t.Start(); for (int i = 0; i &lt; N; i++) &#123; que.Enqueue(i); &#125; for (int i = 0; i &lt; N; i++) &#123; que.Dequeue(); &#125; t.Stop(); return t.ElapsedMilliseconds; &#125; static void Main(string[] args) &#123;#region 数组队列和循环队列性能对比 Console.WriteLine(&quot;=====数组队列和循环队列性能对比=====&quot;); int N = 50000; //O(n^2)复杂度 Array1Queue&lt;int&gt; arr1 = new Array1Queue&lt;int&gt;(); long t1 = TextQueue(arr1, N); Console.WriteLine(&quot;array1queue&#x27;time:&quot; + t1 + &quot;ms&quot;); //O(n)复杂度 Array2Queue&lt;int&gt; arr2 = new Array2Queue&lt;int&gt;(); long t2 = TextQueue(arr2, N); Console.WriteLine(&quot;array2queue&#x27;time:&quot; + t2 + &quot;ms&quot;);#endregion Console.ReadKey(); &#125; 测试结果 加上系统自带的Queue对比测试 Queue&lt;int&gt; que3 = new Queue&lt;int&gt;();Stopwatch t = new Stopwatch();t.Start();for (int i = 0; i &lt; N; i++)&#123; que3.Enqueue(i);&#125;for (int i = 0; i &lt; N; i++)&#123; que3.Dequeue();&#125;t.Stop();Console.WriteLine(&quot;Queue&#x27;time:&quot; + t.ElapsedMilliseconds + &quot;ms&quot;); 结论O(n)和O(n^2)复杂度执行效率天差地别,样本越多相差会越大 链表实现队列新建类LinkedList1Queue 继承接口 IQueue 实现单头链表队列引用链表,实现接口功能LinkedList1Queueusing AlgorithmTest08_链表;namespace AlgorithmTest10_队列Queue&#123; /// &lt;summary&gt; /// 链表队列 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; class LinkedList1Queue&lt;T&gt; : IQueue&lt;T&gt; &#123; /// &lt;summary&gt; /// 引用链表 /// &lt;/summary&gt; private LinkedList1&lt;T&gt; list; public LinkedList1Queue() &#123; list = new LinkedList1&lt;T&gt;(); &#125; public int Count &#123; get &#123; return list.Count; &#125; &#125; public bool IsEmpty &#123; get &#123; return list.IsEmpty; &#125; &#125; public T Dequeue() &#123; return list.RemoveFirst(); &#125; public void Enqueue(T t) &#123; list.AddLast(t); &#125; public T Peek() &#123; return list.GetFirst(); &#125; public override string ToString() &#123; return &quot;Queue front &quot; + list.ToString() + &quot; tail&quot;; &#125; &#125;&#125; 复杂度分析 可以看出链表队列添加元素时复杂度O(n)过高,因为在尾部添加元素需要先遍历一遍元素。 优化链表队列 新加一个尾指针tail，单独用来实现尾部添加操作。 实现有头尾链表队列新建链表AlgorithmTest08_链表中新建**LinkedList2**类，只写队列相关操作 using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace AlgorithmTest08_链表&#123; class LinkedList2&lt;T&gt; &#123; private class Node &#123; public T t; public Node next; public Node(T t, Node next) &#123; this.t = t; this.next = next; &#125; public Node(T t) &#123; this.t = t; this.next = null; &#125; public override string ToString() &#123; return t.ToString(); &#125; &#125; /// &lt;summary&gt; /// 链表头 /// &lt;/summary&gt; private Node head; /// &lt;summary&gt; /// 链表尾 /// &lt;/summary&gt; private Node tail; /// &lt;summary&gt; /// 链表中存储了多少元素 /// &lt;/summary&gt; private int N; public LinkedList2() &#123; head = null; tail = null; N = 0; &#125; public int Count &#123; get &#123; return N; &#125; &#125; public bool IsEmpty &#123; get &#123; return N == 0; &#125; &#125; public void AddLast(T t) &#123; Node node = new Node(t); if (IsEmpty) &#123; head = node; tail = node; &#125; else &#123; //设置node在尾节点的右边 tail.next = node; tail = node; &#125; N++; &#125; public T RemoveFirst() &#123; if (IsEmpty) &#123; throw new InvalidProgramException(&quot;链表为空&quot;); &#125; T t = head.t;//存储要删除的数据 head = head.next;//头部指向下一个节点(删除) N--; if (head == null) &#123;//如果删除过后链表为空 tail = null;//尾部设置也为空 &#125; return t; &#125; public T GetFirst() &#123; if (IsEmpty) &#123; throw new InvalidProgramException(&quot;链表为空&quot;); &#125; return head.t; &#125; public override string ToString() &#123; StringBuilder res = new StringBuilder(); Node cur = head; while (cur != null) &#123; res.Append(cur + &quot;-&gt;&quot;); cur = cur.next; &#125; res.Append(&quot;null&quot;); return res.ToString(); &#125; &#125;&#125; 引用链表,实现接口LinkedList2QueueAlgorithmTest10_队列Queue中创建LinkedList2Queue实现接口IQueue(其实和LinkedList1Queue代码一样) using AlgorithmTest08_链表;namespace AlgorithmTest10_队列Queue&#123; class LinkedList2Queue&lt;T&gt; : IQueue&lt;T&gt; &#123; /// &lt;summary&gt; /// 引用链表 /// &lt;/summary&gt; private LinkedList2&lt;T&gt; list; public LinkedList2Queue() &#123; list = new LinkedList2&lt;T&gt;(); &#125; public int Count &#123; get &#123; return list.Count; &#125; &#125; public bool IsEmpty &#123; get &#123; return list.IsEmpty; &#125; &#125; public T Dequeue() &#123; return list.RemoveFirst(); &#125; public void Enqueue(T t) &#123; list.AddLast(t); &#125; public T Peek() &#123; return list.GetFirst(); &#125; public override string ToString() &#123; return &quot;Queue front &quot; + list.ToString() + &quot; tail&quot;; &#125; &#125;&#125; 单头链表队列和有尾的链表队列性能对比#region 单头链表队列和有尾的链表队列性能对比Console.WriteLine(&quot;=====单头链表队列和有尾的链表队列性能对比=====&quot;);//O(n)复杂度LinkedList1Queue&lt;int&gt; lk1 = new LinkedList1Queue&lt;int&gt;();long tt1 = TextQueue(lk1, N);Console.WriteLine(&quot;linkedlist1queue &#x27;time &quot; + tt1 + &quot;ms&quot;);//O(1)复杂度LinkedList2Queue&lt;int&gt; lk2 = new LinkedList2Queue&lt;int&gt;();long tt2 = TextQueue(lk2, N);Console.WriteLine(&quot;linkedlist2queue &#x27;time &quot; + tt2 + &quot;ms&quot;);#endregion","categories":[{"name":"基础学习","slug":"基础学习","permalink":"https://niaoyu00.github.io/Blog/categories/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Csharp","slug":"Csharp","permalink":"https://niaoyu00.github.io/Blog/tags/Csharp/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://niaoyu00.github.io/Blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"队列","slug":"队列","permalink":"https://niaoyu00.github.io/Blog/tags/%E9%98%9F%E5%88%97/"}]},{"title":"三种栈性能对比","slug":"三种栈性能对比","date":"2022-11-01T07:53:10.000Z","updated":"2022-11-07T06:32:14.534Z","comments":true,"path":"2022/11/01/三种栈性能对比/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/11/01/%E4%B8%89%E7%A7%8D%E6%A0%88%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/","excerpt":"","text":"数组栈、链表栈以及c#系统提供的Stack性能比对代码如下using System;using System.Collections.Generic;using System.Diagnostics;namespace AlgorithmTest09_实现栈Stack&#123; class Program &#123; public static long TextStack(IStack&lt;int&gt; stack, int N) &#123; Stopwatch t = new Stopwatch(); t.Start(); for (int i = 0; i &lt; N; i++) &#123; stack.Push(i); &#125; for (int i = 0; i &lt; N; i++) &#123; stack.Pop(); &#125; t.Stop(); return t.ElapsedMilliseconds; &#125; static void Main(string[] args) &#123; #region 测试性能 //数组栈 int N = 10000000; Array1Stack&lt;int&gt; array1Stack = new Array1Stack&lt;int&gt;(N); long t1 = TextStack(array1Stack, N); Console.WriteLine(&quot;array1Stack&#x27;Time:&#123;0&#125;ms&quot;, t1); //链表栈 LinkedList1Stack&lt;int&gt; linked = new LinkedList1Stack&lt;int&gt;(); long t2 = TextStack(linked, N); Console.WriteLine(&quot;linked&#x27;Time:&#123;0&#125;ms&quot;, t2); //c#自带的stack Stack&lt;int&gt; stack = new Stack&lt;int&gt;(); Stopwatch t3 = new Stopwatch(); t3.Start(); for (int i = 0; i &lt; N; i++) &#123; stack.Push(i); &#125; for (int i = 0; i &lt; N; i++) &#123; stack.Pop(); &#125; t3.Stop(); Console.WriteLine(&quot;stack&#x27;Time:&#123;0&#125;ms&quot;, t3.ElapsedMilliseconds); #endregion Console.ReadKey(); &#125; &#125;&#125; 打印结果 可以看出系统自带的Stack性能最优 链表实现的栈性能最差,因为链表需要对节点和下一节点操作,更吃性能","categories":[{"name":"基础学习","slug":"基础学习","permalink":"https://niaoyu00.github.io/Blog/categories/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://niaoyu00.github.io/Blog/tags/%E6%A0%88/"},{"name":"数据结构","slug":"数据结构","permalink":"https://niaoyu00.github.io/Blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"搜索引擎技巧【转载】","slug":"搜索引擎技巧","date":"2022-10-31T05:24:09.000Z","updated":"2022-11-02T07:28:55.376Z","comments":true,"path":"2022/10/31/搜索引擎技巧/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/10/31/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%8A%80%E5%B7%A7/","excerpt":"","text":"转自码农家园:https://www.codenong.com/cs105540904/ 「关键字」+「空格」+「减号」+「关键字」 如果你想去掉一些你不想看的搜索结果(例如广告、推广)，那么你就可以使用这种搜索方式。 「关键字」+「空格」+「filetype:」+「doc&#x2F;ppt&#x2F;pdf等文件格式」 filetype可以用于搜索特定的文件格式,运用这个搜索方法你可以轻松搜索到各种格式的资料文件,搜索引擎是支持这个搜索方法的。 「关键字」+「空格」+「Ifiletype:」+「doc&#x2F;ppt等文格式」+「空格」+「2017…2019」 如果这样输入,还能找到限定时间里包含关键字的文件资料哦。 「”」+「关键字」+「”」 运用这技巧可以做到关键字全匹配的搜索,简单来说就是搜索出来的结果包含双引号内的所有关键字且顺序也是完全匹配的。 「关键字」+「空格」+「inurl」+「关键字&#x2F;网址」 这个技巧用于搜索关键字出现在特定网址的页面,关键字可以是中文、英文或者网址。 「快速计算」 这个是搜索引擎的一个小应用,但它却很方便实用,我们可以直接在搜索引擎里输入计算公式即可直接得到计算结果,不需要很麻烦的去找计算机内置的计算器。","categories":[{"name":"其他","slug":"其他","permalink":"https://niaoyu00.github.io/Blog/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"搜索技巧","slug":"搜索技巧","permalink":"https://niaoyu00.github.io/Blog/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/"}]},{"title":"使用阿里云oss搭建图床","slug":"使用阿里云oss搭建图床","date":"2022-10-25T05:14:26.000Z","updated":"2022-10-25T06:13:49.299Z","comments":true,"path":"2022/10/25/使用阿里云oss搭建图床/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/10/25/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91oss%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/","excerpt":"","text":"最近发现墙变厚了,不开飞机放在github的图加载实在慢,于是我去了解了下云存储。 花了45买了五年的阿里云oss，在此记录下。 开通点此:对象存储OSS创建用户:网页右上角 名称随便取,这里要勾上 进行一下验证创建完之后一定要复制这俩key,只有创建时会显示,错过忘了得重新生成 回到用户界面,添加用户权限 搜索oss,确认 回到对象存储控制台,创建bucket地域选附近的,读写权限选公读,其他选项全部默认. bucket中授权用户进入文件管理 选择子账号,选择读&#x2F;写,确认 picgo软件配置看提示填就行 配置完成","categories":[{"name":"其他","slug":"其他","permalink":"https://niaoyu00.github.io/Blog/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"阿里云","slug":"阿里云","permalink":"https://niaoyu00.github.io/Blog/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"图床","slug":"图床","permalink":"https://niaoyu00.github.io/Blog/tags/%E5%9B%BE%E5%BA%8A/"}]},{"title":"时间复杂度分析","slug":"时间复杂度分析","date":"2022-10-24T07:57:17.000Z","updated":"2022-10-24T09:34:26.406Z","comments":true,"path":"2022/10/24/时间复杂度分析/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/10/24/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/","excerpt":"","text":"影响程序运行的总时间主要和两点有关 执行每条语句的耗时 执行每条语句的频率 前者主要取决于计算机性能、编译器、操作系统； 后者主要取决于程序本身和输入。 大O表示法：描述算法的运行时间和数据结构规模的关系O(1) O(n) O(log n) O(n log n) O(n^2) 例子：数组末尾添加，四条语句执行时间，O(1) /// &lt;summary&gt; /// index的位置插入item值 /// &lt;/summary&gt; /// &lt;param name=&quot;index&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;item&quot;&gt;&lt;/param&gt;public void Insert(int index, T item) &#123;//插入 if (index &lt; 0 || index &gt; count)//----------------1 &#123; throw new ArgumentException(&quot;数组索引越界&quot;); &#125; if (count == data.Length)//----------------------1 &#123; //throw new ArgumentException(&quot;数组已满&quot;); ResetCapacity(2 * data.Length);//数组扩容加原来两倍 &#125; for (int i = count - 1; i &gt;= index; i--)//-------不成立 &#123; data[i + 1] = data[i]; &#125; data[index] = item;//----------------------------1 count++;//---------------------------------------1 &#125; /// &lt;summary&gt; /// 末尾添加，count:元素个数 /// &lt;/summary&gt; /// &lt;param name=&quot;item&quot;&gt;&lt;/param&gt; public void AddLast(T item) &#123; Insert(count, item); &#125; 数组头部添加,4+n条语句执行,O(n) /// &lt;summary&gt; /// index的位置插入item值 /// &lt;/summary&gt; /// &lt;param name=&quot;index&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;item&quot;&gt;&lt;/param&gt;public void Insert(int index, T item) &#123;//插入 if (index &lt; 0 || index &gt; count)//----------------1 &#123; throw new ArgumentException(&quot;数组索引越界&quot;); &#125; if (count == data.Length)//----------------------1 &#123; //throw new ArgumentException(&quot;数组已满&quot;); ResetCapacity(2 * data.Length);//数组扩容加原来两倍 &#125; for (int i = count - 1; i &gt;= index; i--)//-------n &#123; data[i + 1] = data[i]; &#125; data[index] = item;//----------------------------1 count++;//---------------------------------------1 &#125; /// &lt;summary&gt; /// 头部添加 /// &lt;/summary&gt; /// &lt;param name=&quot;item&quot;&gt;&lt;/param&gt; public void AddFirst(T item) &#123; Insert(0, item); &#125; 数组根据值找索引 O(1)或者O(n)/// &lt;summary&gt;/// 根据值找索引/// &lt;/summary&gt;/// &lt;param name=&quot;value&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public int IndexOf(T value)&#123; for (int i = 0; i &lt; count; i++) &#123; if (data[i].Equals(value))//不能用==,因为都是值类型,不合法 &#123;//确定指定的对象是否等于当前对象。 return i; &#125; &#125; return -1;//值不存在&#125; 元素存在数组中 元素在数组头部找到:O(1) 元素在数组尾部找到:O(n) 平均在数组中间找到:O(2&#x2F;n)&#x3D;O(n) 元素不在数组中:O(n) 数组末尾删除,O(1) /// &lt;summary&gt; /// 删除index位置的值 /// &lt;/summary&gt; /// &lt;param name=&quot;index&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt;public T Delete(int index) &#123; if (count == data.Length / 4)//不足四分之一时,空间减少------1 &#123; ResetCapacity(data.Length / 2); &#125; if (index &lt; 0 || index &gt;= count) &#123; throw new ArgumentException(&quot;索引超出数组界限&quot;); &#125; T temp = data[index];//----------------------------------1 for (int i = index + 1; i &lt; count; i++)//不满足条件 &#123; data[i - 1] = data[i];//左移 &#125; count--;//-----------------------------------------------1 data[count] = default(T);//------------------------------1 return temp;//-------------------------------------------1 &#125; /// &lt;summary&gt; /// 删除末尾 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public T RemoveLast() &#123; return Delete(count - 1); &#125;","categories":[{"name":"基础学习","slug":"基础学习","permalink":"https://niaoyu00.github.io/Blog/categories/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://niaoyu00.github.io/Blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"时间复杂度","slug":"时间复杂度","permalink":"https://niaoyu00.github.io/Blog/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"}]},{"title":"csharp和js的对比(转载)","slug":"csharp和js的对比","date":"2022-10-22T08:32:46.000Z","updated":"2022-11-22T16:05:46.063Z","comments":true,"path":"2022/10/22/csharp和js的对比/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/10/22/csharp%E5%92%8Cjs%E7%9A%84%E5%AF%B9%E6%AF%94/","excerpt":"","text":"js和C#相比。最大不同，在于js是脚本语言，C#是编译性质的语言。 作用域方面js的作用域只有全局作用域和方法作用域，但是可以通过let关键字将作用域限制在块中C#是存在块作用域的，在块中定义的变量，出了这个块就不能使用。 数据类型js和C#一样从抽象层面来说都具有值类型和对象类型js的数字只有浮点型，导致计算数据不准确C#同时具有float， double，int，long等类型js的string类型是值类型，但是C#的string是比较特殊的对象类型(引用类型)js的字符串可以用双引号或单引号，但是C#只可以用双引号js和C#都含有数组对象，null关键字，但是js含有undefined类型，对于未初始化或未声明的变量，值或类型就是undefined constjs的const可以用来修饰对象，对象的属性值可以改变，但是变量所对应的对象不能更改为其它。C#的const只能修饰值类型 声明与初始化js可以先使用，然后声明，即声明提升C#不声明就不能使用，而且不初始化会赋予默认值。但是js不进行初始化就是undefined 比较符方面js多了两个特殊的比较符===和!==他们两个的特殊之处在于同时比较值和数据类型C#和大多数语言一样是&#x3D;&#x3D;和!&#x3D; 所以这是我觉得比较扯的地方 标记js可以定义代码label，然后用break和continue配合使用 异步编程js的异步编程是单线程 C#是直接创建线程 如果是Unity中使用C#,则Unity提供的C#异步操作（StartCoroutine IEnumerator）则是单线层操作。 for循环js当中存在一个for…in 相当于C#的foreach 定义对象不同js是通过大括号，并且将所有属性和方法全部写在里面。C#则是新建类，然后new一个对象 +不同类型js的加号运算符会尽量对相加的两者进行类型转换，然后得出一个看似正确的结果。C#则是直接报错。 函数定义js函数定义没有返回值类型（脚本语言本身就是一种弱类型语言）而且定义函数需要用function关键字，C#则并不需要。js的函数可以自调用，即自己调用自己。但是C#不存在这个语法。js和C#都支持匿名函数，也都支持闭包。js和C#的函数本质都是对象。js函数是一个对象，所以也有属于他的属性和方法call(),call方法的第一个参数是对象其实js函数的本质就是C#中的委托js函数中可以使用this，这个this指该函数所绑定的对象。如果函数是全局函数，那么就指代window对象 this的使用在js中，不同的上下文里面this所指代的对象是不同的。但是在C#中，this指的就是当前对象。 库js有自己的jquery库C#也有自己对应的很多dll库可以使用 版权声明：本文为CSDN博主「猫不在」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_33574890/article/details/116563755","categories":[{"name":"Csharp","slug":"Csharp","permalink":"https://niaoyu00.github.io/Blog/categories/Csharp/"}],"tags":[{"name":"Csharp","slug":"Csharp","permalink":"https://niaoyu00.github.io/Blog/tags/Csharp/"}]},{"title":"实现线性表List之链表","slug":"实现线性表List之链表","date":"2022-10-18T10:31:15.000Z","updated":"2022-11-11T00:21:52.718Z","comments":true,"path":"2022/10/18/实现线性表List之链表/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/10/18/%E5%AE%9E%E7%8E%B0%E7%BA%BF%E6%80%A7%E8%A1%A8List%E4%B9%8B%E9%93%BE%E8%A1%A8/","excerpt":"","text":"什么是链表链表由若干节点构成,节点之间有链接,链接末尾没有节点,指向空null. 链表的实现需要定义: 泛型变量作为节点数据; 下一个节点的引用; 头节点。 代码实现单链表using System;using System.Text;namespace AlgorithmTest08_链表&#123; /// &lt;summary&gt; /// 单链表 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; public class LinkedList1&lt;T&gt; &#123; /// &lt;summary&gt; /// 节点类 /// &lt;/summary&gt; private class Node &#123; public T t;//类型 public Node next;//下一个 public Node(T t, Node next) &#123; this.t = t; this.next = next; &#125; public Node(T t) &#123;//链表尾 this.t = t; this.next = null; &#125; public override string ToString() &#123; return t.ToString(); &#125; &#125; /// &lt;summary&gt; /// 链表头 /// &lt;/summary&gt; private Node head; /// &lt;summary&gt; /// 链表中存储了多少元素 /// &lt;/summary&gt; private int N; /// &lt;summary&gt; /// 链表类构造函数初始化 /// &lt;/summary&gt; public LinkedList1() &#123; head = null; N = 0; &#125; /// &lt;summary&gt; /// 元素个数 /// &lt;/summary&gt; public int Count &#123; get &#123; return N; &#125; &#125; /// &lt;summary&gt; /// 是否为空 /// &lt;/summary&gt; public bool IsEmpty &#123; get &#123; return N == 0; &#125; &#125; /// &lt;summary&gt; /// 添加元素 /// &lt;/summary&gt; public void Add(int index, T t) &#123; if (index &lt; 0 || index &gt; N) &#123; throw new ArgumentException(&quot;非法索引&quot;); &#125; if (index == 0) &#123; //Node node = new Node(t); //node.next = head; //head = node; head = new Node(t, head); &#125; else &#123; Node pre = head; for (int i = 0; i &lt; index - 1; i++) &#123; pre = pre.next; &#125; //Node node = new Node(t); //node.next = pre.next;//新增节点的下一个节点,等于pre位置的下一个节点[相当于占了它位置] //pre.next = node;//pre的下一个节点为新增的节点,[相当于被挤到左侧] pre.next = new Node(t, pre.next); &#125; N++; &#125; /// &lt;summary&gt; /// 头部添加 /// &lt;/summary&gt; /// &lt;param name=&quot;t&quot;&gt;&lt;/param&gt; public void AddFirst(T t) &#123; Add(0, t); &#125; /// &lt;summary&gt; /// 尾部添加 /// &lt;/summary&gt; /// &lt;param name=&quot;t&quot;&gt;&lt;/param&gt; public void AddLast(T t) &#123; Add(N, t); &#125; /// &lt;summary&gt; /// 查询,index:索引 /// &lt;/summary&gt; /// &lt;param name=&quot;index&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public T Get(int index) &#123; if (index &lt; 0 || index &gt;= N) &#123; throw new ArgumentException(&quot;非法索引&quot;); &#125; Node cur = head;//当前位置 for (int i = 0; i &lt; index; i++) &#123; cur = cur.next; &#125; return cur.t;//返回,值 &#125; /// &lt;summary&gt; /// 获取头节点内容 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public T GetFirst() &#123; return Get(0); &#125; /// &lt;summary&gt; /// 获取尾节点内容 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public T GetLast() &#123; return Get(N - 1); &#125; /// &lt;summary&gt; /// 修改节点内容 /// &lt;/summary&gt; /// &lt;param name=&quot;index&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;newT&quot;&gt;&lt;/param&gt; public void Set(int index, T newT) &#123; if (index &lt; 0 || index &gt;= N) &#123; throw new ArgumentException(&quot;非法索引&quot;); &#125; Node cur = head;//初始化当前节点 for (int i = 0; i &lt; index; i++) &#123; cur = cur.next; &#125; cur.t = newT; &#125; /// &lt;summary&gt; /// 查找链表中是否有该元素 /// &lt;/summary&gt; /// &lt;param name=&quot;t&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public bool Contains(T t) &#123; Node cur = head; while (cur != null) &#123; if (cur.t.Equals(t)) &#123; return true; &#125; cur = cur.next;//右移 &#125; return false; &#125; /// &lt;summary&gt; /// 删除索引处节点 /// &lt;/summary&gt; /// &lt;param name=&quot;index&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public T RemoveAt(int index) &#123; if (index &lt; 0 || index &gt;= N) &#123; throw new ArgumentException(&quot;索引不合法&quot;); &#125; if (index == 0) &#123;//删除头部 Node delNode = head;//接收原head数据 head = head.next; N--; return delNode.t; &#125; else &#123; Node pre = head; for (int i = 0; i &lt; index - 1; i++) &#123; pre = pre.next; &#125; Node delNode = pre.next; pre.next = delNode.next; N--; return delNode.t; &#125; &#125; /// &lt;summary&gt; /// 删除头节点 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public T RemoveFirst() &#123; return RemoveAt(0); &#125; /// &lt;summary&gt; /// 删除最后一个节点 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public T RemoveLast() &#123; return RemoveAt(N - 1); &#125; public void Remove(T t) &#123; if (head == null) &#123;//如果链表为空则弹出 return; &#125; if (head.t.Equals(t)) &#123;//删除的值为头部,则直接调用 RemoveFirst(); &#125; else &#123; Node cur = head; Node pre = null; while (cur != null) &#123; if (cur.t.Equals(t)) &#123; break; &#125; pre = cur;//第一轮pre移动到head,第二轮pre右移 cur = cur.next;//第一轮cur右移,第二轮cur右移 //直到查询到相同内容,弹出.或者cur为null(查到底了) &#125; if (cur != null) &#123;//删除操作,跳过cur pre.next = pre.next.next; N--; &#125; &#125; &#125; public override string ToString() &#123; StringBuilder res = new StringBuilder(); Node cur = head; while (cur != null) &#123; res.Append(cur + &quot;-&gt;&quot;); cur = cur.next; &#125; res.Append(&quot;null&quot;); return res.ToString(); &#125; &#125;&#125; 链表添加数据(带头节点)若是在头节点添加,就是新节点的next指向头节点,然后新节点赋值给head，自己成为新的头节点。 若是正常添加新节点，就是index位-1进行循环遍历。移动定位节点到位置的前一个，然后定位节点的next指向新节点的next，新节点本身指向定位节点的next，成功插入。 代码实现: /// &lt;summary&gt; /// 添加元素 /// &lt;/summary&gt; public void Add(int index, T t) &#123; if (index &lt; 0 || index &gt; N) &#123; throw new ArgumentException(&quot;非法索引&quot;); &#125; if (index == 0) &#123; //Node node = new Node(t); //node.next = head; //head = node; head = new Node(t, head); &#125; else &#123; Node pre = head; for (int i = 0; i &lt; index - 1; i++) &#123; pre = pre.next; &#125; //Node node = new Node(t); //node.next = pre.next;//新增节点的下一个节点,等于pre位置的下一个节点[相当于占了它位置] //pre.next = node;//pre的下一个节点为新增的节点,[相当于被挤到左侧] pre.next = new Node(t, pre.next); &#125; N++; &#125; /// &lt;summary&gt; /// 头部添加 /// &lt;/summary&gt; /// &lt;param name=&quot;t&quot;&gt;&lt;/param&gt; public void AddFirst(T t) &#123; Add(0, t); &#125; /// &lt;summary&gt; /// 尾部添加 /// &lt;/summary&gt; /// &lt;param name=&quot;t&quot;&gt;&lt;/param&gt; public void AddLast(T t) &#123; Add(N, t); &#125; 重写ToString public override string ToString()&#123; StringBuilder res = new StringBuilder(); Node cur = head; while (cur != null) &#123; res.Append(cur + &quot;-&gt;&quot;); cur = cur.next; &#125; res.Append(&quot;null&quot;); return res.ToString();&#125; 测试:class Program&#123; static void Main(string[] args) &#123; LinkedList1&lt;int&gt; l = new LinkedList1&lt;int&gt;(); Console.WriteLine(&quot;初次打印&quot;); for (int i = 0; i &lt; 5; i++) &#123; l.AddFirst(i); Console.WriteLine(l); &#125; Console.WriteLine(&quot;末尾添加数字99:&quot;); l.AddLast(99); Console.WriteLine(l); Console.WriteLine(&quot;索引2添加222&quot;); l.Add(2, 2222222); Console.WriteLine(l); Console.WriteLine(&quot;查询索引2&quot;); Console.WriteLine(l.Get(2)); Console.WriteLine(&quot;修改索引2&quot;); l.Set(2, 20); Console.WriteLine(l.Get(2)); Console.WriteLine(&quot;查找链表中是否有值&quot;); Console.WriteLine(l.Contains(4)); Console.ReadKey(); &#125;&#125; 删除元素头部:head.next指向下一个即可,其他部分:index前一个.next指向index.next /// &lt;summary&gt;/// 删除索引处节点/// &lt;/summary&gt;/// &lt;param name=&quot;index&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public T RemoveAt(int index)&#123; if (index &lt; 0 || index &gt;= N) &#123; throw new ArgumentException(&quot;索引不合法&quot;); &#125; if (index == 0) &#123;//删除头部 Node delNode = head;//接收原head数据 head = head.next; N--; return delNode.t; &#125; else &#123; Node pre = head; for (int i = 0; i &lt; index - 1; i++) &#123; pre = pre.next; &#125; Node delNode = pre.next; pre.next = delNode.next; N--; return delNode.t; &#125;&#125; 测试结果:","categories":[{"name":"基础学习","slug":"基础学习","permalink":"https://niaoyu00.github.io/Blog/categories/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://niaoyu00.github.io/Blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"单例模式","slug":"单例模式","date":"2022-10-17T21:11:00.000Z","updated":"2022-10-17T21:18:30.342Z","comments":true,"path":"2022/10/18/单例模式/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/10/18/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"概述单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，使用单例模式的类只有一个对象实例。 单例的实现要点单例模式要求类能够有返回对象一个引用（永远是同一个）和一个获得该实例的方法（必须是静态方法）。 单例的实现主要是通过以下三个步骤： 将类的构造方法定义为私有方法。这样其他类的代码就无法通过调用该类的构造方法来实例化该类的对象，只能通过该类提供的静态方法来得到该类的唯一实例。 定义一个私有的类的静态实例。 提供一个公有的获取实例的静态方法。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://niaoyu00.github.io/Blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://niaoyu00.github.io/Blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"单例模式","slug":"单例模式","permalink":"https://niaoyu00.github.io/Blog/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"Csharp拆装箱","slug":"csharp拆装箱","date":"2022-10-17T17:42:10.000Z","updated":"2022-10-25T05:56:09.805Z","comments":true,"path":"2022/10/18/csharp拆装箱/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/10/18/csharp%E6%8B%86%E8%A3%85%E7%AE%B1/","excerpt":"","text":"关于拆装箱 装箱:值类型数据转换为引用类型。装箱时，生成的是全新的引用对象，这会有时间损耗，因此装箱操作效率不高。 拆箱:引用类型数据转换为值类型数据。 利用装箱和拆箱功能，可通过允许值类型的任何值与Object 类型的值相互转换，将值类型与引用类型链接起来。 值类型只会在栈中分配; 引用类型分配内存与托管堆; 使用泛型可以避免拆装箱操作。 代码演示： using System;using System.Collections;using System.Collections.Generic;using System.Diagnostics;namespace AlgorithmTest07_拆装箱&#123; class Program &#123; static void Main(string[] args) &#123; int n = 100000000; Stopwatch t1 = new Stopwatch();//计时器 Stopwatch t2 = new Stopwatch();//计时器 Console.WriteLine(&quot;测试值类型对象int&quot;); t1.Start();//开始计时 List&lt;int&gt; L = new List&lt;int&gt;(); for (int i = 0; i &lt; n; i++) &#123; L.Add(i);//不发生装箱 int x = L[i];//不发生拆箱 &#125; t1.Stop();//停止计时 Console.WriteLine(t1.ElapsedMilliseconds + &quot;ms&quot;); t2.Start();//开始计时 ArrayList aL = new ArrayList(); for (int i = 0; i &lt; n; i++) &#123; aL.Add(i);//发生装箱[值类型(int)转引用类型(object),ArrayList是object引用类型] int x = (int)aL[i];//发生拆箱引用类型强转值类型 &#125; t2.Stop(); Console.WriteLine(t2.ElapsedMilliseconds + &quot;ms&quot;); Console.ReadKey(); &#125; &#125;&#125; 将运行上Debug改为Release 对比结果:","categories":[{"name":"Csharp","slug":"Csharp","permalink":"https://niaoyu00.github.io/Blog/categories/Csharp/"}],"tags":[{"name":"Csharp","slug":"Csharp","permalink":"https://niaoyu00.github.io/Blog/tags/Csharp/"}]},{"title":"在hexo主页创建音乐播放器且不停播","slug":"在hexo主页创建音乐播放器","date":"2022-10-13T18:38:50.000Z","updated":"2022-10-25T05:48:19.937Z","comments":true,"path":"2022/10/14/在hexo主页创建音乐播放器/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/10/14/%E5%9C%A8hexo%E4%B8%BB%E9%A1%B5%E5%88%9B%E5%BB%BA%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/","excerpt":"","text":"获取链接打开网易云音乐,找到专辑或者单曲,点击生成外链。 调完配置后复制html代码 到next皮肤文件夹下layout\\_macro里打开文件sidebar.njk 粘贴代码到这里 切换页面不停播在next主题文件夹下打开_config.yml把pjax打开 pjax: true 配置完成。 但是这样会有个问题,就是官方的播放器没法调音量看歌词之类的 所以我又想到个比较偷懒的办法,就是永久置顶一篇文章,里面只放播放器,这样就和在主页放差不多的效果了 还有个最大的问题就是虽然音乐不会断,但是操作界面会消失,这就非常难受。 最终解决方法:将网页版写在右侧用户栏,开启固定模式,就会一直悬在底部了 直接复制这段内容粘贴在图中位置 &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css&quot;&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js&quot;&gt;&lt;/script&gt;&lt;!-- require MetingJS --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js&quot;&gt;&lt;/script&gt; 然后再复制下面这段,记得id改成自己的,具体参数看MetingJS官方githup https://github.com/metowolf/MetingJS &lt;meting-js server=&quot;netease&quot; type=&quot;playlist&quot; id=&quot;979896497&quot; fixed=&quot;true&quot; list-folded=&quot;true&quot; autoplay=&quot;false&quot; volume=&quot;0.7&quot; preload=&quot;auto&quot; mutex=&quot;true&quot;&gt;&lt;/meting-js&gt; 文章中添加音乐插件安装npm install --save hexo-tag-aplayer 依赖 APlayer.js &gt; 1.8.0 Meting.js &gt; 1.1.1 MeingJS 支持 (3.0 新功能)在_config.yml中添加 aplayer: meting: true 接着就可以通过 &#123;% meting ...%&#125; 在文章中使用 MetingJS 播放器了： &lt;!-- 简单示例 (id, server, type) --&gt;&#123;% meting &quot;60198&quot; &quot;netease&quot; &quot;playlist&quot; %&#125;&lt;!-- 进阶示例 --&gt;&#123;% meting &quot;60198&quot; &quot;netease&quot; &quot;playlist&quot; &quot;autoplay&quot; &quot;mutex:false&quot; &quot;listmaxheight:340px&quot; &quot;preload:none&quot; &quot;theme:#ad7a86&quot;%&#125; 有关 的选项列表如下: 选项 默认值 描述 id 必须值 歌曲 id &#x2F; 播放列表 id &#x2F; 相册 id &#x2F; 搜索关键字 server 必须值 音乐平台: netease, tencent, kugou, xiami, baidu type 必须值 song, playlist, album, search, artist fixed false 开启固定模式 mini false 开启迷你模式 loop all 列表循环模式：all, one,none order list 列表播放模式： list, random volume 0.7 播放器音量 lrctype 0 歌词格式类型 listfolded false 指定音乐播放列表是否折叠 storagename metingjs LocalStorage 中存储播放器设定的键名 autoplay true 自动播放，移动端浏览器暂时不支持此功能 mutex true 该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停 listmaxheight 340px 播放列表的最大长度 preload auto 音乐文件预载入模式，可选项： none, metadata, auto theme #ad7a86 播放器风格色彩设置","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://niaoyu00.github.io/Blog/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://niaoyu00.github.io/Blog/tags/Hexo/"}]},{"title":"Hexo-next主题自定义","slug":"Hexo-next主题自定义","date":"2022-10-13T11:33:45.000Z","updated":"2022-11-22T18:40:29.044Z","comments":true,"path":"2022/10/13/Hexo-next主题自定义/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/10/13/Hexo-next%E4%B8%BB%E9%A2%98%E8%87%AA%E5%AE%9A%E4%B9%89/","excerpt":"","text":"之前我用的主题是icarus,研究了很久发现没法在主页固定音乐播放器，网上找了很多全是关于next的教程； 一气之下把主题换成了next，换过来之后我觉得配色之类的过于简约，有点不太喜欢； 于是打算先换换配色，搜了一圈发现那些diy主题的攻略全是旧版本的,和新版不同； 于是就有了这篇文章。 NexT version: 8.13.1 文件目录颜色目录source\\css\\_variables目录base.styl文件 主题样式\\source\\css\\_variables目录Gemini.styl文件(继承自Pisces) \\source\\css\\_variables目录Pisces.styl文件 改背景色我的博客主体会偏明亮一些，个人比较喜欢橙色黄色蓝色这类比较鲜艳的颜色，所以先改背景色。 找到主题目录下的\\source\\css\\_variables文件Gemini.styl,这个文件里还有挺多主题相关可以配置。 $body-bg-color = #f6d365; 渐变色代码可以 https://webgradients.com 这个网站中复制,非常好用,不过最好在\\source\\css\\_common\\scaffolding目录下的base.styl中加上几行,固定下 //background-image: linear-gradient(120deg, #f6d365 0%, #fda085 100%);background-repeat: no-repeat;background-attachment: fixed;background-size: cover; 添加视频循环播放作为背景来到目录hexo-theme-next\\layout找到_layout.njk 复制下面这段到body标签下 &lt;video id=&quot;bg&quot; autoplay=&quot;autoplay&quot; loop=&quot;loop&quot; muted=&quot;muted&quot; class=&quot;poster__bg&quot; style=&quot;opacity: 1;&quot; width: 1617px; height: 909.562px&gt; &lt;source src=&quot;https://ys.mihoyo.com/main/_nuxt/videos/3e78e80.mp4&quot; type=&quot;audio/mp4&quot;&gt; 您的浏览器不支持播放此视频.&lt;/video&gt; 接着到该目录hexo-theme-next\\source\\css\\_common\\scaffolding打开base.styl 搜索iframe, img,,删除其中的video标签,会影响布局。删除后长这样： 添加字段(top数值根据网站上面空位灵活调整): .poster__bg &#123; position: fixed; z-index :-999; top:-30px;&#125; 其他部分，比如文章透明度，文字颜色之类的，自己f12一个个找去吧~细节太多我说不过来。 点击按钮切换背景hexo-theme-next\\layout\\_partials\\sidebar\\site-overview.njk找到该文件 搜索class=&quot;links-of-author-item&quot;,在他下方的&#123;%- endfor %&#125;下面复制粘贴内容 &lt;span class=&quot;links-of-author-item&quot;&gt; &lt;button id=&quot;btnChange&quot; title=&quot;更换壁纸&quot;&gt; &lt;i class=&quot;fa fa-camera-retro fa-fw&quot;&gt;&lt;/i&gt; 更换壁纸 &lt;/button&gt; &lt;/span&gt; &lt;script&gt; let i=1; let btn=document.getElementById(&quot;btnChange&quot;); let videoSrc = [ &quot;https://niaoyu.oss-cn-shenzhen.aliyuncs.com/video/shaonv.mp4&quot;, &quot;https://niaoyu.oss-cn-shenzhen.aliyuncs.com/video/Wanye2_1.mp4&quot;, &quot;https://niaoyu.oss-cn-shenzhen.aliyuncs.com/video/Duizhang.mp4&quot;, ]; btn.onclick = () =&gt; &#123; video.src = videoSrc[i]; i++; if (i == 3) &#123; i = 0; &#125; &#125;;&lt;/script&gt; 文章边框同样在主题目录下的\\source\\css\\_variables文件Gemini.styl中 区块四角改成圆角$border-radius-inner = 10px;$border-radius = 10px; 给文章加边框第一步先定义参数$border-solid = solid 1px cornflowerblue;$border-solid-inner = solid 1px cornflowerblue; 第二步应用参数找到皮肤文件目录\\source\\css\\_schemes\\Gemini下的文件index.styl,找到对应类复制下面内容粘贴: .main-inner &gt; &#123; .sub-menu, .post-block, .tabs-comment, .comments, .pagination &#123; background: var(--content-bg-color); border-radius: $border-radius-inner; border: $border-solid-inner; box-shadow: $box-shadow-inner; &amp;:not(:first-child):not(.sub-menu) &#123; border-radius: $border-radius; border: $border-solid; box-shadow: $box-shadow; margin-top: $sidebar-offset; +tablet() &#123; margin-top: $content-tablet-padding; &#125; +mobile() &#123; margin-top: $content-mobile-padding; &#125; &#125; &#125;&#125; 找到目录source\\css\\_schemes\\Pisces,打开_layout.styl,找到对应类复制下面内容粘贴: .header-inner &#123; background: var(--content-bg-color); border-radius: $border-radius-inner; border:$border-solid-inner; box-shadow: $box-shadow-inner; width: $sidebar-desktop; +tablet-mobile() &#123; border-radius: initial; width: auto; &#125;&#125; 接着打开同目录下_siderbar.styl文件,找到对应类复制内容粘贴: .sidebar-inner &#123; background: var(--content-bg-color); border-radius: $border-radius; border:$border-solid; box-shadow: $box-shadow; box-sizing: border-box; color: var(--text-color);&#125; 改文章透明度找到主题目录下的\\source\\css\\_variables文件base.styl ctrl+f搜索content-bg-color,改成下面这样,当然不改透明度也挺好. $content-bg-color = #ffffffc9; 改博客标题背景颜色左上角那一坨黑色看着实在难受,我直接把他变白色透明度0,舒服多了。记得字体也要改下颜色 改颜色找到主题文件夹下面的_config.yml文件,搜索theme_color,直接改颜色为#ffffff00 theme_color: light: &quot;#ffffff00&quot; dark: &quot;#ffffff00&quot; 改标题字体颜色和粗细找到\\source\\css\\_common\\outline\\header的文件site-meta.styl,进去搜site-title .site-title &#123; font-family: $font-family-logo; font-size: $font-size-title; font-weight: bold; line-height: 1.5; color: black; margin: 0;&#125; 我改了颜色顺便加粗了 改文章标题为粗体找到\\source\\css\\_common\\components\\post的文件post-header.styl 搜索post-title修改里面的值 font-weight: bold; 为顶端留空顶格看着不难受嘛?反正我是受不了 还是在主题目录下的\\source\\css\\_variables文件base.styl 搜headband,改透明 增大间距,依个人口味可以调大点像素. $headband-height = 30px;$headband-bg = #ffffff00//var(--theme-color); 改”回顶部”小按钮的样式找到主题目录下的\\source\\css\\_variables文件base.styl 搜索b2我只改了最后一个,背景色: $b2t-bg-color = black//$black-deep;","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://niaoyu00.github.io/Blog/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://niaoyu00.github.io/Blog/tags/Hexo/"}]},{"title":"实现线性表List之顺序表","slug":"实现线性表List之顺序表","date":"2022-10-10T09:09:19.000Z","updated":"2022-10-25T05:45:08.523Z","comments":true,"path":"2022/10/10/实现线性表List之顺序表/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/10/10/%E5%AE%9E%E7%8E%B0%E7%BA%BF%E6%80%A7%E8%A1%A8List%E4%B9%8B%E9%A1%BA%E5%BA%8F%E8%A1%A8/","excerpt":"","text":"顺序表 定义接口namespace AlgorithmTest06_List&#123; interface IListDS&lt;T&gt; &#123; int GetLength();//求长度 void Chear();//清空 bool IsEmpty();//判断线性表是否为空 T Add(T item);//添加 void Insert(int index, T item);//插入 T Delete(int i);//删除 T this[int i] &#123; get; &#125;//定义索引器 获取元素 T GetElem(int i);//取表元 T Set(int i, T item);//修改 int IndexOf(T value);//按值查找 void Remove(T value);//根据值删除 &#125;&#125; 实现接口/// &lt;summary&gt;/// 实现顺序表/// &lt;/summary&gt;/// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;class SeqList&lt;T&gt; : IListDS&lt;T&gt;&#123; //新建类,继承IListDs&lt;T&gt;并且实现接口 private T[] data;//存储数据的数组 private int count = 0; /// &lt;summary&gt; /// size:设定成员个数,默认构造函数容量为10 /// &lt;/summary&gt; /// &lt;param name=&quot;size&quot;&gt;&lt;/param&gt; public SeqList(int size) &#123;//size是最大容量 data = new T[size]; count = 0; &#125; public SeqList() : this(10) &#123; &#125; /// &lt;summary&gt; /// index的位置插入item值 /// &lt;/summary&gt; /// &lt;param name=&quot;index&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;item&quot;&gt;&lt;/param&gt; public void Insert(int index, T item) &#123;//插入 if (index &lt; 0 || index &gt; count) &#123; throw new ArgumentException(&quot;数组索引越界&quot;); &#125; if (count == data.Length) &#123; //throw new ArgumentException(&quot;数组已满&quot;); ResetCapacity(2 * data.Length);//数组扩容加原来两倍 &#125; for (int i = count - 1; i &gt;= index; i--) &#123; data[i + 1] = data[i]; &#125; data[index] = item; count++; &#125; /// &lt;summary&gt; /// 末尾添加 /// &lt;/summary&gt; /// &lt;param name=&quot;item&quot;&gt;&lt;/param&gt; public T Add(T item) &#123; Insert(count, item); return item; &#125; /// &lt;summary&gt; /// 删除index位置的值 /// &lt;/summary&gt; /// &lt;param name=&quot;index&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public T Delete(int index) &#123; if (count == data.Length / 4)//不足四分之一时,空间减少 &#123; ResetCapacity(data.Length / 2); &#125; if (index &lt; 0 || index &gt;= count) &#123; throw new ArgumentException(&quot;索引超出数组界限&quot;); &#125; T temp = data[index]; for (int i = index + 1; i &lt; count; i++) &#123; data[i - 1] = data[i];//左移 &#125; count--; data[count] = default(T); return temp; &#125; public void Chear() &#123; count = 0; &#125; /// &lt;summary&gt; /// 通过i查找对应内容 /// &lt;/summary&gt; /// &lt;param name=&quot;i&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public T GetElem(int i) &#123; if (i &gt;= 0 &amp;&amp; i &lt; count)//索引存在 &#123; return data[i]; &#125; else &#123; return default(T); throw new ArgumentException(&quot;索引不存在&quot;); &#125; &#125; public T this[int i] &#123; get &#123; return GetElem(i); &#125; &#125; /// &lt;summary&gt; /// 索引i,替换内容为item /// &lt;/summary&gt; /// &lt;param name=&quot;i&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;item&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public T Set(int i, T item) &#123; if (i &gt;= 0 &amp;&amp; i &lt; count)//索引存在 return data[i] = item; else throw new ArgumentException(&quot;索引越界&quot;); &#125; /// &lt;summary&gt; /// 获取数组长度 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public int GetCount() &#123; return count;//非空数量 &#125; public int GetLength() &#123; return data.Length;//总元素 &#125; /// &lt;summary&gt; /// 是否为空 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public bool IsEmpty() &#123; return count == 0; &#125; /// &lt;summary&gt; /// 根据值找索引 /// &lt;/summary&gt; /// &lt;param name=&quot;value&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public int IndexOf(T value) &#123; for (int i = 0; i &lt; count; i++) &#123; if (data[i].Equals(value))//不能用==,因为都是值类型,不合法 &#123;//确定指定的对象是否等于当前对象。 return i; &#125; &#125; return -1;//值不存在 &#125; /// &lt;summary&gt; /// 根据值删除对象 /// &lt;/summary&gt; /// &lt;param name=&quot;value&quot;&gt;&lt;/param&gt; public void Remove(T value) &#123; int index = IndexOf(value); if (index != -1)//不能是搜寻不到的数 &#123; Delete(index);//删除 &#125; &#125; /// &lt;summary&gt; /// 打印 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public override string ToString() &#123; StringBuilder res = new StringBuilder(); for (int i = 0; i &lt; count - 1; i++) &#123; res.Append(data[i]); // if (i != count - 1) //如果不是最后一个元素 //&#123; res.Append(&quot;,&quot;); //&#125; &#125; res.Append(data[count - 1]); return res.ToString(); &#125; /// &lt;summary&gt; /// 扩容数组,私有 /// &lt;/summary&gt; /// &lt;param name=&quot;newCapacity&quot;&gt;&lt;/param&gt; private void ResetCapacity(int newCapacity) &#123; T[] newData = new T[newCapacity];//newCapacity:扩容多少 for (int i = 0; i &lt; count; i++) &#123; newData[i] = data[i];//赋值 &#125; data = newData;//再赋值,为了让他外部可用 &#125;&#125; 测试class Program&#123; static void Main(string[] argss) &#123; #region 添加和删除 //使用自己封装的顺序表 SeqList&lt;int&gt; seqlist = new SeqList&lt;int&gt;(20); Console.WriteLine(&quot;元素个数:&quot; + seqlist.GetCount()); for (int i = 0; i &lt; 10; i++) &#123; seqlist.Add(i); &#125; Console.WriteLine(&quot;已添加元素个数:&quot; + seqlist.GetCount()); Console.WriteLine(&quot;----------------&quot;); Console.WriteLine(&quot;索引3添加数字100&quot;); seqlist.Insert(3, 100);//索引3添加数字100 //for (int i = 0; i &lt; seqlist.GetLength(); i++) //&#123; // Console.Write(seqlist.GetElem(i) + &quot;;&quot;); //&#125; Console.WriteLine(seqlist); Console.WriteLine(&quot;个数:&quot; + seqlist.GetCount()); seqlist.Chear(); Console.WriteLine(&quot;清空后个数:&quot; + seqlist.GetCount()); Console.WriteLine(&quot;是否为空&quot; + seqlist.IsEmpty()); Console.WriteLine(&quot;----------------&quot;); for (int i = 4; i &gt; 0; i--) &#123; seqlist.Add(i); &#125; //for (int i = 0; i &lt; seqlist.GetLength(); i++) //&#123; // Console.Write(seqlist[i] + &quot;;&quot;); //&#125; Console.WriteLine(&quot;重新添加4~1&quot;); Console.WriteLine(seqlist); Console.WriteLine(&quot;\\n----------------&quot;); Console.WriteLine(&quot;删除:&quot; + seqlist.Delete(2)); //for (int i = 0; i &lt; seqlist.GetLength(); i++) //&#123; // Console.Write(seqlist[i] + &quot;;&quot;); //&#125; Console.WriteLine(&quot;打印&quot; + seqlist); Console.WriteLine(&quot;\\n----------------&quot;); #endregion #region 查找 Console.WriteLine(&quot;输入值找索引(-1为找不到):&quot;); int value = int.Parse(Console.ReadLine()); Console.WriteLine(&quot;索引:&quot; + seqlist.IndexOf(value)); Console.WriteLine(&quot;当前值:&quot; + seqlist); Console.WriteLine(&quot;找到后删除对象&quot;); seqlist.Remove(value); Console.WriteLine(&quot;----------------&quot;); Console.WriteLine(&quot;当前值:&quot; + seqlist); Console.WriteLine(&quot;索引0替换为100&quot;); seqlist.Set(0, 100); Console.WriteLine(seqlist); #endregion #region 扩容数组(动态数组) Console.WriteLine(&quot;----------------&quot;); Console.WriteLine(&quot;扩容数组&quot;); SeqList&lt;int&gt; seq = new SeqList&lt;int&gt;(10); for (int i = 0; i &lt; 10; i++) &#123; seq.Add(i); &#125; Console.WriteLine(&quot;数组元素展示:&quot; + seq); Console.WriteLine(&quot;容量:&quot; + seq.GetLength()); Console.WriteLine(&quot;数组元素数量:&quot; + seq.GetCount()); Console.WriteLine(&quot;添加元素:&quot; + seq.Add(1000)); Console.WriteLine(&quot;数组元素展示:&quot; + seq); Console.WriteLine(&quot;容量&quot; + seq.GetLength()); Console.WriteLine(&quot;数组元素数量:&quot; + seq.GetCount()); #endregion Console.ReadKey(); &#125;&#125; 重写ToString,添加打印功能class SeqList&lt;T&gt; : IListDS&lt;T&gt; public override string ToString() &#123; StringBuilder res = new StringBuilder(); for (int i = 0; i &lt; count; i++) &#123; res.Append(data[i]); if (i != count - 1) //如果不是最后一个元素 &#123; res.Append(&quot;, &quot;); &#125; &#125; return res.ToString(); &#125; 修改一下,去掉了if,将最后一个元素单独打印 public override string ToString() &#123; StringBuilder res = new StringBuilder(); for (int i = 0; i &lt; count - 1; i++) &#123; res.Append(data[i]); // if (i != count - 1) //如果不是最后一个元素 //&#123; res.Append(&quot;,&quot;); //&#125; &#125; res.Append(data[count - 1]); return res.ToString(); &#125; Main方法中直接打印seqlist 结果如下:","categories":[{"name":"基础学习","slug":"基础学习","permalink":"https://niaoyu00.github.io/Blog/categories/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://niaoyu00.github.io/Blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"Hexo新建文章模板","slug":"Hexo新建文章模板","date":"2022-10-10T09:03:52.000Z","updated":"2022-10-25T05:49:11.677Z","comments":true,"path":"2022/10/10/Hexo新建文章模板/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/10/10/Hexo%E6%96%B0%E5%BB%BA%E6%96%87%E7%AB%A0%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"问题hexo新建文章时,头部默认是只有title和date,每次要添加类别都要重新写。 解决方法：根目录下找到scaffolds文件夹下的post.md就可以编辑模板了","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://niaoyu00.github.io/Blog/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://niaoyu00.github.io/Blog/tags/Hexo/"}]},{"title":"Hexo首页显示摘要","slug":"Hexo首页显示摘要","date":"2022-10-10T07:52:44.000Z","updated":"2022-10-10T07:57:41.671Z","comments":true,"path":"2022/10/10/Hexo首页显示摘要/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/10/10/Hexo%E9%A6%96%E9%A1%B5%E6%98%BE%E7%A4%BA%E6%91%98%E8%A6%81/","excerpt":"","text":"解决Hexo博客没有auto_excerpt的问题1：使用npm安装hexo-excerptnpm install hexo-excerpt --save 2：在站点配置文件中添加excerpt: depth: 5 excerpt_excludes: [] more_excludes: [] hideWholePostExcerpts: true","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://niaoyu00.github.io/Blog/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://niaoyu00.github.io/Blog/tags/Hexo/"}]},{"title":"Hexo置顶功能","slug":"Hexo置顶功能","date":"2022-10-09T04:34:50.000Z","updated":"2022-11-22T15:44:02.658Z","comments":true,"path":"2022/10/09/Hexo置顶功能/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/10/09/Hexo%E7%BD%AE%E9%A1%B6%E5%8A%9F%E8%83%BD/","excerpt":"","text":"置顶功能1.替换首页生成器，在博客根目录中使用以下命令： # your_blognpm uninstall hexo-generator-index --save # 卸载原来的首页生成器npm install hexo-generator-index-pin-top --save # 安装有置顶功能的首页生成器 2.在博客根目录 your_blog&#x2F;_config.yml 的配置文件中设置文章排序方式： index_generator: path: &#x27;&#x27; per_page: 10 order_by: -top -date 3.对于想要置顶的文章，在 Markdown 文件开头设置 top: true ---title: article&#x27;s tiletop: true---markdown content 4.打开文件目录layout\\_partials\\post\\post-meta.njk,搜索post-meta在里面添加如下内容用以显示图标: &#123;% if post.top %&#125; &lt;span class=&quot;post-meta-item&quot;&gt; &lt;span class=&quot;post-meta-item-icon&quot;&gt; &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt; &lt;font color=7D26CD&gt;置顶&lt;/font&gt; &lt;/span&gt; &lt;/span&gt;&#123;% endif %&#125;","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://niaoyu00.github.io/Blog/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://niaoyu00.github.io/Blog/tags/Hexo/"}]},{"title":"数据结构-栈","slug":"数据结构-栈","date":"2022-10-06T09:31:25.000Z","updated":"2022-11-22T18:42:10.260Z","comments":true,"path":"2022/10/06/数据结构-栈/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/","excerpt":"","text":"栈(Stack) 栈中元素是从上到下加入的，即“后进先出” 栈的应用十进制转二进制 Console.WriteLine(&quot;请输入一个十进制数字&quot;); int num = int.Parse(Console.ReadLine()); Stack&lt;int&gt; Remainder = new Stack&lt;int&gt;(); while (num != 0) &#123; Remainder.Push(num % 2); num /= 2; &#125; foreach (var item in Remainder) &#123; Console.ForegroundColor = ConsoleColor.DarkBlue; Console.Write(item); &#125; Console.ReadKey(); 打印结果: 数组实现栈栈的相关操作 Stack void Push(t) 添加元素 T Pop() 删除栈顶 T Peek() 查询栈顶 int Count 栈中多少元素 bool IsEmpty 是否为空 数组在尾端添加删除最合适 新建接口新建一个**接口Stack**实现以上方法 namespace AlgorithmTest09_实现栈Stack&#123; interface IStack&lt;T&gt; &#123; int Count &#123; get; &#125; bool IsEmpty &#123; get; &#125; void Push(T t); T Pop(); T Peek(); &#125;&#125; 实现接口新建Array1Stack类实现接口功能 using AlgorithmTest06_List;namespace AlgorithmTest09_实现栈Stack&#123; class Array1Stack&lt;T&gt; : IStack&lt;T&gt; &#123; private SeqList&lt;T&gt; arr; /// &lt;summary&gt; /// 构造函数 /// 参数:容量 /// &lt;/summary&gt; /// &lt;param name=&quot;capacity&quot;&gt;&lt;/param&gt; public Array1Stack(int capacity) &#123; arr = new SeqList&lt;T&gt;(capacity); &#125; /// &lt;summary&gt; /// 构造函数,默认10容量 /// &lt;/summary&gt; public Array1Stack() &#123; arr = new SeqList&lt;T&gt;(); &#125; public int Count &#123; get &#123; return arr.GetCount(); &#125; &#125;//个数 public bool IsEmpty &#123; get &#123; return arr.IsEmpty(); &#125; &#125;//是否为空 /// &lt;summary&gt; /// 数组底部入栈,为栈顶 /// &lt;/summary&gt; /// &lt;param name=&quot;t&quot;&gt;&lt;/param&gt; public void Push(T t) &#123; arr.AddLast(t); &#125; /// &lt;summary&gt; /// 查询栈顶元素 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public T Peek() &#123; return arr[arr.count - 1];//获取数组末尾索引 &#125; /// &lt;summary&gt; /// 删除数组末尾,出栈 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public T Pop() &#123; return arr.RemoveLast(); &#125; public override string ToString() &#123; return &quot;Stack:&quot; + arr.ToString() + &quot;--Top&quot;; &#125; &#125;&#125; 实现效果using System;namespace AlgorithmTest09_实现栈Stack&#123; class Program &#123; static void Main(string[] args) &#123; Array1Stack&lt;int&gt; stack = new Array1Stack&lt;int&gt;(); Console.WriteLine(&quot;-----栈顶添加元素-----&quot;); for (int i = 0; i &lt; 5; i++) &#123; stack.Push(i); Console.WriteLine(stack); &#125; Console.WriteLine(&quot;-----栈顶删除元素-----&quot;); Console.WriteLine(&quot;删除:&quot; + stack.Pop()); Console.WriteLine(stack); Console.WriteLine(&quot;查询栈顶:&quot; + stack.Peek()); Console.WriteLine(&quot;元素个数:&quot; + stack.Count); Console.WriteLine(&quot;是否为空:&quot; + stack.IsEmpty); Console.ReadKey(); &#125; &#125;&#125; 演示结果 链表实现栈栈的相关操作 Stack void Push(t) 添加元素 T Pop() 删除栈顶 T Peek() 查询栈顶 int Count 栈中多少元素 bool IsEmpty 是否为空 链表最方便的是在头部进行添加或删除操作 实现接口新建LinkedList1Stack类实现IStack接口的方法 using AlgorithmTest08_链表;namespace AlgorithmTest09_实现栈Stack&#123; /// &lt;summary&gt; /// 链表栈 /// &lt;/summary&gt; class LinkedList1Stack&lt;T&gt; : IStack&lt;T&gt; &#123; private LinkedList1&lt;T&gt; list;//链表 public LinkedList1Stack() &#123; list = new LinkedList1&lt;T&gt;(); &#125; /// &lt;summary&gt; /// 节点个数 /// &lt;/summary&gt; public int Count &#123; get &#123; return list.Count; &#125; &#125; /// &lt;summary&gt; /// 是否有节点 /// &lt;/summary&gt; public bool IsEmpty &#123; get &#123; return list.IsEmpty; &#125; &#125; /// &lt;summary&gt; /// 头部添加节点-入栈 /// &lt;/summary&gt; /// &lt;param name=&quot;t&quot;&gt;&lt;/param&gt; public void Push(T t) &#123; list.AddFirst(t); &#125; /// &lt;summary&gt; /// 查询头部节点--查询栈顶 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public T Peek() &#123; return list.GetFirst(); &#125; /// &lt;summary&gt; /// 删除头节点-栈顶出栈 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public T Pop() &#123; return list.RemoveFirst(); &#125; public override string ToString() &#123; return &quot;Stack:Top--&quot; + list.ToString(); &#125; &#125;&#125; 实现效果using System;namespace AlgorithmTest09_实现栈Stack&#123; class Program &#123; static void Main(string[] args) &#123; Array1Stack&lt;int&gt; stack = new Array1Stack&lt;int&gt;(); Console.WriteLine(&quot;-----栈顶添加元素-----&quot;); for (int i = 0; i &lt; 5; i++) &#123; stack.Push(i); Console.WriteLine(stack); &#125; Console.WriteLine(&quot;-----栈顶删除元素-----&quot;); Console.WriteLine(&quot;删除:&quot; + stack.Pop()); Console.WriteLine(stack); Console.WriteLine(&quot;查询栈顶:&quot; + stack.Peek()); Console.WriteLine(&quot;元素个数:&quot; + stack.Count); Console.WriteLine(&quot;是否为空:&quot; + stack.IsEmpty); Console.WriteLine(&quot;-----链表栈演示-----&quot;); LinkedList1Stack&lt;int&gt; listStack = new LinkedList1Stack&lt;int&gt;(); Console.WriteLine(&quot;-----链表栈顶添加元素-----&quot;); for (int i = 0; i &lt; 5; i++) &#123; listStack.Push(i); Console.WriteLine(listStack); &#125; Console.WriteLine(&quot;-----链表栈顶删除元素-----&quot;); Console.WriteLine(&quot;删除:&quot; + listStack.Pop()); Console.WriteLine(listStack); Console.WriteLine(&quot;查询栈顶:&quot; + listStack.Peek()); Console.WriteLine(&quot;元素个数:&quot; + listStack.Count); Console.WriteLine(&quot;是否为空:&quot; + listStack.IsEmpty); Console.ReadKey(); &#125; &#125;&#125; 演示结果","categories":[{"name":"基础学习","slug":"基础学习","permalink":"https://niaoyu00.github.io/Blog/categories/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Csharp","slug":"Csharp","permalink":"https://niaoyu00.github.io/Blog/tags/Csharp/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://niaoyu00.github.io/Blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"栈","slug":"栈","permalink":"https://niaoyu00.github.io/Blog/tags/%E6%A0%88/"}]},{"title":"算法学习-枚举和递归","slug":"算法学习-枚举和递归","date":"2022-10-05T05:46:25.000Z","updated":"2022-11-22T16:05:53.557Z","comments":true,"path":"2022/10/05/算法学习-枚举和递归/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/10/05/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%9E%9A%E4%B8%BE%E5%92%8C%E9%80%92%E5%BD%92/","excerpt":"","text":"枚举算法 打印结果: 递归算法static void Main(string[] args)&#123; //递归 Console.WriteLine(&quot;请输入阶乘数(小于17):&quot;); int i = int.Parse(Console.ReadLine()); Console.WriteLine(Mul(i)); Console.ReadKey();&#125;public static int Mul(int i)&#123; if (i &lt;= 1) &#123; return 1; &#125; else &#123; return Mul(i - 1) * i; &#125;&#125; 打印结果:","categories":[{"name":"基础学习","slug":"基础学习","permalink":"https://niaoyu00.github.io/Blog/categories/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Csharp","slug":"Csharp","permalink":"https://niaoyu00.github.io/Blog/tags/Csharp/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://niaoyu00.github.io/Blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"算法学习-递推逆推","slug":"算法学习-递推逆推","date":"2022-10-04T07:27:55.000Z","updated":"2022-11-22T16:05:57.007Z","comments":true,"path":"2022/10/04/算法学习-递推逆推/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/10/04/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E9%80%92%E6%8E%A8%E9%80%86%E6%8E%A8/","excerpt":"","text":"递推算法有一只大兔子，一个月生一只小兔子，过一个月小兔子变大兔子。以此求第几个月，有几个大兔子。 namespace AlgorithmTest&#123; class Program &#123; static void Main(string[] args) &#123; //费波拉契数列，一个数等于前两个数之和。 //根据输入数，展示到这个数之前的所有数。 Console.WriteLine(&quot;请输入一个0~21之间的数&quot;); int i = int.Parse(Console.ReadLine()); int[] array = new int[20];//定义有20个空的数组 array[0] = 1; array[1] = 1; if (i == 1) &#123; Console.WriteLine(array[0]); &#125; else if (i == 2) &#123; Console.WriteLine(array[0]); Console.WriteLine(array[1]); &#125; else if (i &gt;= 3 &amp;&amp; i &lt; 21) &#123; Console.WriteLine(array[0]); Console.WriteLine(array[1]); for (int j = 3; j &lt;= i; j++) &#123; array[j - 1] = array[j - 2] + array[j - 3]; Console.WriteLine(array[j - 1]); &#125; &#125; else &#123; Console.WriteLine(&quot;数字超过范围&quot;); &#125; Console.ReadKey(); &#125; &#125;&#125; 打印结果： 逆推求存款四年时间，每个月取出1000元(利率按0.0171)，至少需要存多少钱才行? namespace AlgorithmTest02&#123; class Program &#123; static void Main(string[] args) &#123; //逆推 float Fetch = 1000f;//每月取一千 float rate = 0.0171f;//利率 double[] corpis = new double[49];//本金 corpis[48] = Fetch; Console.WriteLine(&quot;第48月末本利合计:&quot; + corpis[48]); for (int i = 47; i &gt; 0; i--) &#123; corpis[i] = (corpis[i + 1] + Fetch) / (1 + rate / 12); Console.WriteLine(&quot;第&quot; + i + &quot;月末本利合计:&quot; + corpis[i]); &#125; Console.ReadKey(); &#125; &#125;&#125; 打印结果： 猴子摘桃猴子第一天摘了若干个桃子，当即吃了一半，还不过瘾，又多吃了一个。第二天早上又将剩下的桃子吃掉一半，又多吃一个。以后每天早上都吃前一天的一半零一个。到第十天的时候再想多吃，见只剩下一个桃子了。求第一天一共摘了多少桃子？ static void Main(string[] args) &#123; int[] taozi = new int[11]; taozi[10] = 1; Console.WriteLine(&quot;第十天有&quot; + taozi[10] + &quot;个桃子&quot;); for (int i = 9; i &gt; 0; i--) &#123; taozi[i] = 2 * (taozi[i + 1] + 1); Console.WriteLine(&quot;第&quot; + i + &quot;天有&quot; + taozi[i] + &quot;个&quot;); &#125; Console.ReadKey(); &#125; 网上看到的写法感觉更精简 static void Main(string[] args) &#123; int day, x, y; day = 10; y = 1; while (day &gt; 1) &#123; x = (y + 1) * 2; y = x; day--; Console.WriteLine(&quot;第&quot; + day + &quot;天有&quot; + x + &quot;个&quot;); &#125; Console.ReadKey(); &#125; 打印结果:","categories":[{"name":"基础学习","slug":"基础学习","permalink":"https://niaoyu00.github.io/Blog/categories/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Csharp","slug":"Csharp","permalink":"https://niaoyu00.github.io/Blog/tags/Csharp/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://niaoyu00.github.io/Blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"数据结构与算法学习","slug":"数据结构与算法学习","date":"2022-10-04T07:26:45.000Z","updated":"2022-11-22T16:05:49.508Z","comments":true,"path":"2022/10/04/数据结构与算法学习/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"最近打算恶补数据结构，在学校的时候对数据结构与算法一直是一知半解，懵懵懂懂的样子。特开此贴记录一下过程，希望能有所收获。打算看过c#基本的数据结构之后，各种类型算法题多刷刷。 算法与数据结构的关系 数据结构可以认为是数据在程序中的存储结构,和基本数据操作 算法可以认为是用来解决问题的方法，算法基于数据结构 数据结构是问题的核心，是算法的基础 算法(Algorithm)的评价标准 运行时间(Running Time) 占用空间(Storage Space) 有时需要牺牲空间换取时间，有时需要牺牲时间来换取空间 其他方面：正确性(Correctness)、可读性(Readability)、健壮性(Robustness) 数据结构","categories":[{"name":"基础学习","slug":"基础学习","permalink":"https://niaoyu00.github.io/Blog/categories/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Csharp","slug":"Csharp","permalink":"https://niaoyu00.github.io/Blog/tags/Csharp/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://niaoyu00.github.io/Blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"开发笔记","slug":"开发笔记","date":"2022-10-01T10:12:03.000Z","updated":"2022-10-02T19:53:18.465Z","comments":true,"path":"2022/10/01/开发笔记/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/10/01/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/","excerpt":"","text":"在给任务轨迹Trail找安放位置的时候我发现：这个模型还有好多武器之类的cube，于是打算做个笔记，以后也许能用到。 另外有一个想法：吃到蓝色超级跳宝石时给角色换双鞋子，将这个超能力设定改为装备赋予，给鞋子加一个Trail短一点的轨迹，应该很酷。 这样的话就需要学一下换装了。干脆在开始页面来一个自定义装扮场景。 刚开始我设想是点击图标然后隐藏&#x2F;显示角色身上对应的衣服，看了视频的开头才知道，可以给角色换骨骼和mesh，确实比直接开关gameobject合理得多，更省资源。国庆几天尝试一下。","categories":[],"tags":[{"name":"开发笔记","slug":"开发笔记","permalink":"https://niaoyu00.github.io/Blog/tags/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"}]},{"title":"Csharp中问号的用法（转载）","slug":"Csharp中问号的用法","date":"2022-09-25T10:06:05.000Z","updated":"2022-11-22T16:05:40.573Z","comments":true,"path":"2022/09/25/Csharp中问号的用法/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/09/25/Csharp%E4%B8%AD%E9%97%AE%E5%8F%B7%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"C#中? 、?? 、?. 、??&#x3D; 的用法和说明（转载）一、可空类型修饰符&lt; ? &gt;引用类型能用空引用来表示一个表示一个不存在的值，但是值类型不能。例如： string str = null;int i = null;//编译报错 为了使值类型也能使用可空类型，就可以用 “ ? “来表示，表现形式为”T?”。例如： int i? //表示可空的整型DateTime time? //表示可空的时间 二、空合并运算符&lt; ?? &gt;用于定义引用类型和可空类型的默认值。如果此运算符的左操作数不为Null，则此操作符将返回左操作数，否则返回右操作数。 var c = a??b //当a不为null时返回a，为null时返回b 三、&lt; ?. &gt;不为null时执行后面的操作。例如： Person.Name?.Person.Code Person.Name = Person == null ? null : Person.Code //两段代码等效 四、&lt; ??&#x3D; &gt;C# 8.0 引入了 null 合并赋值运算符 ??&#x3D;。 仅当左操作数计算为 null 时，才能使用运算符 ??&#x3D; 将其右操作数的值分配给左操作数。 List&lt;int&gt; numbers = null;int? i = null;numbers ??= new List&lt;int&gt;();numbers.Add(i ??= 17);numbers.Add(i ??= 20);Console.WriteLine(string.Join(&quot; &quot;, numbers)); // output: 17 17Console.WriteLine(i); // output: 17 版权声明：本文为CSDN博主「机械键盘侠」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/xuchen_wang/article/details/102850615","categories":[{"name":"Csharp","slug":"Csharp","permalink":"https://niaoyu00.github.io/Blog/categories/Csharp/"}],"tags":[{"name":"Csharp","slug":"Csharp","permalink":"https://niaoyu00.github.io/Blog/tags/Csharp/"}]},{"title":"平台游戏控制器之计时功能","slug":"平台游戏控制器之计时功能","date":"2022-09-23T09:05:10.000Z","updated":"2022-10-08T10:21:48.809Z","comments":true,"path":"2022/09/23/平台游戏控制器之计时功能/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/09/23/%E5%B9%B3%E5%8F%B0%E6%B8%B8%E6%88%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B%E8%AE%A1%E6%97%B6%E5%8A%9F%E8%83%BD/","excerpt":"","text":"ready动画结束后游戏开始,开始计时,直到死亡或者胜利再暂停计时。 新建ClearTime脚本用来更新时间文本,开始动画过后再计时 public class ClearTime : MonoBehaviour&#123; [SerializeField] Text timeText; [SerializeField] VoidEventChannel levelStartedEventChannel;//开始游戏 [SerializeField] VoidEventChannel levelClearedEventChannel;//玩家过关 [SerializeField] StringEventChannel cleardTimeTextEventChannel;//带string参数的频道 [SerializeField] VoidEventChannel playerDefeatedEventChannel;//玩家失败 float clearTime;//时间 bool stop = true;//计时停止 private void OnEnable() &#123; //游戏开始 levelStartedEventChannel.AddListener(LevelStart); //玩家通关 levelClearedEventChannel.AddListener(levelCleared); //玩家失败 playerDefeatedEventChannel.AddListener(HideUI); &#125; private void OnDisable() &#123; //游戏开始 levelStartedEventChannel.RemoveListener(LevelStart); //玩家通关 levelClearedEventChannel.RemoveListener(levelCleared); //玩家失败 playerDefeatedEventChannel.RemoveListener(HideUI); &#125; private void FixedUpdate() &#123;//当计时停止时 返回. if (stop) return; clearTime += Time.fixedDeltaTime; //将clearTime转化为秒,按格式输出 timeText.text = System.TimeSpan.FromSeconds(clearTime).ToString(@&quot;mm\\:ss\\:ff&quot;); &#125; void LevelStart() &#123;//开始游戏 stop = false;//开始计时 &#125; void levelCleared() &#123;//过关 HideUI(); cleardTimeTextEventChannel.Broadcast(timeText.text); &#125; void HideUI() &#123; stop = true;//计时停止 GetComponent&lt;Canvas&gt;().enabled = false;//关闭ui显示 &#125;&#125; 过关时间显示在Victory Screen创建带参数的EventChannel.事件频道创建脚本OneParameterEventChannel设置为泛型,用来继承,方便以后传不同类型参数 public class OneParameterEventChannel&lt;T&gt; : ScriptableObject&#123; //单参数事件频道 event System.Action&lt;T&gt; Delegate; public void Broadcast(T obj) &#123; Delegate?.Invoke(obj);//调用委托 &#125; public void AddListener(System.Action&lt;T&gt; action) &#123; Delegate += action; &#125;//订阅 public void RemoveListener(System.Action&lt;T&gt; action) &#123; Delegate -= action; &#125;//退订&#125; 创建StringEventChannel继承OneParameterEventChannel并且参数类型为&lt;string&gt; using System.Collections;using System.Collections.Generic;using UnityEngine;[CreateAssetMenu(menuName = &quot;Data/EventChannels/StringEventChannel&quot;, fileName = &quot;StringEventChannel_&quot;)]public class StringEventChannel : OneParameterEventChannel&lt;string&gt;&#123;&#125; 这样就可以在相应的地方加入参数传递。 在VictoryScreen获胜ui中获取文本对象[SerializeField] Text timeText;，还有[SerializeField] StringEventChannel clearTimeTextEventChannel;//带string参数的频道 OnEnable()和OnDisable()分别订阅&#x2F;退订方法SetTimeText()，该方法将获取的string参数赋值给Text timeText， [SerializeField] Text timeText;[SerializeField] StringEventChannel clearTimeTextEventChannel;//带string参数的频道 private void OnEnable() &#123; clearTimeTextEventChannel.AddListener(SetTimeText); &#125;private void OnDisable() &#123; clearTimeTextEventChannel.RemoveListener(SetTimeText); &#125;private void SetTimeText(string obj) &#123; timeText.text = obj; &#125; 接着看ClearTime脚本，同样序列化cleardTimeTextEventChannel [SerializeField] StringEventChannel cleardTimeTextEventChannel;//带string参数的频道 在过关函数触发时，调用并且将ui上的timeText数据传入StringEventChannel。 void levelCleared()&#123;//过关 HideUI(); cleardTimeTextEventChannel.Broadcast(timeText.text);&#125;","categories":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/categories/unity/"}],"tags":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/tags/unity/"},{"name":"平台跳跃控制器","slug":"平台跳跃控制器","permalink":"https://niaoyu00.github.io/Blog/tags/%E5%B9%B3%E5%8F%B0%E8%B7%B3%E8%B7%83%E6%8E%A7%E5%88%B6%E5%99%A8/"}]},{"title":"平台游戏控制器之状态驱动虚拟相机","slug":"平台游戏控制器之状态驱动虚拟相机","date":"2022-09-23T08:04:00.000Z","updated":"2022-10-25T18:13:30.827Z","comments":true,"path":"2022/09/23/平台游戏控制器之状态驱动虚拟相机/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/09/23/%E5%B9%B3%E5%8F%B0%E6%B8%B8%E6%88%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B%E7%8A%B6%E6%80%81%E9%A9%B1%E5%8A%A8%E8%99%9A%E6%8B%9F%E7%9B%B8%E6%9C%BA/","excerpt":"","text":"说明:为角色胜利镜头做特殊定制 follow属性用玩家对象 Animated Target:动画目标属性,拖入角色. 原有的相机拖入状态驱动虚拟相机下 复制一个相机改名为Zoom In,意为镜头放大的虚拟相机. 将镜头垂直视野值36改为24 回到状态驱动虚拟相机对象,在这可选玩家不同状态对应使用不同的相机,还可以设置延迟1.2秒切换","categories":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/categories/unity/"}],"tags":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/tags/unity/"},{"name":"平台跳跃控制器","slug":"平台跳跃控制器","permalink":"https://niaoyu00.github.io/Blog/tags/%E5%B9%B3%E5%8F%B0%E8%B7%B3%E8%B7%83%E6%8E%A7%E5%88%B6%E5%99%A8/"}]},{"title":"平台游戏控制器之过关","slug":"平台游戏控制器之过关","date":"2022-09-23T05:15:00.000Z","updated":"2022-10-02T19:51:56.092Z","comments":true,"path":"2022/09/23/平台游戏控制器之过关/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/09/23/%E5%B9%B3%E5%8F%B0%E6%B8%B8%E6%88%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B%E8%BF%87%E5%85%B3/","excerpt":"","text":"过关功能实现说明:过关时开启ui,切换状态为vitory,落地后再播放动画。 VictoryScreen中增加代码:订阅按钮功能,唤出鼠标指针。 using UnityEngine;using UnityEngine.UI;public class VictoryScreen : MonoBehaviour&#123; [SerializeField] VoidEventChannel levelClearedEventChannel;//获取事件频道 [SerializeField] Button nextLevelButton; private void OnEnable() &#123; levelClearedEventChannel.AddListener(ShowUI); nextLevelButton.onClick.AddListener(SceneLoader.LoadNextScene);//订阅下一关按钮功能 &#125; private void OnDisable() &#123; levelClearedEventChannel.RemoveListener(ShowUI); nextLevelButton.onClick.RemoveListener(SceneLoader.LoadNextScene);//订阅下一关按钮功能 &#125; private void ShowUI() &#123; GetComponent&lt;Canvas&gt;().enabled = true; GetComponent&lt;Animator&gt;().enabled = true; Cursor.lockState = CursorLockMode.None; &#125;&#125; PlayerState_Land的LogicUpdate中添加判定，如果玩家胜利，则切换为PlayerState_Victory状态。 PlayerState_Victory状态主要进行随机播放获胜音效。 public class PlayerState_Victory : PlayerState&#123; [SerializeField] AudioClip[] voice; public override void Enter() &#123; base.Enter(); input.DisableGamePlayInputs();//关闭动作表 player.voicePlayer.PlayOneShot(voice[Random.Range(0, voice.Length)]); &#125;&#125;","categories":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/categories/unity/"}],"tags":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/tags/unity/"},{"name":"平台跳跃控制器","slug":"平台跳跃控制器","permalink":"https://niaoyu00.github.io/Blog/tags/%E5%B9%B3%E5%8F%B0%E8%B7%B3%E8%B7%83%E6%8E%A7%E5%88%B6%E5%99%A8/"}]},{"title":"平台游戏控制器之玩家失败","slug":"平台游戏控制器之玩家失败","date":"2022-09-21T09:50:20.000Z","updated":"2022-10-02T19:52:55.421Z","comments":true,"path":"2022/09/21/平台游戏控制器之玩家失败/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/09/21/%E5%B9%B3%E5%8F%B0%E6%B8%B8%E6%88%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B%E7%8E%A9%E5%AE%B6%E5%A4%B1%E8%B4%A5/","excerpt":"","text":"说明:玩家碰到尖刺或者被黑球撞到就会死亡 功能实现尖刺碰撞首先选中所有尖刺,为他们添加脚本Spike using UnityEngine;public class Spike : MonoBehaviour&#123; private void OnTriggerEnter(Collider other) &#123; if (other.TryGetComponent(out PlayerController player)) &#123;//如果碰撞的是挂载PlayerController的对象 player.OnDefeated();//游戏失败，玩家身上相关功能禁用 &#125; &#125;&#125; 角色属性调整(关闭功能)通过问题修复功能,自动在PlayerController脚本中生成**OnDefeated()**函数; 同样地,在input类中生成DisableGamePlayInputs(); public void OnDefeated() &#123;//游戏失败 input.DisableGamePlayInputs();//关闭输入 rigidBody.velocity = Vector3.zero;//速度清零 rigidBody.useGravity = false;//关闭重力对刚体的影响 rigidBody.detectCollisions = false;//关闭刚体碰撞检测 //状态机切换到失败状态 GetComponent&lt;StateMachine&gt;().SwitchState(typeof(PlayerState_Defeated)); &#125; DisableGamePlayInputs();只有一行代码:禁用当前输入动作表。playerInputAction.GamePlay.Disable(); 小球碰撞为球Ball添加脚本Ball,如果球撞到玩家,则执行玩家死亡游戏失败逻辑。 using System.Collections;using System.Collections.Generic;using UnityEngine;public class Ball : MonoBehaviour&#123; [SerializeField] Collider gameplayer;//获取玩家碰撞体 [SerializeField] PlayerController player;//获取玩家控制器 private void OnCollisionEnter(Collision other) &#123; //Debug.Log(other.collider); //Debug.Log(gameplayer); if (other.collider == gameplayer) &#123; player.OnDefeated(); &#125; &#125;&#125; 更简便的写法: using System.Collections;using System.Collections.Generic;using UnityEngine;public class Ball : MonoBehaviour&#123; // [SerializeField] Collider gameplayer;//获取玩家碰撞体 // [SerializeField] PlayerController player;//获取玩家控制器 private void OnCollisionEnter(Collision other) &#123; if (other.gameObject.TryGetComponent(out PlayerController player)) &#123; player.OnDefeated(); &#125; // if (other.collider == gameplayer) // &#123; // player.OnDefeated(); // &#125; &#125;&#125; 给小球加上消失功能,大约6s摧毁自身 using System;using System.Collections;using System.Collections.Generic;using UnityEngine;public class Ball : MonoBehaviour&#123; [SerializeField] VoidEventChannel ballTriggeredEventChannel; private void OnEnable() &#123; ballTriggeredEventChannel.AddListener(EliminateBall); &#125; private void OnDisable() &#123; ballTriggeredEventChannel.RemoveListener(EliminateBall); &#125; private void OnCollisionEnter(Collision other) &#123; if (other.gameObject.TryGetComponent(out PlayerController player)) &#123; player.OnDefeated(); &#125; &#125; private void EliminateBall() &#123; Destroy(gameObject, 6f); &#125;&#125; 对状态的操作新建状态PlayerState_Defeated 用来玩家生成死亡时的音效、特效 using System;using UnityEngine;[CreateAssetMenu(menuName = &quot;Data/StateMachine/PlayerState/Defeated&quot;, fileName = &quot;PlayerState_Defeated&quot;)]public class PlayerState_Defeated : PlayerState&#123; [SerializeField] ParticleSystem Deathvfx;//死亡特效 [SerializeField] AudioClip[] voice;//音效集合 public override void Enter() &#123; base.Enter(); Instantiate(Deathvfx, player.transform.position, Quaternion.identity);//生成特效 AudioClip deathVoice = voice[UnityEngine.Random.Range(0, voice.Length)];//随机选中一个音效 player.voicePlayer.PlayOneShot(deathVoice);//播放音效 &#125;&#125; UI相关新建SceneLoader脚本用来管理场景的切换，用来实现ui中按钮功能 using System;using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.SceneManagement;public class SceneLoader&#123; public static void ReloadScene() &#123;//重开 int sceneIndex = SceneManager.GetActiveScene().buildIndex;//获取场景下标 SceneManager.LoadScene(sceneIndex);//切换为当前场景(重进) &#125; public static void QuitGame() &#123;//退出游戏 //如果在编辑器中运行#if UNITY_EDITOR UnityEditor.EditorApplication.isPlaying = false;//判断当前是否处于游戏状态#else Application.Quie();//退出应用#endif &#125; public static void LoadNextScene() &#123;//下一关 int sceneIndex = SceneManager.GetActiveScene().buildIndex + 1;//获取下一关场景下标 if (sceneIndex &gt;= SceneManager.sceneCount) &#123;//如果下标大于场景总数 ReloadScene();//返回当前关 return; &#125; SceneManager.LoadScene(sceneIndex);//切换为下一关 &#125;&#125; UI中新建DefeatScreen同名脚本 OnEnable和OnDisable中订阅、退订按钮功能。 PlayerShot中实现随机播放失败bgm。这里有个问题，我在玩家失败状态类中实现这个功能的时候，最终运行时音效呈现的效果是若干音乐叠加 而且音调更低，排查了很久找不到原因，所以我把这个功能改成了动画事件触发。动画里事件大概在这个位置 using System;using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class DefeatScreen : MonoBehaviour&#123; [SerializeField] VoidEventChannel playerDefeatedEventChannel;//获取事件频道 [SerializeField] AudioClip[] voice;//加油音效合集 [SerializeField] Button retryButton; [SerializeField] Button quitButton; private void OnEnable() &#123; playerDefeatedEventChannel.AddListener(ShowUI);//订阅展示ui函数 retryButton.onClick.AddListener(SceneLoader.ReloadScene);//订阅重置按钮功能 quitButton.onClick.AddListener(SceneLoader.QuitGame);//订阅退出按钮功能 &#125; private void OnDisable() &#123; playerDefeatedEventChannel.RemoveListener(ShowUI); retryButton.onClick.RemoveListener(SceneLoader.ReloadScene); quitButton.onClick.RemoveListener(SceneLoader.QuitGame); &#125; private void ShowUI() &#123; GetComponent&lt;Canvas&gt;().enabled = true; GetComponent&lt;Animator&gt;().enabled = true; Cursor.lockState = CursorLockMode.None;//显示鼠标光标 &#125; void PlayerShot() &#123; AudioClip retryVoice = voice[UnityEngine.Random.Range(0, voice.Length)];//随机播放加油音效 //游戏错误失败音效 许可:CC-BY 作者:GabrielAraujo 来源:耳聆网 https://www.ear0.com/sound/13207 SoundEffectsPlayer.audioSource.PlayOneShot(retryVoice);//播放音效 &#125;&#125;","categories":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/categories/unity/"}],"tags":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/tags/unity/"},{"name":"平台跳跃控制器","slug":"平台跳跃控制器","permalink":"https://niaoyu00.github.io/Blog/tags/%E5%B9%B3%E5%8F%B0%E8%B7%B3%E8%B7%83%E6%8E%A7%E5%88%B6%E5%99%A8/"}]},{"title":"平台游戏控制器之开始结束画面","slug":"平台游戏控制器之开始结束画面","date":"2022-09-21T08:58:51.000Z","updated":"2022-10-02T19:51:57.598Z","comments":true,"path":"2022/09/21/平台游戏控制器之开始结束画面/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/09/21/%E5%B9%B3%E5%8F%B0%E6%B8%B8%E6%88%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B%E5%BC%80%E5%A7%8B%E7%BB%93%E6%9D%9F%E7%94%BB%E9%9D%A2/","excerpt":"","text":"说明:开始游戏时播放ui动画,放完后摧毁红色闸门。游戏结束时(吃完红宝石)，弹出用时、结束画面。 开始画面开始时ReadyScreen对象的Canvas和Animator组件默认为开启。 在ReadyScreen对象下新建同名脚本ReadyScreen，拖入脚本化对象VoidEventChannel： ui关闭时调用委托(关门)，并且隐藏Canvas和Animator，播放音效。 public class ReadyScreen : MonoBehaviour&#123; [SerializeField] VoidEventChannel levelStartedEventChannel;//获取事件频道 [SerializeField] AudioClip beginSFX;//开始音效 private void CloseUI() &#123; levelStartedEventChannel.Broadcast();//调用委托 GetComponent&lt;Canvas&gt;().enabled = false; GetComponent&lt;Animator&gt;().enabled = false; SoundEffectsPlayer.audioSource.PlayOneShot(beginSFX);//播放音效 &#125;&#125; 接下来是添加动画事件 动画器中选中最后一帧，添加事件 选择该ui上脚本里的函数CloseUI(),当动画执行到此就会运行该函数。 记得在闸门(StartGate)上添加Gate脚本 附加上对应的脚本化文件。 因此实现通过动画事件，隐藏ui、播放开始动画、移除闸门等操作。 结束画面与上面原理相同，流程：吃到红宝石游戏结束，弹出游戏结束画面。 红宝石中的同名脚本VitoryGem中，获取事件频道，触发函数时调用委托。 using UnityEngine;public class VitoryGem : MonoBehaviour&#123; [SerializeField] AudioClip pickUpSound;//音效 [SerializeField] ParticleSystem pickUpVFX;//特效 [SerializeField] VoidEventChannel levelClearedEventChannel;//获取事件频道 private void OnTriggerEnter(Collider other) &#123; levelClearedEventChannel.Broadcast();//调用委托 SoundEffectsPlayer.audioSource.PlayOneShot(pickUpSound); Instantiate(pickUpVFX, transform.position, Quaternion.identity); Destroy(gameObject);//摧毁 &#125;&#125; VictoryScreen对象(UI)创建同名脚本VictoryScreen VictoryScreen默认Canvas和Animator为隐藏 在ShowUI函数中开启显示Canvas和Animator组件。 using UnityEngine;public class VictoryScreen : MonoBehaviour&#123; [SerializeField] VoidEventChannel levelClearedEventChannel;//获取事件频道 private void OnEnable() &#123; levelClearedEventChannel.AddListener(ShowUI); &#125; private void OnDisable() &#123; levelClearedEventChannel.RemoveListener(ShowUI); &#125; private void ShowUI() &#123; GetComponent&lt;Canvas&gt;().enabled = true; GetComponent&lt;Animator&gt;().enabled = true; &#125;&#125;","categories":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/categories/unity/"}],"tags":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/tags/unity/"},{"name":"平台跳跃控制器","slug":"平台跳跃控制器","permalink":"https://niaoyu00.github.io/Blog/tags/%E5%B9%B3%E5%8F%B0%E8%B7%B3%E8%B7%83%E6%8E%A7%E5%88%B6%E5%99%A8/"}]},{"title":"平台跳跃控制器之宝石功能实现:delegate","slug":"平台跳跃控制器之宝石功能实现-delegate","date":"2022-09-20T06:24:56.000Z","updated":"2022-10-02T19:51:59.169Z","comments":true,"path":"2022/09/20/平台跳跃控制器之宝石功能实现-delegate/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/09/20/%E5%B9%B3%E5%8F%B0%E8%B7%B3%E8%B7%83%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B%E5%AE%9D%E7%9F%B3%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-delegate/","excerpt":"","text":"常规方法：通过委托联系宝石与门(观察者模式)流程是: 在宝石脚本中创建委托,并在碰撞函数中调用(Invoke()); 在门脚本中创建函数(Open())摧毁对象,并且订阅宝石中的委托。 当宝石碰撞，调用了委托，订阅委托的两个门就执行相应动作(摧毁)。 这个方法缺点是门与宝石耦合 给宝石添加委托event关键字:其他类不可使用&#x3D;,只可以+&#x3D;或-&#x3D; 碰撞事件函数中调用委托 给门添加Gate脚本写一个函数来销毁门 void Open() &#123; Destroy(gameObject); &#125; 获取gateTrigger实例并且 在**Onenable()**中订阅Open函数 引入Scriptable Object实现解耦 新建一个EventChannels文件夹并且创建VoidEventChannel脚本 将它继承于ScriptableObject,实现声明委托、调用、订阅、退订等操作。 using UnityEngine;[CreateAssetMenu(menuName = &quot;Data/EventChannels/VoidEventChannel&quot;, fileName = &quot;VoidEventChannel_&quot;)]public class VoidEventChannel : ScriptableObject&#123; event System.Action Delegate; public void Broadcast() &#123; Delegate?.Invoke();//调用委托 // 等价于如下代码 // if (Delegate!=null) // &#123; // Delegate.Invoke(); // &#125; &#125; public void AddListener(System.Action action) &#123; Delegate += action; &#125;//订阅 public void RemoveListener(System.Action action) &#123; Delegate -= action; &#125;//退订&#125; 在中Data文件夹中创建EventChannels文件夹，并创建VoidEventChannel_文件 门开关之类的命名为VoidEventChannel_GateTriggered 修改GateTrigger代码序列化获取VoidEventChannel可脚本化对象,注释定义委托代码,在触发器中调用VoidEventChannel中的调用委托函数。 using UnityEngine;public class GateTrigger : MonoBehaviour&#123; [SerializeField] AudioClip pickUpSound;//音效 [SerializeField] ParticleSystem pickUpVFX;//特效 [SerializeField] VoidEventChannel gateTriggeredEventChannel; // public event System.Action OpenDoor;//定义委托 private void OnTriggerEnter(Collider other) &#123; gateTriggeredEventChannel.Broadcast();//调用委托 SoundEffectsPlayer.audioSource.PlayOneShot(pickUpSound); Instantiate(pickUpVFX, transform.position, Quaternion.identity); Destroy(gameObject);//摧毁 &#125;&#125; 修改Gate代码序列化获取VoidEventChannel可脚本化对象，调用其中订阅和退订函数,意为委托执行时摧毁门。 using UnityEngine;public class Gate : MonoBehaviour&#123; [SerializeField] VoidEventChannel gateTriggeredEventChannel; private void OnEnable() &#123; //gateTrigger.OpenDoor += Open; gateTriggeredEventChannel.AddListener(Open); &#125; private void OnDisable() &#123; //gateTrigger.OpenDoor -= Open; gateTriggeredEventChannel.RemoveListener(Open); &#125; void Open() &#123; Destroy(gameObject); &#125;&#125; 配置GateTrigger和相对应的Gate拖入可视化脚本对象，VoidEventChannel 此时,拾取蓝宝石将会摧毁宝石和红门。","categories":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/categories/unity/"}],"tags":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/tags/unity/"},{"name":"平台跳跃控制器","slug":"平台跳跃控制器","permalink":"https://niaoyu00.github.io/Blog/tags/%E5%B9%B3%E5%8F%B0%E8%B7%B3%E8%B7%83%E6%8E%A7%E5%88%B6%E5%99%A8/"}]},{"title":"平台跳跃控制器之声音","slug":"平台跳跃控制器之声音","date":"2022-09-15T07:32:56.000Z","updated":"2022-10-02T19:51:07.953Z","comments":true,"path":"2022/09/15/平台跳跃控制器之声音/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/09/15/%E5%B9%B3%E5%8F%B0%E8%B7%B3%E8%B7%83%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B%E5%A3%B0%E9%9F%B3/","excerpt":"","text":"说明:红宝石和蓝宝石是一次性的,所以拾取后要摧毁音效对象，而黄宝石是需要重复利用的，不需要摧毁。 为了整体音效更好管理，新建一个SoundEffectsPlayer类,附加在SFX Player对象上,SFX Player对象上要有AudioSource组件。 public class SoundEffectsPlayer : MonoBehaviour&#123; public static AudioSource audioSource &#123; get; private set; &#125; private void Awake() &#123; audioSource = GetComponent&lt;AudioSource&gt;(); audioSource.playOnAwake = false; &#125;&#125; StarGem,黄色跳跃星星脚本中,注释掉AudioSource定义代码，播放音效改为调用SoundEffectsPlayer类中的AudioSource:SoundEffectsPlayer.audioSource.PlayOneShot(pickUpSFX);//播放音效 一次性宝石分别在红、蓝宝石组件上新建两个同名脚本:VitoryGem、GateTrigger 统一代码为:拾取时播放音效、特效。 public class GateTrigger : MonoBehaviour&#123; [SerializeField] AudioClip pickUpSound;//音效 [SerializeField] ParticleSystem pickUpVFX;//特效 private void OnTriggerEnter(Collider other) &#123; SoundEffectsPlayer.audioSource.PlayOneShot(pickUpSound); Instantiate(pickUpVFX, transform.position, Quaternion.identity); Destroy(gameObject);//摧毁 &#125;&#125; 红、蓝宝石不需要判断是否和玩家产生碰撞。通过碰撞物理层级来实现，限定两个宝石只和玩家产生碰撞 新建Player和Interactable层级 项目设置中，设置Interactable物理层级只和player碰撞。 玩家音效在PlayerController中添加音源组件 在跳跃、二段跳、落地等状态中添加音效（截图为跳跃状态，其他代码一样） 然后在编辑器中拖入各自的音频文件 添加背景音乐(Loop：循环播放，Play On Awake:开局自动播放) 调整音量在每个有创建AudioSource,的脚本中添加音量调整滑块 SoundEffectsPlayer: PlayerController: 效果：","categories":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/categories/unity/"}],"tags":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/tags/unity/"},{"name":"平台跳跃控制器","slug":"平台跳跃控制器","permalink":"https://niaoyu00.github.io/Blog/tags/%E5%B9%B3%E5%8F%B0%E8%B7%B3%E8%B7%83%E6%8E%A7%E5%88%B6%E5%99%A8/"}]},{"title":"游戏画面中查看debug:OnGUI","slug":"游戏画面中查看debug-OnGUI","date":"2022-09-14T13:25:05.000Z","updated":"2022-10-02T19:50:52.849Z","comments":true,"path":"2022/09/14/游戏画面中查看debug-OnGUI/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/09/14/%E6%B8%B8%E6%88%8F%E7%94%BB%E9%9D%A2%E4%B8%AD%E6%9F%A5%E7%9C%8Bdebug-OnGUI/","excerpt":"","text":"private void OnGUI() &#123; Rect rect = new Rect(200, 200, 200, 200);//显示位置 string msg = &quot;是否有跳跃缓冲:&quot; + HasJumpInputBuffer;//字符串 GUIStyle style = new GUIStyle();//自定义文本样式 style.fontSize = 20; style.fontStyle = FontStyle.Bold;//粗体 GUI.Label(rect, msg, style); &#125;","categories":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/categories/unity/"}],"tags":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/tags/unity/"},{"name":"OnGUI","slug":"OnGUI","permalink":"https://niaoyu00.github.io/Blog/tags/OnGUI/"}]},{"title":"平台跳跃控制器之预输入","slug":"平台跳跃控制器之预输入","date":"2022-09-14T09:27:07.000Z","updated":"2022-10-02T19:50:39.407Z","comments":true,"path":"2022/09/14/平台跳跃控制器之预输入/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/09/14/%E5%B9%B3%E5%8F%B0%E8%B7%B3%E8%B7%83%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B%E9%A2%84%E8%BE%93%E5%85%A5/","excerpt":"","text":"功能实现说明:未落地时按跳跃键,可被记录，并且落地后起跳。 降落状态，并且无法二段跳时，开启缓冲输入。 从降落到落地之间只要一直按着空格，落地后会立马跳起。 中间松开就会关闭缓冲输入。 落地后关闭缓冲输入。 PlayerInput中添加变量public bool HasJumpInputBuffer &#123; get; set; &#125; **onEnable()**函数中添加松开按键判定 private void OnEnable() &#123; //当玩家松开按键跳跃时 playerInputAction.GamePlay.Jump.canceled += delegate &#123; HasJumpInputBuffer = false;//松开按键关闭跳跃输入缓冲 &#125;; &#125; PlayerState_Fall脚本中添加输入缓冲 if (input.playerjump) &#123; if (player.CanAirJump) &#123;//当玩家可以跳跃时(吃到星星,测试时条件是落地后) stateMachine.SwitchState(typeof(PlayerState_AirJump)); return; &#125; input.HasJumpInputBuffer = true;//如果玩家不能二段跳,则开启动作预输入(输入缓冲) &#125; PlayerState_JumpUp脚本,**Enter()**中添加input.HasJumpInputBuffer = false;//关闭动作缓冲 PlayerState_Land,落地状态脚本,判定开启动作缓冲输入时也可跳跃 if (input.HasJumpInputBuffer || input.playerjump) &#123;//如果存在跳跃输入缓冲 //或者玩家按下空格起跳,则切换状态为跳跃 stateMachine.SwitchState(typeof(PlayerState_JumpUp)); &#125; 限制缓冲输入时长新建协程JumpInputBufferCoroutine,跳跃输入缓冲携程 IEnumerator JumpInputBufferCoroutine() &#123; //跳跃输入缓冲携程 HasJumpInputBuffer = true; yield return waitJumpInputBufferTime;//延迟0.5s HasJumpInputBuffer = false; &#125; 该协程写进一个方法用以别的类调用 public void SetJumpInputBufferTimer() &#123; StopCoroutine(nameof(JumpInputBufferCoroutine)); StartCoroutine(nameof(JumpInputBufferCoroutine)); &#125; 例如PlayerState_Fall状态中,将无限制缓冲输入时长改为长按0.5s失效 //若如果玩家不能二段跳,则开启动作预输入(输入缓冲) 携程 // input.HasJumpInputBuffer = true; input.SetJumpInputBufferTimer();","categories":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/categories/unity/"}],"tags":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/tags/unity/"},{"name":"平台跳跃控制器","slug":"平台跳跃控制器","permalink":"https://niaoyu00.github.io/Blog/tags/%E5%B9%B3%E5%8F%B0%E8%B7%B3%E8%B7%83%E6%8E%A7%E5%88%B6%E5%99%A8/"}]},{"title":"平台跳跃控制器之土狼时间","slug":"平台跳跃控制器之土狼时间","date":"2022-09-08T15:24:18.000Z","updated":"2022-10-02T19:51:00.444Z","comments":true,"path":"2022/09/08/平台跳跃控制器之土狼时间/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/09/08/%E5%B9%B3%E5%8F%B0%E8%B7%B3%E8%B7%83%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B%E5%9C%9F%E7%8B%BC%E6%97%B6%E9%97%B4/","excerpt":"","text":"土狼时间人物在地面&#x2F;平台边缘即将掉落的时候,仍有机会进行跳跃动作; 其原理是:在人物掉落判定时开始计时,在设置的土狼时间内,可以按键跳跃。 新建一个状态脚本PlayerState_CoyoteTime，大部分代码可复制PlayerState_Run。 从RUN状态转向CoyoteTime，首先关闭刚体重力(需要在PlayerController脚本中添加方法获取参数)，使角色在空中保持一段时间。状态结束再开启刚体重力。 其中包含的下落状态处理逻辑，因此可以将PlayerState_Run中浮空切换下落状态改为切换为PlayerState_CoyoteTime PlayerState_CoyoteTime.cs代码 using System.Collections;using System.Collections.Generic;using UnityEngine;[CreateAssetMenu(menuName = &quot;Data/StateMachine/PlayerState/CoyoteTime&quot;, fileName = &quot;PlayerState_CoyoteTime&quot;)]public class PlayerState_CoyoteTime : PlayerState&#123; [SerializeField] float runSpeed = 5f;//跑步速度 [SerializeField] float coyoteTime = 0.1f;//土狼时间持续时间 public override void Enter() &#123; base.Enter(); //取消刚体重力 player.SetUseGravity(false); &#125; public override void Exit() &#123; //结束,开启重力 player.SetUseGravity(true); &#125; public override void LogicUpdate() &#123; if (input.playerjump) &#123; //如果玩家按下空格起跳,则切换状态为跳跃 stateMachine.SwitchState(typeof(PlayerState_JumpUp)); &#125; if (StateDuration &gt; coyoteTime || !input.PlayerMove) &#123;//当玩家不进行移动操作,或土狼时间结束时,切换为掉落状态 stateMachine.SwitchState(typeof(PlayerState_Fall)); &#125; &#125; public override void PhysicUpdate() &#123; player.Move(runSpeed); &#125;&#125; PlayerController中新加的函数 public void SetUseGravity(bool value) &#123;//控制刚体重力开关 rigidBody.useGravity = value; &#125; PlayerState_Run中修改后的内容 if (!player.IsGrounded) &#123;//当玩家不在地面上时,切换为土狼时间状态 stateMachine.SwitchState(typeof(PlayerState_CoyoteTime)); &#125;","categories":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/categories/unity/"}],"tags":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/tags/unity/"},{"name":"平台跳跃控制器","slug":"平台跳跃控制器","permalink":"https://niaoyu00.github.io/Blog/tags/%E5%B9%B3%E5%8F%B0%E8%B7%B3%E8%B7%83%E6%8E%A7%E5%88%B6%E5%99%A8/"}]},{"title":"平台跳跃控制器之二段跳","slug":"平台跳跃控制器之二段跳","date":"2022-08-29T09:12:13.000Z","updated":"2022-10-02T19:50:45.570Z","comments":true,"path":"2022/08/29/平台跳跃控制器之二段跳/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/08/29/%E5%B9%B3%E5%8F%B0%E8%B7%B3%E8%B7%83%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B%E4%BA%8C%E6%AE%B5%E8%B7%B3/","excerpt":"","text":"总章中间漏了点，最近懒得补。干脆做到哪写到哪吧，有时间再整理。 跳跃在空中的状态是：跳起-&gt;下落; 跳起之后松开空格就是下落状态，所以二段跳逻辑我们写在下落状态中； 实现空中多段跳 新建一个空中跳跃状态(PlayerState_AirJump.cs),为他添加资产菜单(CreateAssetMenu); 空中跳跃的逻辑和普通跳跃一样,所以直接复制代码即可。重要的地方在于,我们需要给二段跳进行限制。 在PlayerController.cs中,新建属性CanAirJump,public bool CanAirJump &#123; get; set; &#125; = true;//控制空中跳跃能力的开关 在下落状态脚本PlayerState_Fall.cs中的**LogicUpdate()**函数里实现判断,当玩家可以跳跃时(吃到星星,测试时条件是落地后)切换状态: public override void LogicUpdate() &#123; if (player.IsGrounded) &#123;//当玩家接触到地面时,切换到落地状态 stateMachine.SwitchState(typeof(PlayerState_Land)); &#125; if (input.playerjump) &#123; if (player.CanAirJump) &#123;//当玩家可以跳跃时(吃到星星,测试时条件是落地后) stateMachine.SwitchState(typeof(PlayerState_AirJump)); &#125; &#125; &#125; 给跳跃添加粒子特效分别在两个跳跃状态新建[SerializeField] ParticleSystem jumpVFX;//粒子特效 实现吃星星增加跳跃次数首先将玩家控制器脚本PlayerController中,属性 public bool CanAirJump &#123; get; set; &#125;的ture赋值删除,不进行初始化.默认值为false; 其次在PlayerState_Land脚本中删除Enter()里,player.CanAirJump。 打开星星宝石预制体,创建脚本StarGem,内容如下:public class StarGem : MonoBehaviour&#123; //进入触发器 private void OnTriggerEnter(Collider other) &#123; //检测进入触发器的对象是否是玩家 if (other.TryGetComponent&lt;PlayerController&gt;(out PlayerController player)) &#123;//打开空中跳跃能力 player.CanAirJump = true; //Destroy(gameObject);不可直接摧毁宝石 &#125; &#125;&#125; 碰撞体配置,记得打开触发器 接下来实现星星宝石消失后延时恢复 public class StarGem : MonoBehaviour&#123;//进入触发器 [SerializeField] float resetTime = 2; MeshRenderer meshRenderer;//渲染器组件 new Collider collider;//碰撞器组件 WaitForSeconds waitResetTime; private void Awake() &#123; meshRenderer = GetComponentInChildren&lt;MeshRenderer&gt;(); collider = GetComponent&lt;Collider&gt;(); waitResetTime = new WaitForSeconds(resetTime); &#125; private void OnTriggerEnter(Collider other) &#123; //检测进入触发器的对象是否是玩家 if (other.TryGetComponent&lt;PlayerController&gt;(out PlayerController player)) &#123;//打开空中跳跃能力 player.CanAirJump = true; //Destroy(gameObject);不可直接摧毁宝石 meshRenderer.enabled = false;//关闭宝石的渲染器组件 collider.enabled = false;//关闭碰撞器组件 //Invoke(nameof(Reset), resetTime);//延时resetTime秒调用函数 StartCoroutine(ResetCoroutine());//启动延时携程 &#125; &#125; IEnumerator ResetCoroutine() &#123;//延时携程 yield return waitResetTime;//挂起等待resetTime秒 Reset();//实现功能 &#125; void Reset() &#123; meshRenderer.enabled = true;//关闭宝石的渲染器组件 collider.enabled = true;//关闭碰撞器组件 &#125;&#125; 给星星添加音效组件中添加Audio Source,在代码中添加拾取音效.图中已圈出 旋转星星using System.Collections;using System.Collections.Generic;using UnityEngine;public class AutoRotate : MonoBehaviour&#123; [SerializeField] Vector3 rotation; private void Update() &#123;//旋转 transform.Rotate(rotation * Time.deltaTime); &#125;&#125;","categories":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/categories/unity/"}],"tags":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/tags/unity/"},{"name":"平台跳跃控制器","slug":"平台跳跃控制器","permalink":"https://niaoyu00.github.io/Blog/tags/%E5%B9%B3%E5%8F%B0%E8%B7%B3%E8%B7%83%E6%8E%A7%E5%88%B6%E5%99%A8/"}]},{"title":"(转载)Cinemachine Camera部分讲解和使用","slug":"Cinemachine Camera详细讲解和使用","date":"2022-08-04T04:26:41.813Z","updated":"2022-10-02T19:50:18.023Z","comments":true,"path":"2022/08/04/Cinemachine Camera详细讲解和使用/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/08/04/Cinemachine%20Camera%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Cinemachine Camera转载自知乎用户:Ouroboros 文章地址:https://zhuanlan.zhihu.com/p/516625841 本篇节选了body部分 在阅读以下文章之前先了解以下概念 Pitch Axis：俯仰轴 Roll Axis：翻转轴 Yaw Axis：航向轴 这三个轴与x，y，z坐标轴不同概念 Body 打开Body组件界面有7种算法 以下图片出现黄色感叹号是因为Follow没有挂载跟随目标 Do nothing 选择该算法后，该虚拟相机的坐标不会移动更新，通常为静态镜头选择此算法或使用自定义脚本直接为相机位置设置动画。通常和LookAt配合使用，模拟固定位置的跟随镜头。 3rd Person Follow选择该算法后虚拟相机会自动跟随任务移动，就是常见的第三人称视角 变量 含义 Damping 阻尼系数，指摄像机向x,y,z轴三个方向移动反应速度，系数越小反应越快，系数越大反应越慢，可以通过调整三个不同方向轴的阻尼系数来实现不同的移动效果。 Shoulder Offset 相对于跟随目标原点的肩膀支点的位置。这个偏移量位于目标模型空间。 Vertical Arm Length 手相对于肩膀的垂直偏移量。当相机垂直旋转时，arm长度会影响跟踪目标在屏幕空间的偏移。 Camera Side 明确哪个位置是相机的肩膀（0-1，代表left，in-between，right三种状态） Camera Distance 相机的手部位置会被放置多远距离 Camera Collision Fiter 相机碰撞过滤器，相机会自动避免阻碍这些层。有以下成员：Nothing&#x2F;Everything&#x2F;default&#x2F;TransparentFX&#x2F;Ignore Raycast&#x2F;Water&#x2F;UI Ignore Tag 检测忽略的Tag Camera Radius 虚拟相机会尽量与遮挡物保持不低于这个距离。如果你看到由于较大的FOV导致相机穿透了遮挡物内部，可以适当增加这个值。 Framing Transposer​ 此虚拟相机本身算法将相机以固定的屏幕空间关系移动到跟随目标。您还可以指定偏移、阻尼和合成规则。Framing Transposer只改变相机在空间中的位置。它不会重新定向或以其他方式瞄准相机。 ​ Framing Transposer专为 2D 和正交相机而设计。但它也适用于透视相机和 3D 环境。 ​ 此算法首先沿相机 Z 轴移动相机，直到跟随目标与相机的 XY 平面处于所需距离。然后在其 XY 平面中移动相机，直到跟随目标位于相机屏幕上的所需点。 注意：Framing Transposer忽略 LookAt 目标 - 仅使用 Follow 目标。 如果Follow目标是Target Group，则可以使用其他属性来构建整个组。 面版 变量 含义 Tracked Object Offse 对跟随目标对象的偏移量（在目标-局部坐标中）。相机将尝试框定目标位置加上此偏移量的点。当目标原点不是目标点时，使用它来校正相机 Lookahead Time 根据目标的运动，调整虚拟相机与“跟随”目标的偏移量。Cinemachine预测目标在未来数秒之内到达的位置并提前设置Unity相机的位置。这个功能对微动的动画敏感，并且会放大噪点，导致非预期的相机抖动。如果不能接受目标运动时的相机抖动，减小这个属性可能会使相机动画更流畅。 Lookahead Smoothing 预测算法的平滑度。较大的值可以消除抖动但会使预测滞后。 Lookahead Ignore Y 如果选中，则忽略沿 Y 轴的移动以进行预测计算。 X ，Y，Z Damping 相机尝试保持 x ，y，z轴偏移的响应程度。小数字使相机更灵敏。数字越大，相机响应越慢。每个轴使用不同的设置可以产生广泛的相机行为。 Target Movement Only 如果启用此选项，则阻尼仅适用于目标的运动。相机旋转更改将绕过阻尼。 Screen X，Y 目标的水平，垂直屏幕位置。相机移动的结果是使目标处于此位置。 Camera Distance 沿摄像机Z轴与跟随目标保持的距离。 Dead Zone Width 当目标在此位置范围内时，不会水平移动相机 Dead Zone Height 当目标在此位置范围内时，不会垂直移动相机。 Dead Zone Depth 当跟随目标距离相机在此范围内时，不会沿其z轴移动相机。 Unlimited Soft Zone 如果选中，Soft Zone没有边界 Soft Zone Width 当目标处于此范围内时，会水平移动相机，将目标移回到Dead Zone中。Damping属性会影响摄像机的运动速度。 Soft Zone Height 当目标处于此范围内时，会垂直移动相机，将目标移回到Dead Zone中。Damping属性会影响摄像机的运动速度。 Bias X，Y Soft Zone的中心与目标位置的水平，垂直偏移。 Center On Active 选中时，虚拟相机激活时会将镜头中心对准物体。不选中时，虚拟相机会将目标物体放置在最近的dead zone边缘。 非常详细不用介绍了 Hard Lock To Target该算法实现虚拟相机和跟随目标使用相同位置。可以用作第一人称 Orbital Transposer这个算法支持相机和目标之间的可变相对位置关系。可以接受玩家的输入，动态的控制相机的位置。 Orbital Transposer引入了一个新的概念叫heading，代表了目标移动的方向或面朝的方向。Orbital Transposer会尝试移动相机，让镜头朝向heading的方向。默认情况下，相机的位置会在target的正后面。也可以通过Heading Bias属性设置。如果给Orbital Transposer添加了输入控制器，玩家就可以控制相机围绕目标旋转。可以设置为Input Manager中的轴，也可以直接用脚本控制。 当Recenter To Target Heading属性选中时，在没有输入时Orbital Transposer可以自动重新居中相机。 变量 含义 Binding Mode 解释虚拟摄像机与跟随目标的偏移时要使用的坐标空间。 Follow Offset 跟随目标时的位置偏移 X Damping 相机在X轴上移动的阻力系数。较小的值会使相机反应更快。较大的值会使相机的反应速度变慢。每个轴使用不同的设置可以制造出各种类型相机的行为。 绑定模式为Simple Follow With World Up时不可用。 Y Damping 相机尝试保持 y 轴偏移的响应速度。小数字使相机更灵敏。数字越大，相机响应越慢。 Z Damping 相机尝试保持 z 轴偏移的响应程度。小数字使相机更灵敏。数字越大，相机响应越慢。 Yaw Damping 相机在y轴旋转的阻力系数。较小的数字会使相机反应更快。较大的数字会使相机的反应速度变慢。每个轴使用不同的设置可以制造出各种类型相机的行为。Binding Mode为Lock to Target With World Up、Lock to Target No Roll、Lock to Target时可用。 Pitch Damping 相机在x轴旋转的阻力系数。较小的数字会使相机反应更快。较大的数字会使相机的反应速度变慢。 Binding Mode为Lock to Target No Roll、Lock to Target时可用。 Roll Damping 相机在z轴旋转的阻力系数。较小的数字会使相机反应更快。较大的数字会使相机的反应速度变慢。 Binding Mode为Lock to Target时可用。 Heading 指定如何计算跟随目标的航向。 Recenter To Target Heading Orbital Transposer __可选地自动将相机重新居中。选中__Recenter To Target Heading 后，Orbital Transposer 会自动将相机移回目标航向。您可以指定在检测到没有用户输入后要等待的时间长度以及重新定位的速度。 X Axis 航向控制。此处的设置控制相机响应玩家输入的行为。 Binding Mode Lock To Target On Assign：本地空间，相机被激活或target赋值时的相对位置。 Lock To Target With World Up：本地空间，保持相机y轴朝上，yaw和roll为0。 Lock To Target No Roll：本地空间，锁定到目标物体，roll为0。 Lock To Target：本地空间，锁定到目标物体 。 World Space：世界空间 。 Simple Follow With World Up：相对于目标的位置，使用相机的本地坐标系，保持相机y轴朝上。 Heading Definition：计算Follow朝向的方法 Position Delta 以根据上次更新和当前帧的目标位置差异来计算航向。 Velocity 以使用目标刚体的速度。 如果目标没有刚体组件，则恢复到位置增量。 Target Forward 以使用目标的本地 Forward 轴作为航向。 World Forward 以使用恒定的世界空间 Forward 作为航向。 Velocity Filter Strength：在定义中使用 Position Delta 或 Velocity 时控制速度的平滑。 Bias：相对于航向放置相机的轨道中的角度偏移。 以度为单位。 轴值为 0 会将相机放在此处。 Recenter To Target Heading Wait Time：如果在轴上没有检测到用户输入，相机会在重新定位之前等待这么长时间（以秒为单位）。 Recentering Time：重新自动定位居中的过程花费的时间. X Axis Value：当前值 Value Range ：值范围 Wrap：如果选中，则轴在 Min 和 Max 值之间形成一个循环。 Speed ：最大速度（Max Speed）或者最大增加速度（Input Value Gain） Accel Time ：加速到最高速度所需要的时间 Input Axis Name：在 Unity 输入管理器中指定的此轴的名称。 设置为空字符串以禁用此轴的自动更新。 Input Axis Value：玩家输入轴的值。值0表示没有输入。可以通过编写脚本控制 Invert：是否反转输入的值（取相反数） Tracked Dolly这个算法可以让相机沿预定路径移动（轨道相机）。使用Path Position属性来指定将虚拟相机放置在路径上的位置。需Follow目标移动。 使用Auto-Dolly模式将虚拟相机移动到路径上最接近Follow目标的位置。启用后，Auto-Dolly会自动将虚拟相机的位置移动到最接近目标的路径上的位置。 提示：使用Auto-Dolly模式时，一定要谨慎选择路径形状。在围绕某个点形成弧形的路径上可能会有问题。举一个极端的例子，考虑一条以Follow目标为中心的完美圆形路径。路径上最接近目标的点变得不稳定，因为圆形路径上的所有点都同样接近目标。在这种情况下，将Follow目标移动很小的距离会导致相机在轨道上移动很大的距离。 注意此算法一定要有Path 变量 含义 Path 相机移动的路径。此属性必须引用CinemachinePath或Cinemachine Smooth Path对象。 Path Position 沿路径放置相机的位置。直接给这个属性作动画或启用Auto-Dolly。这个值以Position Units指定的单位为单位。 Position Units 路径位置的度量单位。 Path Offset 相机相对于路径的位置。X 垂直于路径，Y 向上，Z 平行于路径。使用此属性可使相机偏离路径本身 X ，Y，Z Damping 相机尝试保持 x ，y，z轴偏移的响应程度。小数字使相机更灵敏。数字越大，相机响应越慢。每个轴使用不同的设置可以产生广泛的相机行为。 Camera Up 如何为虚拟摄像机设置向上矢量。这会影响屏幕构图，因为相机 Aim 算法尝试尊重向上方向。 Auto Dolly 控制自动轨道位置选择方式。要使用此功能，必须设置Follow目标。 Path Cinemachine中有两种Dolly Path组件： CinemachinePath组件：每个路径点都可以设置位置、切线和翻转角度，可以最大程度控制路径。但是如果切线设置的不合理，相机在路径上运动时可能会有不稳定的现象。 CinemachineSmoothPath组件：每个路径点都可以设置位置和翻转角度。组件中会使用Bezier算法来推算路径点之间的位置。虽然SmoothPath不能完全控制路径，但是整个路径会更平滑和连续。推荐优先使用。可以避免出现，尽管路径位置始终是平滑连续的，但沿路径设置动画时仍然可能会产生不稳定的现象。 额外扩展：什么是Bezier算法和Bezier曲线 Bezier曲线 怎么理解贝塞尔曲线? - 知乎 Bezier算法 详细的算法推导可以在上述链接中观看如何逐阶层运算各个阶的Bezier曲线。 Unity本身自带的CinemachineSmoothPath脚本源码，他们是定义一个世界空间路径，由一组路点组成，每个路点都有位置和滚动设置。Bezier 插值在航点之间执行，以获得平滑和连续的路径。 计算距离缓存时，对点之间的路径进行多次采样。路径将通过所有航路点，并且（与 CinemachinePath 不同）保证一阶和二阶连续性。 源码都是运算过程，大家可以自行观看。 如何创建Dolly Path 方法一：如果是在相机上制作路径动画，可以直接创建Dolly Camera。菜单栏Cinemachine &gt; Create Dolly Camera with Track。点击后会创建一个虚拟相机和dolly path。这个Path默认是SmoothPath。虚拟相机会自动设置好Body属性为Dolly Track并且Path属性赋值为创建出来的Dolly path。 方法二：如果是给GameObject制作路径动画，可以直接创建Dolly Cart。菜单栏Cinemachine &gt; Create Dolly Track With Cart。点击后会创建一个虚拟相机和DollyCart。这个Path默认是SmoothPath。只需要把做路径动画的物体作为Cart的子物体即可。 方法三：直接创建Dolly Path。创建一个空物体，给空物体添加CinemachinePath或CinemachineSmoothPath组件。 SmoothPath参数详解 Resolution： 每个路径点之间采样的次数。Cinemachine在计算路径距离时使用此值来限制粒度。场景视图中路径Gizmo上的交叉线反映了该值。 Appearance ：路径在场景中显示的外观。只在编辑器中生效。 Path Color ：选中路径时的颜色。 Inactive Path Color ：未选中路径的颜色。 Width ：路径轨道的宽度。 Looped ：选中后，路径会首尾相连。 Path Length ：整个路径长度，这个数据是只读的，根据所有路径点计算出来的。 Waypoints ：定义路径点的列表。 Position ：位置，在路径局部空间中的位置（即相对于路径GameObject本身的变换） Roll* ：翻转角度。朝向的其他轴方向是从切线和世界的向上向量推断出来的。 Dolly Cart参数 （只有Create Dolly Track With Cart才有）详解： 这是限制在 CinemachinePath的移动镜头。 它可用于为路径上的任何对象设置动画，或作为 Cinemachine 虚拟摄像机的跟随目标。这个组件就是把当前所附着的GameObject沿着path移动。 Speed ：移动物体的速度。基于Position Unit设置的单位。如果速度不为0，则小车会根据速度自动移动。 Position :当前物体所处的位置。基于Position Unit设置的单位 Position Units Path Units ：使用路径点的序号。比如0代表第一个路径点，1代表第二个路径点。 Distance ：使用路径的总长度。 Normalized： 归一化。0代表路径最开始的位置，1代表路径结束的位置。 Camera Up Default：不修改虚拟相机up方向，使用Cinemachine Brain的Override的World Up Path：使用路径当前的向上向量 Path No Roll：使用路径节点当前的向上向量，Roll*为0 Follow Target：使用跟随目标的向上向量 Follow Target No Roll：使用跟随目标的向上向量，Roll*为0 不要修改虚拟摄像机的向上方向。 相反，使用 Cinemachine Brain 中的 World Up Override 属性 Auto Dolly Enabled：选中使用自动dolly，注意：这对性能可能会有一些影响，却决于Search Resolution Position Offset：从路径最近点到跟随目标的偏移量 Search Radius：对当前路径点的n个单位点进行搜索，如果为0则为整条路径所有点 Search Resolution：Cinemachine 通过将片段分成许多直线来搜索片段。 数字越大，结果越准确。 但是，对于更高的数字，性能会成比例地变慢。 Transposer这个算法将虚拟相机的坐标与跟随目标的坐标有固定的偏移量来进行跟随，也可以使用Damping属性 简单来说就是虚拟相机跟目标会有固定的位置差偏移 根据BindingMode的不同选择会有不同参数的Damping可以调整 Binding Mode 各种模式可以参考上面Orbital Transposer 的详细介绍","categories":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/categories/unity/"}],"tags":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/tags/unity/"},{"name":"Cinemachine Camera","slug":"Cinemachine-Camera","permalink":"https://niaoyu00.github.io/Blog/tags/Cinemachine-Camera/"}]},{"title":"使用vscode开发unity项目","slug":"使用vscode开发unity项目","date":"2022-07-12T07:13:27.785Z","updated":"2022-10-02T19:48:47.834Z","comments":true,"path":"2022/07/12/使用vscode开发unity项目/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/07/12/%E4%BD%BF%E7%94%A8vscode%E5%BC%80%E5%8F%91unity%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"仅做记录 vscode需要的插件如下： Auto-Using for C#，自动添加引用 Unity Code Snippets，unity代码补全 c#，必备 C# XML Documentation Comments，三下&#x2F;&#x2F;&#x2F;实现xm注释l Code Runner，运行代码 GitHub Theme；eppz! (C# theme for Unity)；Gruvbox Theme；（三款编辑器皮肤 期间会提示安装.net framework，sdk包。 vscode字体设置:“editor.fontFamily”: “Fira Code Medium, ‘Courier New’, monospace” unity中打开edit-&gt;Preferences-&gt;External Tools,选中vscode，记得勾选下面前两行。","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://niaoyu00.github.io/Blog/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/tags/unity/"},{"name":"VsCode","slug":"VsCode","permalink":"https://niaoyu00.github.io/Blog/tags/VsCode/"}]},{"title":"unity平台跳跃控制器","slug":"unity平台跳跃控制器","date":"2022-07-08T06:59:54.828Z","updated":"2022-10-12T14:18:30.958Z","comments":true,"path":"2022/07/08/unity平台跳跃控制器/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/07/08/unity%E5%B9%B3%E5%8F%B0%E8%B7%B3%E8%B7%83%E6%8E%A7%E5%88%B6%E5%99%A8/","excerpt":"","text":"教程来自b站阿严:https://www.bilibili.com/video/BV1rL4y1W7KH 成果展示: 【[unity]平台跳跃类demo】 https://www.bilibili.com/video/BV1AK411Q7ry?share_source=copy_web&amp;vd_source=644eac695af0d52dcffdec474d1423b1 一 项目的创建和管理插件 删除不需要的插件，安装需要的插件，删除后插件内容： 1.1 安装： Cinemachine，虚拟相机插件。 Post Processing，后处理插件。 Input System，新的输入系统插件。 1.2 安装完成后图: 1.3 导入资源包这里我使用的是自己在unity商店买的资源包，替换了unity酱，想要做点不一样的。 二 状态机系统创建接口文件和状态机类 2.1 Istate接口using System.Collections;using System.Collections.Generic;using UnityEngine;public interface IState&#123; void Enter();//状态进入 void Exit();//状态退出 void LogicUpdate();//状态逻辑更新 void PhysicUpdate();//状态物理更新&#125; 2.2 StateMachine类作用: 持有所有状态,并且进行管理和切换; 负责当前状态的更新. using System.Collections;using System.Collections.Generic;using UnityEngine;public class StateMachine : MonoBehaviour&#123; //1、持有所有状态,并且进行管理和切换;2、负责当前状态的更新 IState currentState; void Update() &#123; //更新状态逻辑 currentState.LogicUpdate(); &#125; void FixedUpdate() &#123; //更新物理 currentState.PhysicUpdate(); &#125; protected void SwitchOn(IState newState) &#123;//状态开启 //新状态赋值给当前状态,然后启动 currentState = newState; currentState.Enter(); &#125; public void SwitchState(IState newState) &#123;//切换状态 //先关闭状态,然后新状态赋值给当前状态,启动 currentState.Exit(); SwitchOn(newState); &#125;&#125; 三 扩展状态机系统创建PlayerStates(玩家状态)并初始化 using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerState : ScriptableObject, IState&#123;//玩家状态类 Animator animator;//动画器 PlayerStateMachine stateMachine;//玩家状态机类 public void Initialize(Animator animator, PlayerStateMachine stateMachine) &#123; this.animator = animator; this.stateMachine = stateMachine; &#125; public virtual void Enter() &#123; &#125; public virtual void Exit() &#123; &#125; public virtual void LogicUpdate() &#123; &#125; public virtual void PhysicUpdate() &#123; &#125;&#125; PlayerStatesMachine(玩家状态机) using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerStateMachine : StateMachine&#123;//玩家状态机 Animator animator; private void Awake() &#123; animator = GetComponentInChildren&lt;Animator&gt;(); //可以在此初始化 玩家状态 &#125;&#125; 3.1 状态机系统继承关系图 3.2 使用两种方法实现角色动画3.2.1、常规方法(不使用状态机)构建基础状态机系统,创建动画控制器 拖到玩家对象 将动画拖入控制器 更改默认状态 然后在player对象添加玩家控制器脚本 需求分析: 按下A&#x2F;D键时播放跑步动画 松开按键回到空闲动画 实现方式： 获取键盘的输入信号(Input System) 播放特定动画(Animator) PlayerController代码如下： using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.InputSystem;public class PlayerController : MonoBehaviour&#123; Animator animator; private void Awake() &#123; animator = GetComponentInChildren&lt;Animator&gt;();//获取动画控制组件 &#125; void Update() &#123; //按住当前键盘的a或者d键 //if(Input.GetKey(KeyCode.A)|| Input.GetKey(KeyCode.D)) if (Keyboard.current.aKey.isPressed || Keyboard.current.dKey.isPressed) &#123; animator.Play(&quot;Run&quot;);//播放动画器中特定动画 &#125; else//松开按键时 &#123; animator.Play(&quot;Idle&quot;); &#125; &#125;&#125; 并且同时更改动画器中动画的名字，以匹配代码中的命名 全部改完效果如图： 3.2.2、通过状态机实现动画状态切换首先将状态机脚本添加到玩家上 其次在Player State文件夹中创建idle和run状态脚本 皆继承于PlayerState [CreateAssetMenu(menuName = &quot;Data/StateMachine/PlayerState/Idle&quot;, fileName = &quot;PlayerState_Idle&quot;)] 这条代码将代码暴露在编辑器中，可在文件夹中创建可程序化对象文件 举例PlayerState_Idle代码如下: 重写状态函数,更新状态 using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.InputSystem;[CreateAssetMenu(menuName = &quot;Data/StateMachine/PlayerState/Idle&quot;, fileName = &quot;PlayerState_Idle&quot;)]public class PlayerState_Idle : PlayerState&#123; public override void Enter() &#123; animator.Play(&quot;Idle&quot;); &#125; public override void LogicUpdate() &#123; if (Keyboard.current.aKey.isPressed || Keyboard.current.dKey.isPressed) &#123; stateMachine.SwitchState(stateMachine.runState); &#125; &#125;&#125; PlayerState_Idle脚本代码同理。 状态机模式将不同状态分开来处理,这个模式中只需要思考,当前状态如何切换到下一状态,而不再需要同时考虑另一个状态的逻辑问题。 (例如需要落地后才可起跳，常规方法需要使用很多Boolean值来判断状态，而状态机模式只需要在各自状态中实现切换即可) 3.3 状态机模式优缺点优点 逻辑分开到各个状态中处理，不需要考虑状态之间的约束，让思路更清楚。 代码性能提升 缺点 文件数量增加 代码重复 3.4 继续完善状态机功能打开玩家状态机脚本PlayerStateMachine 目前所有新状态都需要新建初始化,是否可以声明一个鸡和然后将所有状态都扔进去呢?当然可以。 首先修改玩家状态机类的代码，(注释中是原代码) 我们新建一个states数组，通过遍历获取玩家具体状态。 using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerStateMachine : StateMachine&#123;//玩家状态机 Animator animator; //public PlayerState_Idle idleState; //public PlayerState_Run runState; [SerializeField] PlayerState[] states;//持有所有状态 private void Awake() &#123; animator = GetComponentInChildren&lt;Animator&gt;(); //可以在此初始化 玩家状态 //idleState.Initialize(animator, this); //runState.Initialize(animator, this); foreach (PlayerState state in states) &#123; state.Initialize(animator, this); &#125; &#125; private void Start() &#123; SwitchOn(【idleState】);//默认idle，【idleState】报错，需要通过字典 &#125;&#125; 这么做idleState会出现报错， 这时需要在父类创建字典，声明一个键为System.Type值为IState类型的字典 然后在玩家状态机类PlayerStateMachine中的状态遍历循环中，给它赋值。 最后就可以通过键来获取状态。以下是父类，也就是状态+6机类StateMachine中代码： using System.Collections;using System.Collections.Generic;using UnityEngine;public class StateMachine : MonoBehaviour&#123; //1、持有所有状态,并且进行管理和切换;2、负责当前状态的更新 IState currentState; //新建一个 键为System.Type 值为IState类型的字典 protected Dictionary&lt;System.Type, IState&gt; stateTbale; void Update() &#123; //更新状态逻辑 currentState.LogicUpdate(); &#125; void FixedUpdate() &#123; //更新物理 currentState.PhysicUpdate(); &#125; protected void SwitchOn(IState newState) &#123;//状态开启 //新状态赋值给当前状态,然后启动 currentState = newState; currentState.Enter(); &#125; public void SwitchState(IState newState) &#123;//切换状态 //先关闭状态,然后新状态赋值给当前状态,启动 currentState.Exit(); SwitchOn(newState); &#125;&#125; 接着在玩家状态机类awake()中初始化，更改后的玩家状态机类代码如下： using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerStateMachine : StateMachine&#123;//玩家状态机 Animator animator; //public PlayerState_Idle idleState; //public PlayerState_Run runState; [SerializeField] PlayerState[] states;//持有所有状态 private void Awake() &#123; //获取动画 animator = GetComponentInChildren&lt;Animator&gt;(); //字典长度为状态数组长度 stateTbale = new Dictionary&lt;System.Type, IState&gt;(states.Length); //可以在此初始化 玩家状态 //idleState.Initialize(animator, this); //runState.Initialize(animator, this); foreach (PlayerState state in states) &#123; state.Initialize(animator, this); stateTbale.Add(state.GetType(), state);//朝字典添加数据 &#125; &#125; private void Start() &#123; Debug.Log(typeof(PlayerState_Idle)); //在字典中传入PlayerState_Idle的类型 //默认idle SwitchOn(stateTbale[typeof(PlayerState_Idle)]); &#125;&#125; 接着会遇到两个报错：PlayerState_Run和PlayerState_Idle类中的状态切换里的变量不存在了。 我们需要回到状态机主类StateMachine，重载状态切换函数SwitchState。将变量类型改为字典需要的键(System.Type类)对比如下: public void SwitchState(IState newState) &#123;//切换状态 //先关闭状态,然后新状态赋值给当前状态,启动 currentState.Exit(); SwitchOn(newState); &#125; public void SwitchState(System.Type newStateType) &#123;//切换状态 //通过字典获取状态，再调用上面那个SwitchState()； SwitchState(stateTbale[newStateType]); &#125; 这样在报错的PlayerState_Run和PlayerState_Idle中修改相应的变量即可： stateMachine.SwitchState(runState); 改成了 stateMachine.SwitchState(typeof(PlayerState_Run)); using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.InputSystem;[CreateAssetMenu(menuName = &quot;Data/StateMachine/PlayerState/Idle&quot;, fileName = &quot;PlayerState_Idle&quot;)]public class PlayerState_Idle : PlayerState&#123; public override void Enter() &#123; animator.Play(&quot;Idle&quot;); &#125; public override void LogicUpdate() &#123; if (Keyboard.current.aKey.isPressed || Keyboard.current.dKey.isPressed) &#123; stateMachine.SwitchState(typeof(PlayerState_Run)); &#125; &#125;&#125; 四 Input System输入系统 如果需要某个功能对应不同按键都可触发,使用InputSystem会更加方便。不使用输入系统的话需要多个判断语句实现。 4.1 新建Input Actions命名为PlayerInputActions,玩家输入动作 4.1.1、创建移动动作新建GamePlay动作表,重命名动作名为Axes 轴。右边动作类型选value，值类型选二维向量 删除默认的按键，添加预设的上下左右 通过listen绑定按键 手柄和键盘的模式都改成digital，这样手柄将和键盘一样xy取值只有0,-1,1 4.1.2、创建跳跃动作 记得保存资产 4.1.3、生成c#文件更改文件位置 4.2 初始化玩家输入4.2.1、新建脚本PlayerInput 玩家输入类，并且添加到player对象中。using UnityEngine;public class PlayerInput : MonoBehaviour&#123;//玩家输入类 PlayerInputActions playerInputAction;//inputsystem生成的c#文件 public bool PlayerMove =&gt; AxisX != 0f;//通过判断x轴是否为0,判断是否移动 //获取轴的值 x,y Vector2 axes =&gt; playerInputAction.GamePlay.Axes.ReadValue&lt;Vector2&gt;(); public float AxisX =&gt; axes.x; //WasPressedThisFrame()是否按下 public bool playerjump =&gt; playerInputAction.GamePlay.Jump.WasPressedThisFrame(); //WasReleasedThisFrame()是否松开按键 public bool playerstopJump =&gt; playerInputAction.GamePlay.Jump.WasReleasedThisFrame(); private void Awake() &#123; playerInputAction = new PlayerInputActions();//初始化 &#125; public void EnableGameplayInputs() &#123; //启用gameplay动作表（inputsystem中自带的方法，通过.GamePlay.Enable()启动） playerInputAction.GamePlay.Enable(); Cursor.lockState = CursorLockMode.Locked;//鼠标设置为锁定模式 &#125;&#125; 4.2.2、更改PlayerState 玩家状态脚本，加入玩家输入 初始化using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerState : ScriptableObject, IState&#123;//玩家状态类 protected Animator animator;//动画器 protected PlayerInput input;//玩家输入类 protected PlayerStateMachine stateMachine;//玩家状态机类 public void Initialize(Animator animator, PlayerInput input, PlayerStateMachine stateMachine) &#123; //初始化状态动画,玩家输入类，玩家状态机 this.animator = animator; this.input = input; this.stateMachine = stateMachine; &#125; public virtual void Enter() &#123; &#125; public virtual void Exit() &#123; &#125; public virtual void LogicUpdate() &#123; &#125; public virtual void PhysicUpdate() &#123; &#125;&#125; 4.2.3、修改PlayerState_Idle和PlayerState_Run脚本因为在PlayerInput中,新建了一个变量表示玩家是否移动。原来判断玩家是否在移动的语句优化如下： 旧版通过检测按键a或者d判断: if (Keyboard.current.aKey.isPressed || Keyboard.current.dKey.isPressed) 新版判断输入事件x轴是否为0，得出玩家是否正移动: if (input.PlayerMove) 4.2.4、在PlayerStateMachine 玩家状态机类中初始化玩家输入部分代码如下： PlayerInput input;//玩家输入 private void Awake() &#123; //获取动画 animator = GetComponentInChildren&lt;Animator&gt;(); //获取玩家输入 input = GetComponent&lt;PlayerInput&gt;(); //字典长度为状态数组长度 stateTbale = new Dictionary&lt;System.Type, IState&gt;(states.Length); //可以在此初始化 玩家状态 //idleState.Initialize(animator, this); //runState.Initialize(animator, this); foreach (PlayerState state in states) &#123; state.Initialize(animator, input, this); stateTbale.Add(state.GetType(), state);//朝字典添加数据 &#125; &#125; 4.2.5、在PlayerController 玩家控制器类中添加玩家输入，并且启用动作表public class PlayerController : MonoBehaviour&#123; //玩家控制器 PlayerInput input;//玩家输入类 private void Awake() &#123; input = GetComponent&lt;PlayerInput&gt;();//获取对象 &#125; private void Start() &#123; input.EnableGameplayInputs();//启用动作表 &#125;#region 常规方法(不使用状态机)...&#125; 五 玩家移动、转向5.1 玩家移动功能实现分析:通过刚体模拟物体运动，需要获取player身上的刚体组件。 将玩家移动功能写在PlayerController玩家控制器脚本中。 新建刚体变量，获取实例，创建了三个改变刚体速度的函数 using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.InputSystem;public class PlayerController : MonoBehaviour&#123;//玩家控制器 PlayerInput input;//玩家输入类 Rigidbody rigidBody;//刚体类引用变量 private void Awake() &#123; input = GetComponent&lt;PlayerInput&gt;();//获取对象实例 rigidBody = GetComponent&lt;Rigidbody&gt;();//获取刚体组件实例 &#125; private void Start() &#123; input.EnableGameplayInputs();//启用动作表 &#125; public void SetVelocity(Vector3 velocity) &#123; //直接修改刚体速度 rigidBody.velocity = velocity; &#125; public void SetVelocityX(float velocityX) &#123; //将刚体x轴的速度设置为参数的值,y不变。左右移动 rigidBody.velocity = new Vector3(velocityX, rigidBody.velocity.y); &#125; public void SetVelocityY(float velocityY) &#123; //将刚体y轴的速度设置为参数的值,x不变。跳跃或者下落 rigidBody.velocity = new Vector3(rigidBody.velocity.x, velocityY); &#125; #region 常规方法(不使用状态机)...&#125; PlayerState 玩家状态类中添加玩家控制器类，并初始化(部分代码) protected PlayerController player;//玩家控制器public void Initialize(PlayerController player, Animator animator, PlayerInput input, PlayerStateMachine stateMachine) &#123; //初始化玩家控制器，状态动画,玩家输入类，玩家状态机 this.player = player; this.animator = animator; this.input = input; this.stateMachine = stateMachine; &#125; PlayerStateMachine 玩家状态机类一起更新 using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerStateMachine : StateMachine&#123;//玩家状态机 Animator animator;//动画 PlayerInput input;//玩家输入 PlayerController playerController;//玩家状态机 [SerializeField] PlayerState[] states;//持有所有状态 private void Awake() &#123; //获取动画 animator = GetComponentInChildren&lt;Animator&gt;(); //获取玩家输入 input = GetComponent&lt;PlayerInput&gt;(); //获取玩家控制器 playerController = GetComponent&lt;PlayerController&gt;(); //字典长度为状态数组长度 stateTbale = new Dictionary&lt;System.Type, IState&gt;(states.Length); //可以在此初始化 玩家状态 //idleState.Initialize(animator, this); //runState.Initialize(animator, this); foreach (PlayerState state in states) &#123; state.Initialize(playerController, animator, input, this); stateTbale.Add(state.GetType(), state);//朝字典添加数据 &#125; &#125; private void Start() &#123; //Debug.Log(typeof(PlayerState_Idle)); //在字典中传入PlayerState_Idle的类型 //默认idle SwitchOn(stateTbale[typeof(PlayerState_Idle)]); &#125;&#125; 在PlayerState_Run 跑步状态脚本中**重写PhysicUpdate()**方法实现玩家移动 using System.Collections;using System.Collections.Generic;using UnityEngine;[CreateAssetMenu(menuName = &quot;Data/StateMachine/PlayerState/Run&quot;, fileName = &quot;PlayerState_Run&quot;)]public class PlayerState_Run : PlayerState&#123; [SerializeField] float runSpeed = 5f;//跑步速度 public override void Enter() &#123; animator.Play(&quot;Run&quot;); &#125; public override void LogicUpdate() &#123; if (!input.PlayerMove) &#123;//if玩家没移动输入 则切换状态为idle stateMachine.SwitchState(typeof(PlayerState_Idle)); &#125; &#125; public override void PhysicUpdate() &#123; player.SetVelocityX(runSpeed); &#125;&#125; 新建变量runSpeed 跑步速度 将它序列化，已暴露在编辑器中，至此移动功能实现。 5.2 玩家转向5.2.1、通过镜像翻转改变玩家朝向首先在PlayerController 玩家控制器中增加Move(), 通过更改Player的localScale的属性x轴正负(对应axisX轴)值,同步修改角色朝向。 左右移动功能使用速度x方向 然后修改PlayerState_Run中**PhysicUpdate()**函数 player.SetVelocityX(runSpeed);改为player.Move(runSpeed); 新的比旧的多了转向功能。 5.5.2、停止移动**PlayerState_Idle类Enter()**中新加一条代码player.SetVelocityX(0f);x轴速度归零 5.3 玩家加速和减速5.3.1、实现玩家加速在玩家控制器中添加一个方法,获取玩家移速。 打开玩家状态类声明浮点型变量currentSpeed，当前速度 修改PlayerState_Run脚本,新增变量acceration加速度，Enter()中获取当前速度，LogicUpdate()中新增缓慢加速的算法。 using System.Collections;using System.Collections.Generic;using UnityEngine;[CreateAssetMenu(menuName = &quot;Data/StateMachine/PlayerState/Run&quot;, fileName = &quot;PlayerState_Run&quot;)]public class PlayerState_Run : PlayerState&#123; [SerializeField] float runSpeed = 5f;//跑步速度 [SerializeField] float acceration = 10f;//加速度 public override void Enter() &#123; animator.Play(&quot;Run&quot;); currentSpeed = player.MoveSpeed;//获取当前速度 &#125; public override void LogicUpdate() &#123; if (!input.PlayerMove) &#123;//if玩家没移动输入 则切换状态为idle stateMachine.SwitchState(typeof(PlayerState_Idle)); &#125; //从当前速度到指定速度之间随着acceration加速度增加。 currentSpeed = Mathf.MoveTowards(currentSpeed, runSpeed, acceration * Time.deltaTime); &#125; public override void PhysicUpdate() &#123; //player.Move(runSpeed); player.Move(currentSpeed); &#125;&#125; 5.3.2、实现玩家减速修改PlayerState_Idle脚本，新增变量deceleration表示减速加速度，Enter()中记录当前速度，LogicUpdate()中新增缓慢减速算法。重写PhysicUpdate()方法设置减速。 using System.Collections;using System.Collections.Generic;using UnityEngine;[CreateAssetMenu(menuName = &quot;Data/StateMachine/PlayerState/Idle&quot;, fileName = &quot;PlayerState_Idle&quot;)]public class PlayerState_Idle : PlayerState&#123; [SerializeField] float deceleration = 5f; public override void Enter() &#123; animator.Play(&quot;Idle&quot;);//播放动画器里的idle动画 //player.SetVelocityX(0f);//x轴速度归零 currentSpeed = player.MoveSpeed;//记录当前速度 &#125; public override void LogicUpdate() &#123; if (input.PlayerMove) &#123;//判断是否移动 stateMachine.SwitchState(typeof(PlayerState_Run)); &#125; //减速 currentSpeed = Mathf.MoveTowards(currentSpeed, 0, deceleration * Time.deltaTime); &#125; public override void PhysicUpdate() &#123; //因为已停止移动 所以不能用Move()，并且需要获取玩家朝向layer.transform.localScale.x player.SetVelocityX(currentSpeed * player.transform.localScale.x); &#125;&#125; 5.4 相机跟随玩家使用Cinemachine虚拟相机插件实现。 新建虚拟相机命名为Virtual Camera Player Follow， 拖到Cameras下。 提前重置两个相机位置，然后将player拖到follow槽中 取消勾选Aim选项，这个是用作瞄准用的。 将body机身改成Framing Transposer取景器 调试参数，选中这个，在试玩时做的操作也会保存 六 优化改进动画播放PlayerState玩家状态脚本中新增三条属性 分别用来获取状态动画名称、动画切换时间、声明int类型哈希值。 onenable()中，将获取的字符串转哈希值（哈希值占用资源少）。 Enter()中，使用animator.crossFade()过渡动画，淡入淡出效果。 参数1：字符串或者哈希值，参数2：持续时间。 玩家状态PlayerState_Idle和PlayerState_Run中的animator.Play()改为base.Enter();继承父类 回到编辑器中只需要在可视化脚本中输入动画名即可. 七 玩家跳跃功能7.1 地面检测要实现跳跃功能，首先要检测地面。 在Player对象下的Ground Detector空对象中添加新的脚本：PlayerGroundDetector 玩家地面检测器 代码如下: using System.Diagnostics;using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerGroundDetector : MonoBehaviour&#123; [SerializeField] float detectionRadius = 0.1f;//检测半径 [SerializeField] LayerMask groundLayer;//层级 Collider[] colliders = new Collider[1];//碰撞数组 //Physics.OverlapSphereNonAlloc 检测碰撞个数,不触发回收机制 判断如不为0则返回true //IsGrounded:可以判断玩家是否在地面 public bool IsGrounded =&gt; Physics.OverlapSphereNonAlloc(transform.position, detectionRadius, colliders,groundLayer) != 0; //OnDrawGizmosSelected():系统提供的方法,不是自己建的。 void OnDrawGizmosSelected() &#123;//在编辑器中展示 方便调试 Gizmos.color = Color.green; Gizmos.DrawWireSphere(transform.position, detectionRadius); &#125;&#125; 在PlayerController 玩家控制器脚本中新增代码,以使用玩家地面检测器的参数. 新增内容: PlayerGroundDetector groundDetector;//玩家地面检测//获取地面检测结果public bool IsGrounded =&gt; groundDetector.IsGrounded;//true 为已接触//判断玩家是否为正在下落,下落时刚体的y速度为负数,并且需要未落地.public bool IsFalling =&gt; rigidBody.velocity.y &lt; 0f &amp;&amp; !IsGrounded; 7.2 检测当前播放动画是否完成需要获取:1.动画播放开启的时间;2.当前状态持续时长;3.动画自身播放时长 打开玩家状态脚本 PlayerState,新增代码. float stateStartTime;//状态开始时间 //动画是否播放完毕,通过判断 [当前状态的持续时间]是否大于等于[动画本身长度],若大于则动画结束. protected bool IsAnimationFinished =&gt; StateDuration &gt;= animator.GetCurrentAnimatorStateInfo(0).length; //当前状态的持续时间,当前时间减去状态开始时间. protected float StateDuration =&gt; Time.time - stateStartTime; Enter()中给stateStartTime赋值 public virtual void Enter() &#123;//animator.CrossFade()交叉淡化函数,可传入哈希值或者string animator.CrossFade(stateHash, transitionDuration); stateStartTime = Time.time;//记录下状态开始时间 &#125; 7.3 玩家跳跃新建三个状态类PlayerState_Fall,PlayerState_JumpUp,PlayerState_Land。 玩家按下跳跃键,并且玩家在地面上","categories":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/categories/unity/"}],"tags":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/tags/unity/"},{"name":"平台跳跃控制器","slug":"平台跳跃控制器","permalink":"https://niaoyu00.github.io/Blog/tags/%E5%B9%B3%E5%8F%B0%E8%B7%B3%E8%B7%83%E6%8E%A7%E5%88%B6%E5%99%A8/"}]},{"title":"unity中Invoke用法","slug":"unity中Invoke用法","date":"2022-06-16T11:16:00.000Z","updated":"2022-10-02T19:50:25.270Z","comments":true,"path":"2022/06/16/unity中Invoke用法/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/06/16/unity%E4%B8%ADInvoke%E7%94%A8%E6%B3%95/","excerpt":"","text":"Invoke方法是Unity3D 中的一种委托机制。现在看一下官网给出的API： public void Invoke(string methodName, float time); methodName 是方法名，time 是具体几秒 Invokes the method methodName in time seconds. 在具体事件以后调用这个方法 也就是说，Invoke(“SendMessage”,5) ,表示的是在“5s”以后执行“SendMessage”方法。 使用Invoke方法需要注意以下三点： 1、它应该在Start,Update,FixUpdate,LateUpdate,还有OnGUI中被调用 2、Invoke中传递的方法不能是含有参数的方法、 3、当Time.ScaleTime &#x3D; 0时，Invoke()无效，调用不到Invoke方法 当然，Invoke也支持重复调用: InvokeRepeating(“SendMessage”,2,3); 表示在“2s”以后开始调用第一次，之后每隔“3s”重复调用一次。","categories":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/categories/unity/"}],"tags":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/tags/unity/"},{"name":"Invoke","slug":"Invoke","permalink":"https://niaoyu00.github.io/Blog/tags/Invoke/"}]},{"title":"正则表达式(搬运)","slug":"正则表达式","date":"2022-06-06T11:26:04.000Z","updated":"2022-10-02T19:53:23.536Z","comments":true,"path":"2022/06/06/正则表达式/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/06/06/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"什么是正则表达式？ 正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。 一个正则表达式是一种从左到右匹配主体字符串的模式。“Regular expression”这个词比较拗口，我们常使用缩写的术语“regex”或“regexp”。正则表达式可以从一个基础字符串中根据一定的匹配模式替换文本中的字符串、验证表单、提取字符串等等。 想象你正在写一个应用，然后你想设定一个用户命名的规则，让用户名包含字符、数字、下划线和连字符，以及限制字符的个数，好让名字看起来没那么丑。我们使用以下正则表达式来验证一个用户名： 以上的正则表达式可以接受 john_doe、jo-hn_doe、john12_as。但不匹配Jo，因为它包含了大写的字母而且太短了。 目录 1. 基本匹配 2. 元字符 2.1 点运算符 . 2.2 字符集 2.2.1 否定字符集 2.3 重复次数 2.3.1 * 号 2.3.2 + 号 2.3.3 ? 号 2.4 {} 号 2.5 (…) 特征标群 2.6 | 或运算符 2.7 转码特殊字符 2.8 锚点 2.8.1 ^ 号 2.8.2 $ 号 3. 简写字符集 4. 零宽度断言(前后预查) 4.1 ?&#x3D;… 正先行断言 4.2 ?!… 负先行断言 4.3 ?&lt;&#x3D; … 正后发断言 4.4 ?&lt;!… 负后发断言 5. 标志 5.1 忽略大小写（Case Insensitive） 5.2 全局搜索（Global search） 5.3 多行修饰符（Multiline） 额外补充 贡献 许可证 1. 基本匹配正则表达式其实就是在执行搜索时的格式，它由一些字母和数字组合而成。例如：一个正则表达式 the，它表示一个规则：由字母t开始，接着是h，再接着是e。 \"the\" => The fat cat sat on the mat. 在线练习 正则表达式123匹配字符串123。它逐个字符的与输入的正则表达式做比较。 正则表达式是大小写敏感的，所以The不会匹配the。 \"The\" => The fat cat sat on the mat. 在线练习 2. 元字符正则表达式主要依赖于元字符。元字符不代表他们本身的字面意思，他们都有特殊的含义。一些元字符写在方括号中的时候有一些特殊的意思。以下是一些元字符的介绍： 元字符 描述 . 句号匹配任意单个字符除了换行符。 [ ] 字符种类。匹配方括号内的任意字符。 [^ ] 否定的字符种类。匹配除了方括号里的任意字符 * 匹配&gt;&#x3D;0个重复的在*号之前的字符。 + 匹配&gt;&#x3D;1个重复的+号前的字符。 ? 标记?之前的字符为可选. {n,m} 匹配num个大括号之前的字符或字符集 (n &lt;&#x3D; num &lt;&#x3D; m). (xyz) 字符集，匹配与 xyz 完全相等的字符串. &amp;#124; 或运算符，匹配符号前或后的字符. &amp;#92; 转义字符,用于匹配一些保留的字符 [ ] ( ) &#123; &#125; . * + ? ^ $ \\ &#124; ^ 从开始行开始匹配. $ 从末端开始匹配. 2.1 点运算符 ..是元字符中最简单的例子。.匹配任意单个字符，但不匹配换行符。例如，表达式.ar匹配一个任意字符后面跟着是a和r的字符串。 \".ar\" => The car parked in the garage. 在线练习 2.2 字符集字符集也叫做字符类。方括号用来指定一个字符集。在方括号中使用连字符来指定字符集的范围。在方括号中的字符集不关心顺序。例如，表达式[Tt]he 匹配 the 和 The。 \"[Tt]he\" => The car parked in the garage. 在线练习 方括号的句号就表示句号。表达式 ar[.] 匹配 ar.字符串 \"ar[.]\" => A garage is a good place to park a car. 在线练习 2.2.1 否定字符集一般来说 ^ 表示一个字符串的开头，但它用在一个方括号的开头的时候，它表示这个字符集是否定的。例如，表达式[^c]ar 匹配一个后面跟着ar的除了c的任意字符。 \"[^c]ar\" => The car parked in the garage. 在线练习 2.3 重复次数后面跟着元字符 +，* or ? 的，用来指定匹配子模式的次数。这些元字符在不同的情况下有着不同的意思。 2.3.1 * 号*号匹配 在*之前的字符出现大于等于0次。例如，表达式 a* 匹配0或更多个以a开头的字符。表达式[a-z]* 匹配一个行中所有以小写字母开头的字符串。 \"[a-z]*\" => The car parked in the garage #21. 在线练习 *字符和.字符搭配可以匹配所有的字符.*。*和表示匹配空格的符号\\s连起来用，如表达式\\s*cat\\s*匹配0或更多个空格开头和0或更多个空格结尾的cat字符串。 \"\\s*cat\\s*\" => The fat cat sat on the concatenation. 在线练习 2.3.2 + 号+号匹配+号之前的字符出现 &gt;&#x3D;1 次。例如表达式c.+t 匹配以首字母c开头以t结尾，中间跟着至少一个字符的字符串。 \"c.+t\" => The fat cat sat on the mat. 在线练习 2.3.3 ? 号在正则表达式中元字符 ? 标记在符号前面的字符为可选，即出现 0 或 1 次。例如，表达式 [T]?he 匹配字符串 he 和 The。 \"[T]he\" => The car is parked in the garage. 在线练习 \"[T]?he\" => The car is parked in the garage. 在线练习 2.4 &#123;&#125; 号在正则表达式中 &#123;&#125; 是一个量词，常用来限定一个或一组字符可以重复出现的次数。例如， 表达式 [0-9]&#123;2,3&#125; 匹配最少 2 位最多 3 位 0~9 的数字。 \"[0-9]{2,3}\" => The number was 9.9997 but we rounded it off to 10.0. 在线练习 我们可以省略第二个参数。例如，[0-9]&#123;2,&#125; 匹配至少两位 0~9 的数字。 \"[0-9]{2,}\" => The number was 9.9997 but we rounded it off to 10.0. 在线练习 如果逗号也省略掉则表示重复固定的次数。例如，[0-9]&#123;3&#125; 匹配3位数字 \"[0-9]{3}\" => The number was 9.9997 but we rounded it off to 10.0. 在线练习 2.5 (...) 特征标群特征标群是一组写在 (...) 中的子模式。(...) 中包含的内容将会被看成一个整体，和数学中小括号（ ）的作用相同。例如, 表达式 (ab)* 匹配连续出现 0 或更多个 ab。如果没有使用 (...) ，那么表达式 ab* 将匹配连续出现 0 或更多个 b 。再比如之前说的 &#123;&#125; 是用来表示前面一个字符出现指定次数。但如果在 &#123;&#125; 前加上特征标群 (...) 则表示整个标群内的字符重复 N 次。 我们还可以在 () 中用或字符 | 表示或。例如，(c|g|p)ar 匹配 car 或 gar 或 par. \"(c|g|p)ar\" => The car is parked in the garage. 在线练习 2.6 | 或运算符或运算符就表示或，用作判断条件。 例如 (T|t)he|car 匹配 (T|t)he 或 car。 \"(T|t)he|car\" => The car is parked in the garage. 在线练习 2.7 转码特殊字符反斜线 \\ 在表达式中用于转码紧跟其后的字符。用于指定 &#123; &#125; [ ] / \\ + * . $ ^ | ? 这些特殊字符。如果想要匹配这些特殊字符则要在其前面加上反斜线 \\。 例如 . 是用来匹配除换行符外的所有字符的。如果想要匹配句子中的 . 则要写成 \\. 以下这个例子 \\.?是选择性匹配. \"(f|c|m)at\\.?\" => The fat cat sat on the mat. 在线练习 2.8 锚点在正则表达式中，想要匹配指定开头或结尾的字符串就要使用到锚点。^ 指定开头，$ 指定结尾。 2.8.1 ^ 号^ 用来检查匹配的字符串是否在所匹配字符串的开头。 例如，在 abc 中使用表达式 ^a 会得到结果 a。但如果使用 ^b 将匹配不到任何结果。因为在字符串 abc 中并不是以 b 开头。 例如，^(T|t)he 匹配以 The 或 the 开头的字符串。 \"(T|t)he\" => The car is parked in the garage. 在线练习 \"^(T|t)he\" => The car is parked in the garage. 在线练习 2.8.2 $ 号同理于 ^ 号，$ 号用来匹配字符是否是最后一个。 例如，(at\\.)$ 匹配以 at. 结尾的字符串。 \"(at\\.)\" => The fat cat. sat. on the mat. 在线练习 \"(at\\.)$\" => The fat cat. sat. on the mat. 在线练习 3. 简写字符集正则表达式提供一些常用的字符集简写。如下: 简写 描述 . 除换行符外的所有字符 \\w 匹配所有字母数字，等同于 [a-zA-Z0-9_] \\W 匹配所有非字母数字，即符号，等同于： [^\\w] \\d 匹配数字： [0-9] \\D 匹配非数字： [^\\d] \\s 匹配所有空格字符，等同于： [\\t\\n\\f\\r\\p&#123;Z&#125;] \\S 匹配所有非空格字符： [^\\s] \\f 匹配一个换页符 \\n 匹配一个换行符 \\r 匹配一个回车符 \\t 匹配一个制表符 \\v 匹配一个垂直制表符 \\p 匹配 CR&#x2F;LF（等同于 \\r\\n），用来匹配 DOS 行终止符 4. 零宽度断言（前后预查）先行断言和后发断言（合称 lookaround）都属于非捕获组（用于匹配模式，但不包括在匹配列表中）。当我们需要一个模式的前面或后面有另一个特定的模式时，就可以使用它们。 例如，我们希望从下面的输入字符串 $4.44 和 $10.88 中获得所有以 $ 字符开头的数字，我们将使用以下的正则表达式 (?&lt;=\\$)[0-9\\.]*。意思是：获取所有包含 . 并且前面是 $ 的数字。 零宽度断言如下： 符号 描述 ?&#x3D; 正先行断言-存在 ?! 负先行断言-排除 ?&lt;&#x3D; 正后发断言-存在 ?&lt;! 负后发断言-排除 4.1 ?=... 正先行断言?=... 正先行断言，表示第一部分表达式之后必须跟着 ?=...定义的表达式。 返回结果只包含满足匹配条件的第一部分表达式。定义一个正先行断言要使用 ()。在括号内部使用一个问号和等号： (?=...)。 正先行断言的内容写在括号中的等号后面。例如，表达式 (T|t)he(?=\\sfat) 匹配 The 和 the，在括号中我们又定义了正先行断言 (?=\\sfat) ，即 The 和 the 后面紧跟着 (空格)fat。 \"(T|t)he(?=\\sfat)\" => The fat cat sat on the mat. 在线练习 4.2 ?!... 负先行断言负先行断言 ?! 用于筛选所有匹配结果，筛选条件为 其后不跟随着断言中定义的格式。正先行断言 定义和 负先行断言 一样，区别就是 = 替换成 ! 也就是 (?!...)。 表达式 (T|t)he(?!\\sfat) 匹配 The 和 the，且其后不跟着 (空格)fat。 \"(T|t)he(?!\\sfat)\" => The fat cat sat on the mat. 在线练习 4.3 ?&lt;= ... 正后发断言正后发断言 记作(?&lt;=...) 用于筛选所有匹配结果，筛选条件为 其前跟随着断言中定义的格式。例如，表达式 (?&lt;=(T|t)he\\s)(fat|mat) 匹配 fat 和 mat，且其前跟着 The 或 the。 \"(?","categories":[{"name":"基础学习","slug":"基础学习","permalink":"https://niaoyu00.github.io/Blog/categories/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://niaoyu00.github.io/Blog/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"ScriptableObject简单使用","slug":"ScriptableObject","date":"2022-06-06T11:20:04.000Z","updated":"2022-10-02T19:52:01.647Z","comments":true,"path":"2022/06/06/ScriptableObject/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/06/06/ScriptableObject/","excerpt":"","text":"ScriptableObject平时开发存在的一些问题： 一个场景内有多个相同组件使用相同数值的时候，这个组件也在内存中多了一份实例，浪费内存空间。 static或者[Serializable]修饰的变量，在程序退出后会还原。编辑器模式运行时，只能通过Copy Component Values来临时保存调整好的数值。 项目之间、场景之间数据很难共享。 在runtime下要改变某个GameObject上组件的数值，就一定要获取到这个GameObject实例，使项目耦合度成倍提高，最后变成蜘蛛网。 场景中总会有一些空的GameObject用来保存和共享数据，这个GameObject基本不会参与太多的游戏逻辑，但为了保存和共享场景内的数据就不得不碍眼的在场景中出现，逼死强迫症，也不利于模块抽象。 同样，要通过UGUI Button中的On Click事件调用一个GameObject上的方法，也只能获取到GameObject实例来调用，数量太多的话也变成了蜘蛛网。 使用ScriptableObject如何解决 ScriptableObject是将数据存储在.asset文件中的，可以理解为类似material这样的文件，ScriptableObject中存储的数值在runtime中作出修改，在退出后也会被保存下来。 同样，类似material文件，在多个地方需要用到同一个数据，只要把ScriptableObject生成的.asset文件拖入相应位置就可以，不必再指向某个单例或者实例。 可以被任何场景引用，在项目之间、场景之间很容易的共享数据。 不必为了保存数据在场景中放置一个空GameObject。让项目的复杂度和耦合度最大限度的降低，强迫症福音。 ScriptableObject是自定义的数据类型，应用非常灵活。 通过UGUI Button中的On Click事件只需要指向某一个ScriptableObject文件，而响应事件的GameObject也只需要获取到这个ScriptableObject文件即可触发，不必让按钮指向GameObject实例。大幅度减少了项目逻辑和结构的复杂程度。 需求 通过ScriptableObject获取一个GameObject的实例。 不获取物体实例，通过ScriptableObject实现UnityEvent的执行。 角色：player,enemy; 场景内会在随机位置生成任意数量的敌人，敌人会追着player一直跑，player通过移动来躲避敌人，每次碰到敌人就会减少生命值。 开始实现搭建场景和角色敌人: 新建脚本FollowTransformSmooth，实现追踪功能，拖到enemy上面。public class FollowTransformSmooth : MonoBehaviour&#123; //[SerializeField] Transform target; [SerializeField] TargetTransform target; [SerializeField] Rigidbody selfRigidbody; [SerializeField, Range(0f, 100f)] float moveSpeed = 10f; Vector3 _destination;//目的地 Vector3 _direction;//方向 void LateUpdate() &#123;//LateUpdate 在调用所有 Update 函数后调用。 //_destination = target.position;//怪物追踪目的地 _destination = target.targetTrans.position;//怪物追踪目的地 _direction = (_destination - transform.position).normalized;//怪物前进方向 //AddForce,向刚体添加力,(vector3方向,ForceMode力类型) selfRigidbody.AddForce(_direction * moveSpeed, ForceMode.Acceleration); // ForceMode.Force 向此刚体添加连续力，使用其质量。 // ForceMode.Acceleration 向此刚体添加连续加速度，忽略其质量。 // ForceMode.Impulse 向此刚体添加瞬时力冲击，考虑其质量。 // ForceMode.VelocityChange 向此刚体添加瞬时速度变化，忽略其质量。 &#125;&#125; 新建TargetTransform脚本，继承ScriptableObject，用来存储主角的位置信息[CreateAssetMenu(menuName = &quot;mySubMenu/TargetTransform &quot;)]public class TargetTransform : ScriptableObject&#123; public Transform targetTrans;&#125; 编译完在文件夹新建TargetTransform，命名为Player 新建SetTarget脚本，主角位置数据赋值给TargetTransform。拖到player上public class SetTarget : MonoBehaviour&#123; [SerializeField] TargetTransform target; void Awake() &#123; target.targetTrans = gameObject.transform;//当前位置数据传递给TargetTransform &#125;&#125; 预制体上的配置：","categories":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/categories/unity/"}],"tags":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/tags/unity/"},{"name":"ScriptableObject","slug":"ScriptableObject","permalink":"https://niaoyu00.github.io/Blog/tags/ScriptableObject/"}]},{"title":"横板卷轴射击游戏笔记","slug":"横板卷轴射击游戏笔记","date":"2022-05-27T10:18:20.000Z","updated":"2022-10-02T19:49:40.918Z","comments":true,"path":"2022/05/27/横板卷轴射击游戏笔记/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/05/27/%E6%A8%AA%E6%9D%BF%E5%8D%B7%E8%BD%B4%E5%B0%84%E5%87%BB%E6%B8%B8%E6%88%8F%E7%AC%94%E8%AE%B0/","excerpt":"","text":"一、背景滚动实现方法 创建一个3d对象Quad,重命名为SimpleBackground,调整好大小(跟图片差不多大) 新建一个材质,设置shader为Unlit&#x2F;Textu 将图片texture type设置为default，拖入材质。 将材质拖进SimpleBackground，这样就做好了背景。 通过实时更改材质中offset偏移值，来实现滚动效果 滚动代码如下：将Start()改为每帧刷新的协程(模拟Update()) Material material; [SerializeField] Vector2 scrollVelocity;//速度 void Awake() &#123; material = GetComponent&lt;Renderer&gt;().material; &#125; private IEnumerator Start() &#123; while (GameManager.GameState != GameState.GameOver) //游戏状态不为gameover可运行场景滚动 &#123; material.mainTextureOffset += scrollVelocity * Time.deltaTime; yield return null; &#125; &#125; 二、Input System动作输入系统Input System（安装包）实现了一个，可使用任何类型输入设备来控制unity内容的系统。它旨在替代unity旧的输入管理器（UnityEngine.Input类），并且更为强大，灵活易用。 安装输入系统Window-&gt;Pacjage Manager-&gt;UnityRegistry(搜索input)-&gt;安装 实现功能新建InputActions文件 打开InputActions，绑定输入信号。 创建c#文件,注意名字可自定，我取名为PlayerInputActions。 新建一个PlayInput类,继承于ScriptableObject,//ScriptableObject:一个类，如果需要创建【无需附加到游戏对象】的对象时，可从该类派生。【】表示强调。继承PlayerInputActions类中的几个接口，实现接口。 未完待续…(因为是好早之前看视频学的,详细的内容得去重看视频再补,目前还没那个时间)","categories":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/categories/unity/"}],"tags":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/tags/unity/"}]},{"title":"github图床搭建","slug":"git图床","date":"2022-05-23T11:58:22.511Z","updated":"2022-10-25T05:56:04.250Z","comments":true,"path":"2022/05/23/git图床/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/05/23/git%E5%9B%BE%E5%BA%8A/","excerpt":"","text":"※提示:github是国外网站，所以图片加载速度一般，现在我已经换成了阿里云存储了，详细请看：https://niaoyu00.github.io/Blog/2022/10/24/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/ gitee的图床居然炸了？！难怪我之前看网站里图片都没了，一直没意识到是gitee的问题。因为本人前段时间重装电脑系统，导致今天整理笔记的时候要重新配置picgo的图床，刚配置完一看图片显示都是空的…我一直怀疑是因为我typora没升级付费版，所以他不给显示。网上查了半天，最后才发现是gitee加了防盗链，虽然说拿他白嫖做图床有点不厚道，但是你既然开放了这个功能，要停的话至少提前说一下嘛。算了，回到重点，下面是github图床搭建流程，在此记录下来以后忘了可以看看： 1、新建一个github仓库，clone到本地，然后将gitee旧图片文件夹拷进来再上传。完成后大概是这样： 2、仓库搞完去获取个人令牌 名字随便取，自己记得就好。日期选无限期。下方选repo 然后获取token，记得复制 3、打开picgo输入相应数据仓库名直接复制github的http链接，删一下前半部分https://github.com/还有最后的.git就行。指定存储路径最好别填，我试了很容易上传失败。 4、打开typora中文件-&gt;偏好设置-&gt;图像 按图片中操作完测试下","categories":[{"name":"git","slug":"git","permalink":"https://niaoyu00.github.io/Blog/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://niaoyu00.github.io/Blog/tags/git/"}]},{"title":"unity滑条控制音量事件","slug":"unity滑条控制音量事件","date":"2022-05-11T18:36:12.000Z","updated":"2022-10-02T19:48:49.599Z","comments":true,"path":"2022/05/12/unity滑条控制音量事件/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/05/12/unity%E6%BB%91%E6%9D%A1%E6%8E%A7%E5%88%B6%E9%9F%B3%E9%87%8F%E4%BA%8B%E4%BB%B6/","excerpt":"","text":"slider.onValueChanged.AddListenerslider.onValueChanged.AddListener((float v) =&gt; &#123;//v等价于slider.value AudioTuning.Instance.SetMasterVolume(v); &#125;); AudioTuning:public class AudioTuning : SingLeton&lt;AudioTuning&gt;&#123; [SerializeField] AudioMixer audioMixer; public void SetMasterVolume(float volume) &#123; audioMixer.SetFloat(&quot;MasterVolume&quot;, volume); &#125;&#125;","categories":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/categories/unity/"}],"tags":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/tags/unity/"}]},{"title":"unity中查找对象的五种方法","slug":"unity中查找对象的五种方法","date":"2022-05-11T18:31:17.000Z","updated":"2022-10-02T19:48:51.278Z","comments":true,"path":"2022/05/12/unity中查找对象的五种方法/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/05/12/unity%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%94%E7%A7%8D%E6%96%B9%E6%B3%95/","excerpt":"","text":"通过对象名称（Find方法） GameObject.Find(&quot;name&quot;) 通过标签获取单个游戏对象（FindWithTag方法） GameObject.FindWithTag(&quot;Tag&quot;); 通过标签获取多个游戏对象（FindGameObjectsWithTags方法） 通过类型获取单个游戏对象（FindObjectOfType方法） 通过类型获取多个游戏对象（FindObjectsOfType方法）","categories":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/categories/unity/"}],"tags":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/tags/unity/"}]},{"title":"unity塔防demo记录","slug":"unity塔防demo记录","date":"2022-03-09T11:30:04.000Z","updated":"2022-10-02T19:46:19.882Z","comments":true,"path":"2022/03/09/unity塔防demo记录/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/03/09/unity%E5%A1%94%E9%98%B2demo%E8%AE%B0%E5%BD%95/","excerpt":"","text":"参考项目:https://www.bilibili.com/video/BV15W411976h新加的功能1.怪物球自转 2.不同炮台只可在特定颜色，区域内建造。 3.未选中炮台不可建造 遇到的问题炮弹打中敌人之后发现后方的一个怪会持续扣血直到死亡。初步猜测是碰撞触发了多次，后来暂停看的时候发现，子弹爆炸特效(在子弹销毁时触发) 在敌人死亡的时候会一下子刷出特别多。因此我判断是子弹打入敌人之后没有实时销毁。运行一测，果然是。最后在子弹脚本中，释放子弹爆炸特效的前方增加了销毁自身的代码。修复了bug。 待续..","categories":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/categories/unity/"}],"tags":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/tags/unity/"},{"name":"塔防demo","slug":"塔防demo","permalink":"https://niaoyu00.github.io/Blog/tags/%E5%A1%94%E9%98%B2demo/"}]},{"title":"协调程序","slug":"协程","date":"2022-03-03T04:55:48.000Z","updated":"2022-10-02T19:46:57.572Z","comments":true,"path":"2022/03/03/协程/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/03/03/%E5%8D%8F%E7%A8%8B/","excerpt":"","text":"协程：协同程序协程的使用前提：直接或间接的继承MonoBehavior才可以使用。 不足：会产生外的开销。 协程方法与普通方法的区别：被调用时：普通方法被调用时，原来执行的部分保留现场，停止执行，然后去执行要调用的方法，并且，被调用的方法执行完之后才能返回到调用前的状态接着往下执行。。。协同方法的执行是不用等协同方法执行完再执行调用之前原来方法的代码。而是两者&#x3D;&#x3D;异步执行&#x3D;&#x3D;。 类似js的异步","categories":[{"name":"基础学习","slug":"基础学习","permalink":"https://niaoyu00.github.io/Blog/categories/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/tags/unity/"}]},{"title":"git指令","slug":"git指令","date":"2022-03-01T01:16:27.000Z","updated":"2022-10-02T19:53:22.110Z","comments":true,"path":"2022/03/01/git指令/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/03/01/git%E6%8C%87%E4%BB%A4/","excerpt":"","text":"1.配置提交人姓名: git config --global user.name提交人姓名2.配置提交人姓名: git config --global user.email提交人邮箱3.查看git配置信息: git config --list git init |初始化git仓库git status |查看文件状态git add 文件列表 |提交到暂存区git commit -m 提交信息 |向仓库提交代码 用&#x3D;&#x3D;暂存区&#x3D;&#x3D;中的文件覆盖&#x3D;&#x3D;电脑工作目录&#x3D;&#x3D;的文件：git checkout 文件名 将文件从暂存区里删除: git rm --cached 文件 将git仓库中置顶的更新&#x3D;&#x3D;记录恢复&#x3D;&#x3D;出来，并且覆盖&#x3D;&#x3D;暂存区和工作目录&#x3D;&#x3D;: git reset --hard commitID 分支命令功能分支 -&gt; 开发分支 -&gt; 主分支 git branch 查看分支 git branch 分支名称 创建分支 git checkout 分支名称 切换分支 git merge 来源分支 &#x3D;&#x3D;合并分支&#x3D;&#x3D; git branch -d 分支名称 删除分支（分支被合并后才允许删除）（-D 强制删除） 暂时保存更改在git中，可以暂时提取分支上所有的改动并存储，让开发人员得到一个干净的工作副本，临时转向其他工作。 使用场景：分支临时切换 存储临时改动：git stash 恢复改动：git stash pop 本地仓库推送到远程仓库 git push 远程仓库地址 分支名称 git remote add 远程仓库&#x3D;&#x3D;地址别名&#x3D;&#x3D; 远程仓库地址 git push 远程仓库&#x3D;&#x3D;地址别名&#x3D;&#x3D; 分支名称 git push &#x3D;&#x3D;-u&#x3D;&#x3D; 远程仓库地址别名 分支名称 -u 记住推送地址及分支，&#x3D;&#x3D;下次推送&#x3D;&#x3D;只需要输入&#x3D;&#x3D;git push&#x3D;&#x3D;即可 拉取操作克隆仓库克隆远端数据仓库到本地：git clone 仓库地址 拉取远程仓库中最新的版本：git pull 远程仓库地址 分支名称 解决冲突在多人同时开发一个项目时，如果两个人修改了同一个文件的同一个地方，就会发生冲突。冲突需要人为解决。 跨团队协作 程序员 C fork仓库 程序员 C 将仓库克隆在本地进行修改 程序员 C 将仓库推送到远程 程序员 C 发起pull reqest 原仓库作者审核 原仓库作者合并代码 ssh免登陆生成秘钥：ssh-keygen 秘钥存储目录：C:\\Users\\用户\\.ssh 公钥名称：id_rsa.pub 私钥名称：id_rsa 公钥放在github 私钥放在本地 GIT忽略清单将不需要被git管理的文件名字添加到此文件中，在执行git命令的时候，git就会忽略这些文件。 git忽略清单文件名称：**.gitignore** 将工作目录中的文件全部添加到暂存区：git add .","categories":[{"name":"git","slug":"git","permalink":"https://niaoyu00.github.io/Blog/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://niaoyu00.github.io/Blog/tags/git/"}]},{"title":"unity的Axis设置","slug":"unity的Axis设置","date":"2022-02-26T23:02:27.000Z","updated":"2022-10-02T19:47:48.080Z","comments":true,"path":"2022/02/27/unity的Axis设置/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/02/27/unity%E7%9A%84Axis%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"unity的Axis设置，路径为Edit-&gt;Project setting-&gt;Input: 属性如下： Name：&#x3D;&#x3D;按键名&#x3D;&#x3D;该键的名称，可以在脚本编程中直接引用他。比如：Input.GetButtonDown(“Jump”); Descriptive Name:&#x3D;&#x3D;【描述名】&#x3D;&#x3D;在游戏的独立机构中的配置对话框中，当控制值为正时候所显示的名称。默认空白。 Negative Descriptive Name：&#x3D;&#x3D;【负描述】&#x3D;&#x3D;在游戏的独立机构中的配置对话框中，当控制值为负的时候所显示的名称。 Nagative Button：&#x3D;&#x3D;【负向按钮】&#x3D;&#x3D;玩家按下这个按钮来让被控制物体向负方向运动。 Positive Button：&#x3D;&#x3D;【正向按钮】&#x3D;&#x3D;玩家按下这个按钮让被控制物体向正方向运动。 Alt Negative Button: 玩家可以使用的备选负向按钮，比如方向键和WASD Alt Positive Button：玩家可以使用的备选争相按钮。 Gravity：&#x3D;&#x3D;【重力】&#x3D;&#x3D;如果玩家停止输入，该轴将恢复到空挡或0速度，其单位为单位每秒。 Dead：&#x3D;&#x3D;【盲区】&#x3D;&#x3D;可以用在模拟控制。在模拟控制器上，在这个范围内的任何值都会映射到空档不会提供任何输入。 Sensitivity：&#x3D;&#x3D;【灵敏度】&#x3D;&#x3D;可以用于数字控制，他是该轴向给定得值移动的速度。正负都可，单位为单位每秒。 Snap：&#x3D;&#x3D;【对齐】&#x3D;&#x3D;如果选中，可以确保在同时按下正向和负向按钮时候该轴的值为空挡。 Invert：&#x3D;&#x3D;【反转】&#x3D;&#x3D;迅速交换正向和负向控制键。 Type：&#x3D;&#x3D;【类型】&#x3D;&#x3D;该键对应的输入设备类型。可以为Key，MouseButton，MouseMove，JoystickAxis，或Window Movement。 Axis：&#x3D;&#x3D;【轴】&#x3D;&#x3D;这个控制方式有该输入设备的哪条轴指挥。这可受不同游戏手柄影响。 JoyNum：&#x3D;&#x3D;【操作杆编号】&#x3D;&#x3D;多个操作杆在机器上市后，决定哪个哪个操作杆控制给定的轴。可以选择从所有的操作杆接受输入，或是为其制定一个特定的。","categories":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/categories/unity/"}],"tags":[{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/tags/unity/"}]},{"title":"计算器","slug":"Csharp计算器","date":"2022-02-23T10:35:39.000Z","updated":"2022-11-22T16:06:59.742Z","comments":true,"path":"2022/02/23/Csharp计算器/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/02/23/Csharp%E8%AE%A1%E7%AE%97%E5%99%A8/","excerpt":"","text":"using System;using System.Linq;namespace Calculator&#123; class Program &#123; static void Main(string[] args) &#123; for (int i = 0; i &lt; 3; i++) &#123; string inputStr = Console.ReadLine(); CalcOnline(inputStr); &#125; &#125; static CalcInfo[] configs = new CalcInfo[] &#123; new CalcInfo(&quot;+&quot;,(a,b)=&gt;a+b), new CalcInfo(&quot;-&quot;,(a,b)=&gt;a-b), new CalcInfo(&quot;*&quot;,(a,b)=&gt;a*b), new CalcInfo(&quot;/&quot;,(a,b)=&gt;a/b), &#125;; private static void CalcOnline(string inputStr) &#123; int index = -1; Func&lt;float, float, float&gt; func = null; for (int i = 0; i &lt; configs.Length; i++) &#123; var item = configs[i]; index = inputStr.IndexOf(item.tag);//找到符号，返回所在下标，未找到返回-1 if (index != -1) &#123; func = item.func;//如果找到的是+，那么index为1，+的func函数内容是a+b break; &#125; &#125; if (index == -1) &#123; Console.WriteLine(&quot;只支持+-*/&quot;); return; &#125; CalcResult(inputStr, func, index); &#125; private static void CalcResult(string inputStr, Func&lt;float, float, float&gt; func, int index) &#123; string num1Str = inputStr.Substring(0, index);//0~index之间的内容(不包括后面的)赋值给num1Str，若输入1+2则获得1 int strLen = inputStr.Count(); Console.WriteLine($&quot;strLen:&#123;strLen&#125;,index:&#123;index&#125;&quot;); string num2Str = inputStr.Substring(index+1,strLen-index-1);//若输入1+2则获得2 float num1 = float.Parse(num1Str); float num2 = float.Parse(num2Str); Console.WriteLine($&quot;num1:&#123;num1&#125;, num2:&#123;num2&#125;&quot;); float result = func(num1, num2); Console.WriteLine($&quot;&#123;inputStr&#125;的计算结果：&#123;result&#125;&quot;); &#125; &#125; public class CalcInfo &#123; public string tag; public Func&lt;float, float, float&gt; func; public CalcInfo(string tag, Func&lt;float, float, float&gt; func) &#123; this.tag = tag; this.func = func; &#125; &#125;&#125;////5+6//strLen:3,index:1//num1:5, num2:6//5+6的计算结果：11","categories":[{"name":"基础学习","slug":"基础学习","permalink":"https://niaoyu00.github.io/Blog/categories/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Csharp","slug":"Csharp","permalink":"https://niaoyu00.github.io/Blog/tags/Csharp/"}]},{"title":"委托","slug":"委托","date":"2022-02-22T11:25:14.000Z","updated":"2022-10-02T19:47:06.545Z","comments":true,"path":"2022/02/22/委托/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/02/22/%E5%A7%94%E6%89%98/","excerpt":"","text":"委托delegate：可以保存多个函数指针，试用&#x3D;+，-+进行操作。//将函数赋值给delegate，delegate会储存下来。 //Action无返回值 Action&lt;string&gt; print = Print; print(&quot;使用print打印&quot;); Func&lt;float,float,float&gt; fc = Mul;//打印：Func，第三个参数是返回值类型 var f = fc(3, 4).ToString(); //打印：乘法3 * 4 = 12 Console.WriteLine(f);//打印：12 CalFunc func = Add; func(1.1f, 2);//打印：加法1.1+2=3.1 Console.WriteLine(&quot;加入Sub()&quot;); func += Sub; func(1.1f, 2);//打印：减法1.1+2=3.1 //1.1-2=-0.9 Console.WriteLine(&quot;移除Add()&quot;); func -= Add; func(1.1f, 2);//打印：减法1.1-2=-0.9 Console.WriteLine(&quot;-------------闭包↓----------------&quot;); int intVal = 10; //匿名函数 执行后改变的值可作用到函数外。 Action aa = () =&gt; &#123; intVal += 10; &#125;; aa();//调用 Console.WriteLine(intVal);//打印：20//无返回值，封装了一个print代替writeline static void Print(string info) =&gt;Console.WriteLine(info); //定义了delegate，可以存储函数指针 delegate float CalFunc(float f1, float f2); //下面是好几个函数，实现加减乘。 static float Add(float arg1, float arg2) &#123; Console.WriteLine($&quot;加法&#123;arg1&#125;+&#123;arg2&#125;=&#123;arg1 + arg2&#125;&quot;); return arg1 + arg2; &#125; static float Sub(float arg1, float arg2) &#123; Console.WriteLine($&quot;减法&#123;arg1&#125;-&#123;arg2&#125;=&#123;arg1 - arg2&#125;&quot;); return arg1 - arg2; &#125; static float Mul(float arg1, float arg2) &#123; Console.WriteLine($&quot;乘法&#123;arg1&#125;*&#123;arg2&#125;=&#123;arg1 * arg2&#125;&quot;); return arg1 * arg2; &#125;","categories":[{"name":"基础学习","slug":"基础学习","permalink":"https://niaoyu00.github.io/Blog/categories/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Csharp","slug":"Csharp","permalink":"https://niaoyu00.github.io/Blog/tags/Csharp/"}]},{"title":"Csharpclass与struct的关系","slug":"CsharpClass与Struct的关系","date":"2022-02-21T11:37:16.000Z","updated":"2022-10-02T19:47:15.159Z","comments":true,"path":"2022/02/21/CsharpClass与Struct的关系/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/02/21/CsharpClass%E4%B8%8EStruct%E7%9A%84%E5%85%B3%E7%B3%BB/","excerpt":"","text":"值与引用的关系 值类型在栈中存储 引用类型在堆中存储 &#x3D;&#x3D;Class&#x3D;&#x3D;的值在堆里，地址在栈。(栈开一个空间存储地址，通过地址在堆里找到创建的值。) &#x3D;&#x3D;Struct&#x3D;&#x3D;直接在栈里开辟空间来存储值。 此处为cVec的地址与sVec x,sVec Y，开辟了三个。 再来看函数内部： 更改了cvec与svec的x值， 此时**cVec.print()**打印的值为 1cVec(100,0) **sVec.print()**打印的值也为 sVec(100,0) 函数调用结束，目光回到上面初始开辟的空间。 下方的**cVec.print()，sVec.print()**； 打印结果为： cVec(100,0) sVec(0,0) 因为sVec是函数内创建的值，在外面他没有更改。而cVec是通过地址找到堆里的值，在函数里已经将值更改。 如果想要Struct的值跟class一样，需要再前面加ref","categories":[{"name":"基础学习","slug":"基础学习","permalink":"https://niaoyu00.github.io/Blog/categories/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Csharp","slug":"Csharp","permalink":"https://niaoyu00.github.io/Blog/tags/Csharp/"}]},{"title":"Ue4材质快捷键（转载）","slug":"材质快捷键","date":"2022-02-18T01:17:07.000Z","updated":"2022-10-02T19:53:28.970Z","comments":true,"path":"2022/02/18/材质快捷键/","link":"","permalink":"https://niaoyu00.github.io/Blog/2022/02/18/%E6%9D%90%E8%B4%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"","text":"虚幻材质里面的快捷键注：以下快捷键都需要结合鼠标左键来创建 首先是数字键1234分别对应的是1234维的常数节点，然后这里有个主意的地方就是1维常数的参数快捷键是S，三维常数的参数快捷键是V。 然后是ABCD ，A是Add加法节点， B是bumpoffset凹凸偏移，C是注释，D是Divide除法节点，当然还有我们的M,multiply乘法节点 E就是我们的power节点了，F这个节点目前还不是很熟悉是一个UNspecified function什么类型的函数，欢迎补充。 L就是线性插值这个节点了。非常重要的！ I是一个IF函数节点 N是我们的normalize O就是我们的1-x函数了one minus 反转~~ P是panner平移节点 R是refelction vector 反射向量 T是Texture sample贴图节点，经常会用到。 最后是U，UV贴图平铺的一个节点，也很重要 作者：墨一良丶 https://www.bilibili.com/read/cv7905584?spm_id_from=333.999.0.0 出处：bilibili","categories":[{"name":"ue4","slug":"ue4","permalink":"https://niaoyu00.github.io/Blog/categories/ue4/"}],"tags":[{"name":"ue4材质","slug":"ue4材质","permalink":"https://niaoyu00.github.io/Blog/tags/ue4%E6%9D%90%E8%B4%A8/"}]},{"title":"Ue4材质边界混合","slug":"边界混合","date":"2021-10-30T08:57:19.000Z","updated":"2022-10-02T19:53:27.591Z","comments":true,"path":"2021/10/30/边界混合/","link":"","permalink":"https://niaoyu00.github.io/Blog/2021/10/30/%E8%BE%B9%E7%95%8C%E6%B7%B7%E5%90%88/","excerpt":"","text":"边界混合 世界坐标纹理对齐，实现效果大概是：在地面添加物体，任意改变形状位置，材质纹理会自动对齐。 边界混合2解决PDO抖动显示问题","categories":[{"name":"ue4","slug":"ue4","permalink":"https://niaoyu00.github.io/Blog/categories/ue4/"}],"tags":[{"name":"ue4材质","slug":"ue4材质","permalink":"https://niaoyu00.github.io/Blog/tags/ue4%E6%9D%90%E8%B4%A8/"}]},{"title":"ue4decal贴花","slug":"decal","date":"2021-10-27T08:29:31.000Z","updated":"2022-10-02T19:53:24.659Z","comments":true,"path":"2021/10/27/decal/","link":"","permalink":"https://niaoyu00.github.io/Blog/2021/10/27/decal/","excerpt":"","text":"decal贴花 材质 Tiling：平铺 Crop X：横向移动 Crop Y：纵向移动 08 - Parallax POM：侧面看也能看出高低差 Height Ratio：凸起部分的高度 Reference Plane：使用UsePOM会导致正常视角看贴花有显示bug，通过这个参数调整。 抖动，使颜色混合","categories":[{"name":"ue4","slug":"ue4","permalink":"https://niaoyu00.github.io/Blog/categories/ue4/"}],"tags":[{"name":"ue4材质","slug":"ue4材质","permalink":"https://niaoyu00.github.io/Blog/tags/ue4%E6%9D%90%E8%B4%A8/"}]},{"title":"ue4顶点绘制","slug":"顶点绘制","date":"2021-10-25T04:36:18.000Z","updated":"2022-10-02T19:53:26.381Z","comments":true,"path":"2021/10/25/顶点绘制/","link":"","permalink":"https://niaoyu00.github.io/Blog/2021/10/25/%E9%A1%B6%E7%82%B9%E7%BB%98%E5%88%B6/","excerpt":"","text":"网格体绘制（顶点绘制） 步骤混合材质 打开这个，依顺序从底层-&gt;中间层-&gt;顶层进行选择。 截图里红色框命名，蓝色框确认，创建后就是混合后的材质。 然后将混合后材质拖进平面，调整平铺比例（视频里材质UV是4x4，而box盒子是一米见方，因此需要调整混合后材质的uv，将材质02-Base Layer参数平铺x平铺y改成四分之一） 绘制 模式&#x3D;&gt;网格体绘制 选择平面 选绘制，切换成黑色 通道选择：红：中间层 绿：顶层 蓝：水坑层（默认需要激活） 擦除：按住shift再画高度混合方法在混合材质界面，给底层BaseLayer添加，基础层置换贴图-displacement map 之后在这里微调效果 大致效果： 顶层也可以这么操作。 Global可调节饱和度，亮度、对比度 粗糙度调节 使用独立的置换调整值 右边的勾勾，勾选之后06-displacement会增加选项 选中哪个层调数值，相当于把那个层移高，或者下降 缺点： 细看有瑕疵 性能消耗（需要去材质蓝图关闭）。 调整水材质 Liquid Color：水颜色 Liquid Opacity：透明度 （水的深&#x2F;浅） Liquid Falloff Roughness：边缘过渡的粗糙度（数值越小边缘越湿润） Albedo Darkening Color：液体调白色&#x3D;&gt;模拟物体防水表面。液体调暗&#x3D;&gt;模拟物体表面渗入性 Liquid Wave Controls：波浪调整 浪花大小（数值越小浪花越大） 浪花速度 上方水面 法线贴图的强度 无 2和3一般一起调整。","categories":[{"name":"ue4","slug":"ue4","permalink":"https://niaoyu00.github.io/Blog/categories/ue4/"}],"tags":[{"name":"ue4材质","slug":"ue4材质","permalink":"https://niaoyu00.github.io/Blog/tags/ue4%E6%9D%90%E8%B4%A8/"}]},{"title":"ue4材质笔记","slug":"ue4材质学习笔记","date":"2021-10-15T15:20:31.000Z","updated":"2022-10-02T19:48:56.975Z","comments":true,"path":"2021/10/15/ue4材质学习笔记/","link":"","permalink":"https://niaoyu00.github.io/Blog/2021/10/15/ue4%E6%9D%90%E8%B4%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"简明PBR2：介绍了菲尼尔，以及两个网站可以查折射率 材质基础 常量Constant：不能在材质实例中调整 变量Variable：可以在材质中调整 右键可以转换常量或变量 矢量Vector：表示颜色、坐标信息 标量Scalar：常用参数调整手段 用作展示颜色节点Variable3Vector节点 可调整参数ScalarParameter节点 调用贴图 TextureCoordinate 控制纹理平铺 lerp线性插值 lerp可以混合两种颜色，加上一个标量来控制 也可以混合法线贴图，前台控制法线程度 2022年5月10日编辑:ue4材质内容基本忘光了,留着文章就当记录了.","categories":[{"name":"ue4","slug":"ue4","permalink":"https://niaoyu00.github.io/Blog/categories/ue4/"}],"tags":[{"name":"ue4材质","slug":"ue4材质","permalink":"https://niaoyu00.github.io/Blog/tags/ue4%E6%9D%90%E8%B4%A8/"}]}],"categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://niaoyu00.github.io/Blog/categories/Hexo/"},{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/categories/unity/"},{"name":"美术","slug":"美术","permalink":"https://niaoyu00.github.io/Blog/categories/%E7%BE%8E%E6%9C%AF/"},{"name":"lua","slug":"lua","permalink":"https://niaoyu00.github.io/Blog/categories/lua/"},{"name":"基础学习","slug":"基础学习","permalink":"https://niaoyu00.github.io/Blog/categories/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"name":"其他","slug":"其他","permalink":"https://niaoyu00.github.io/Blog/categories/%E5%85%B6%E4%BB%96/"},{"name":"Csharp","slug":"Csharp","permalink":"https://niaoyu00.github.io/Blog/categories/Csharp/"},{"name":"设计模式","slug":"设计模式","permalink":"https://niaoyu00.github.io/Blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"开发工具","slug":"开发工具","permalink":"https://niaoyu00.github.io/Blog/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"git","slug":"git","permalink":"https://niaoyu00.github.io/Blog/categories/git/"},{"name":"ue4","slug":"ue4","permalink":"https://niaoyu00.github.io/Blog/categories/ue4/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://niaoyu00.github.io/Blog/tags/Hexo/"},{"name":"vloantis","slug":"vloantis","permalink":"https://niaoyu00.github.io/Blog/tags/vloantis/"},{"name":"unity","slug":"unity","permalink":"https://niaoyu00.github.io/Blog/tags/unity/"},{"name":"动作游戏","slug":"动作游戏","permalink":"https://niaoyu00.github.io/Blog/tags/%E5%8A%A8%E4%BD%9C%E6%B8%B8%E6%88%8F/"},{"name":"像素画","slug":"像素画","permalink":"https://niaoyu00.github.io/Blog/tags/%E5%83%8F%E7%B4%A0%E7%94%BB/"},{"name":"美术","slug":"美术","permalink":"https://niaoyu00.github.io/Blog/tags/%E7%BE%8E%E6%9C%AF/"},{"name":"热更新","slug":"热更新","permalink":"https://niaoyu00.github.io/Blog/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"Addressables","slug":"Addressables","permalink":"https://niaoyu00.github.io/Blog/tags/Addressables/"},{"name":"AssetBundle","slug":"AssetBundle","permalink":"https://niaoyu00.github.io/Blog/tags/AssetBundle/"},{"name":"AB包","slug":"AB包","permalink":"https://niaoyu00.github.io/Blog/tags/AB%E5%8C%85/"},{"name":"lua","slug":"lua","permalink":"https://niaoyu00.github.io/Blog/tags/lua/"},{"name":"next","slug":"next","permalink":"https://niaoyu00.github.io/Blog/tags/next/"},{"name":"文章内置标签","slug":"文章内置标签","permalink":"https://niaoyu00.github.io/Blog/tags/%E6%96%87%E7%AB%A0%E5%86%85%E7%BD%AE%E6%A0%87%E7%AD%BE/"},{"name":"unity换装","slug":"unity换装","permalink":"https://niaoyu00.github.io/Blog/tags/unity%E6%8D%A2%E8%A3%85/"},{"name":"UIToolkit","slug":"UIToolkit","permalink":"https://niaoyu00.github.io/Blog/tags/UIToolkit/"},{"name":"arpg","slug":"arpg","permalink":"https://niaoyu00.github.io/Blog/tags/arpg/"},{"name":"unity脚本模板","slug":"unity脚本模板","permalink":"https://niaoyu00.github.io/Blog/tags/unity%E8%84%9A%E6%9C%AC%E6%A8%A1%E6%9D%BF/"},{"name":"unity生命周期","slug":"unity生命周期","permalink":"https://niaoyu00.github.io/Blog/tags/unity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"name":"awake","slug":"awake","permalink":"https://niaoyu00.github.io/Blog/tags/awake/"},{"name":"Csharp","slug":"Csharp","permalink":"https://niaoyu00.github.io/Blog/tags/Csharp/"},{"name":"二分查找","slug":"二分查找","permalink":"https://niaoyu00.github.io/Blog/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"顺序查找","slug":"顺序查找","permalink":"https://niaoyu00.github.io/Blog/tags/%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://niaoyu00.github.io/Blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"集合","slug":"集合","permalink":"https://niaoyu00.github.io/Blog/tags/%E9%9B%86%E5%90%88/"},{"name":"映射","slug":"映射","permalink":"https://niaoyu00.github.io/Blog/tags/%E6%98%A0%E5%B0%84/"},{"name":"麦克风","slug":"麦克风","permalink":"https://niaoyu00.github.io/Blog/tags/%E9%BA%A6%E5%85%8B%E9%A3%8E/"},{"name":"队列","slug":"队列","permalink":"https://niaoyu00.github.io/Blog/tags/%E9%98%9F%E5%88%97/"},{"name":"栈","slug":"栈","permalink":"https://niaoyu00.github.io/Blog/tags/%E6%A0%88/"},{"name":"数据结构","slug":"数据结构","permalink":"https://niaoyu00.github.io/Blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"搜索技巧","slug":"搜索技巧","permalink":"https://niaoyu00.github.io/Blog/tags/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/"},{"name":"阿里云","slug":"阿里云","permalink":"https://niaoyu00.github.io/Blog/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"图床","slug":"图床","permalink":"https://niaoyu00.github.io/Blog/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"时间复杂度","slug":"时间复杂度","permalink":"https://niaoyu00.github.io/Blog/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"name":"设计模式","slug":"设计模式","permalink":"https://niaoyu00.github.io/Blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"单例模式","slug":"单例模式","permalink":"https://niaoyu00.github.io/Blog/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"name":"开发笔记","slug":"开发笔记","permalink":"https://niaoyu00.github.io/Blog/tags/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"},{"name":"平台跳跃控制器","slug":"平台跳跃控制器","permalink":"https://niaoyu00.github.io/Blog/tags/%E5%B9%B3%E5%8F%B0%E8%B7%B3%E8%B7%83%E6%8E%A7%E5%88%B6%E5%99%A8/"},{"name":"OnGUI","slug":"OnGUI","permalink":"https://niaoyu00.github.io/Blog/tags/OnGUI/"},{"name":"Cinemachine Camera","slug":"Cinemachine-Camera","permalink":"https://niaoyu00.github.io/Blog/tags/Cinemachine-Camera/"},{"name":"VsCode","slug":"VsCode","permalink":"https://niaoyu00.github.io/Blog/tags/VsCode/"},{"name":"Invoke","slug":"Invoke","permalink":"https://niaoyu00.github.io/Blog/tags/Invoke/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://niaoyu00.github.io/Blog/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"ScriptableObject","slug":"ScriptableObject","permalink":"https://niaoyu00.github.io/Blog/tags/ScriptableObject/"},{"name":"git","slug":"git","permalink":"https://niaoyu00.github.io/Blog/tags/git/"},{"name":"塔防demo","slug":"塔防demo","permalink":"https://niaoyu00.github.io/Blog/tags/%E5%A1%94%E9%98%B2demo/"},{"name":"ue4材质","slug":"ue4材质","permalink":"https://niaoyu00.github.io/Blog/tags/ue4%E6%9D%90%E8%B4%A8/"}]}